###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.20.2.41139 for 8051             27/Mar/2014  17:05:51 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  D:\Texas Instruments\Z-Stack Lighting              #
#                          1.0.2\Components\mac\low_level\srf04\single_chip\m #
#                          ac_mcu.c                                           #
#    Command line       =  -f "D:\Texas Instruments\Z-Stack Lighting          #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\Tools\CC2530DB\f8wRouter.cfg" (-DCPU32MHZ        #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8       #
#                          -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f "D:\Texas         #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\Tools\CC2530DB\f8wConfig.cfg" (-DZIGBEEPRO       #
#                          -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR       #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100    #
#                          -DREJOIN_POLL_RATE=440) -f "D:\Texas               #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\Tools\CC2530DB\f8wZCL.cfg" "D:\Texas             #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Components\mac\low_level\srf04\single_chip\m #
#                          ac_mcu.c" -D FEATURE_GREEN_POWER -D SECURE=1 -D    #
#                          TC_LINKKEY_JOIN -D ZDSECMGR_TC_DEVICE_MAX=2 -D     #
#                          NV_RESTORE -D HOLD_AUTO_START -D INTER_PAN -D      #
#                          ZTOOL_P1 -D MT_TASK -D MT_APP_FUNC -D MT_SYS_FUNC  #
#                          -D MT_ZDO_FUNC -D MT_ZDO_CB_FUNC -D MT_UTIL_FUNC   #
#                          -D MT_ZDO_MGMT -D LCD_SUPPORTED -D HAL_LCD=FALSE   #
#                          -D HAL_KEY=FALSE -D ZCL_BASIC -D ZCL_READ -D       #
#                          ZCL_WRITE -D ZCL_IDENTIFY -D ZCL_ON_OFF -D         #
#                          ZCL_SCENES -D ZCL_GROUPS -D                        #
#                          ZCL_LIGHT_LINK_ENHANCE -D ZCL_LEVEL_CTRL -D        #
#                          ZCL_COLOR_CTRL -D xMAX_CHANNELS_24GHZ=0x02108800   #
#                          -lC "D:\Texas Instruments\Z-Stack Lighting         #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\BridgeE #
#                          B-Pro\List\" -lA "D:\Texas Instruments\Z-Stack     #
#                          Lighting 1.0.2\Projects\zstack\ZLL\SampleApp\CC253 #
#                          x\BridgeEB-Pro\List\" --diag_suppress Pe001,Pa010  #
#                          -o "D:\Texas Instruments\Z-Stack Lighting          #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\BridgeE #
#                          B-Pro\Obj\" -e --debug --core=plain --dptr=16,1    #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I "D:\Texas Instruments\Z-Stack Lighting          #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\" -I    #
#                          "D:\Texas Instruments\Z-Stack Lighting             #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\Sour #
#                          ce\" -I "D:\Texas Instruments\Z-Stack Lighting     #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\S #
#                          ource\" -I "D:\Texas Instruments\Z-Stack Lighting  #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\HomeAutomation\Source\" -I "D:\Texas             #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\HomeAutomation\SampleLight\Source\" -I           #
#                          "D:\Texas Instruments\Z-Stack Lighting             #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\ZMain\TI2530DB\" -I "D:\Texas                    #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\hal\include\" -I "D:\Texas      #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\hal\target\CC2530EB\" -I        #
#                          "D:\Texas Instruments\Z-Stack Lighting             #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mac\include\" -I "D:\Texas      #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mac\high_level\" -I "D:\Texas   #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mac\low_level\srf04\" -I        #
#                          "D:\Texas Instruments\Z-Stack Lighting             #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mac\low_level\srf04\single_chip #
#                          \" -I "D:\Texas Instruments\Z-Stack Lighting       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mt\" -I "D:\Texas               #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\osal\include\" -I "D:\Texas     #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\services\saddr\" -I "D:\Texas   #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\services\sdata\" -I "D:\Texas   #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\af\" -I "D:\Texas         #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\nwk\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\sapi\" -I "D:\Texas       #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\sec\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\sys\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\zcl\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\zdo\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\zmac\" -I "D:\Texas             #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\zmac\f8w\" -Ohz                 #
#                          --require_prototypes                               #
#    List file          =  D:\Texas Instruments\Z-Stack Lighting              #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\BridgeE #
#                          B-Pro\List\mac_mcu.lst                             #
#    Object file        =  D:\Texas Instruments\Z-Stack Lighting              #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\BridgeE #
#                          B-Pro\Obj\mac_mcu.r51                              #
#                                                                             #
#                                                                             #
###############################################################################

D:\Texas Instruments\Z-Stack Lighting 1.0.2\Components\mac\low_level\srf04\single_chip\mac_mcu.c
      1          /**************************************************************************************************
      2            Filename:       mac_mcu.c
      3            Revised:        $Date: 2013-05-17 11:08:52 -0700 (Fri, 17 May 2013) $
      4            Revision:       $Revision: 34354 $
      5          
      6            Description:    Describe the purpose and contents of the file.
      7          
      8          
      9            Copyright 2006-2013 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                          Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          
     45          /* hal */
     46          #include "hal_defs.h"
     47          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x91
   \   unsigned char volatile __sfr RFIRQF1
   \                     RFIRQF1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x94
   \   unsigned char volatile __sfr T2CTRL
   \                     T2CTRL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9a
   \   unsigned char volatile __sfr IEN2
   \                     IEN2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9b
   \   unsigned char volatile __sfr S1CON
   \                     S1CON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9e
   \   unsigned char volatile __sfr CLKCONSTA
   \                     CLKCONSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa1
   \   unsigned char volatile __sfr T2IRQF
   \                     T2IRQF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa2
   \   unsigned char volatile __sfr T2M0
   \                     T2M0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa3
   \   unsigned char volatile __sfr T2M1
   \                     T2M1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa4
   \   unsigned char volatile __sfr T2MOVF0
   \                     T2MOVF0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa5
   \   unsigned char volatile __sfr T2MOVF1
   \                     T2MOVF1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa6
   \   unsigned char volatile __sfr T2MOVF2
   \                     T2MOVF2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa7
   \   unsigned char volatile __sfr T2IRQM
   \                     T2IRQM:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa9
   \   unsigned char volatile __sfr IP0
   \                     IP0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb4
   \   unsigned char volatile __sfr ADCCON1
   \                     ADCCON1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb9
   \   unsigned char volatile __sfr IP1
   \                     IP1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbc
   \   unsigned char volatile __sfr RNDL
   \                     RNDL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbd
   \   unsigned char volatile __sfr RNDH
   \                     RNDH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbf
   \   unsigned char volatile __sfr RFERRF
   \                     RFERRF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc3
   \   unsigned char volatile __sfr T2MSEL
   \                     T2MSEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe9
   \   unsigned char volatile __sfr RFIRQF0
   \                     RFIRQF0:
   \   000000                DS 1
     48          
     49          /* low-level specific */
     50          #include "mac_rx.h"
     51          #include "mac_tx.h"
     52          #include "mac_backoff_timer.h"
     53          #include "mac_csp_tx.h"
     54          #include "mac_rx_onoff.h"
     55          #include "mac_low_level.h"
     56          
     57          /* target specific */
     58          #include "mac_mcu.h"
     59          #include "mac_radio_defs.h"
     60          
     61          /* debug */
     62          #include "mac_assert.h"
     63          
     64          /* high level */
     65          #include "mac_pib.h"
     66          
     67          /* ------------------------------------------------------------------------------------------------
     68           *                                           Defines
     69           * ------------------------------------------------------------------------------------------------
     70           */
     71          
     72          /* for optimized indexing of uint32's */
     73          #if HAL_MCU_LITTLE_ENDIAN()
     74          #define UINT32_NDX0   0
     75          #define UINT32_NDX1   1
     76          #define UINT32_NDX2   2
     77          #define UINT32_NDX3   3
     78          #else
     79          #define UINT32_NDX0   3
     80          #define UINT32_NDX1   2
     81          #define UINT32_NDX2   1
     82          #define UINT32_NDX3   0
     83          #endif
     84          
     85          /* ------------------------------------------------------------------------------------------------
     86           *                                        Local Variables
     87           * ------------------------------------------------------------------------------------------------
     88           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     89          uint8       macChipVersion = 0;
   \                     macChipVersion:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     90          static int8 maxRssi;
   \                     maxRssi:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     91          static uint32 prevAccumulatedOverflowCount = 0;
   \                     prevAccumulatedOverflowCount:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     92          static bool updateRolloverflag = FALSE;
   \                     updateRolloverflag:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     93          static uint32 prevoverflowCount = 0;
   \                     prevoverflowCount:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
     94          
     95          
     96          /*
     97           *  This number is used to calculate the precision count for OSAL timer update. In Beacon mode,
     98           *  the overflow count may be initialized to zero or to a constant. The "skip" in overflow count
     99           *  needs to be accounted for in this variable.
    100           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    101          static uint32 accumulatedOverflowCount = 0;
   \                     accumulatedOverflowCount:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
    102          
    103          /* Function pointer for the random seed callback */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    104          static macRNGFcn_t pRandomSeedCB = NULL;
   \                     pRandomSeedCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    105          /* ------------------------------------------------------------------------------------------------
    106           *                                       Local Prototypes
    107           * ------------------------------------------------------------------------------------------------
    108           */
    109          static void mcuRecordMaxRssiIsr(void);
    110          static uint32 macMcuOverflowGetCompare(void);
    111          void MAC_SetRandomSeedCB(macRNGFcn_t pCBFcn);
    112          
    113          /**************************************************************************************************
    114           * @fn          MAC_SetRandomSeedCB
    115           *
    116           * @brief       Set the function pointer for the random seed callback.
    117           *
    118           * @param       pCBFcn - function pointer of the random seed callback
    119           *
    120           * @return      none
    121           **************************************************************************************************
    122           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    123          void MAC_SetRandomSeedCB(macRNGFcn_t pCBFcn)
   \                     MAC_SetRandomSeedCB:
    124          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    125            pRandomSeedCB = pCBFcn;
   \   000004   90....       MOV     DPTR,#pRandomSeedCB
   \   000007   EA           MOV     A,R2
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   EB           MOV     A,R3
   \   00000B   F0           MOVX    @DPTR,A
    126          }
   \   00000C   80..         SJMP    ??Subroutine7_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine7_0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    127          
    128          /**************************************************************************************************
    129           * @fn          macMcuInit
    130           *
    131           * @brief       Initialize the MCU.
    132           *
    133           * @param       none
    134           *
    135           * @return      none
    136           **************************************************************************************************
    137           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    138          MAC_INTERNAL_API void macMcuInit(void)
   \                     macMcuInit:
    139          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    140            halIntState_t  s;
    141          
    142            /* This CORR_THR value should be changed to 0x14 before attempting RX. Testing has shown that
    143             * too many false frames are received if the reset value is used. Make it more likely to detect
    144             * sync by removing the requirement that both symbols in the SFD must have a correlation value
    145             * above the correlation threshold, and make sync word detection less likely by raising the
    146             * correlation threshold.
    147             */
    148            MDMCTRL1 = CORR_THR;
   \   00000A   9061A9       MOV     DPTR,#0x61a9
   \   00000D   7414         MOV     A,#0x14
   \   00000F   F0           MOVX    @DPTR,A
    149          
    150          #ifdef FEATURE_CC253X_LOW_POWER_RX
    151            /* Reduce RX power consumption current to 20mA at the cost of some sensitivity
    152             * Note: This feature can be applied to CC2530 and CC2533 only.
    153             */
    154            RXCTRL = 0x00;
    155            FSCTRL = 0x50;
    156          #else
    157            /* tuning adjustments for optimal radio performance; details available in datasheet */
    158            RXCTRL = 0x3F;
   \   000010   9061AB       MOV     DPTR,#0x61ab
   \   000013   743F         MOV     A,#0x3f
   \   000015   F0           MOVX    @DPTR,A
    159            
    160            /* Adjust current in synthesizer; details available in datasheet. */
    161            FSCTRL = 0x55;
   \   000016   A3           INC     DPTR
   \   000017   7455         MOV     A,#0x55
   \   000019   F0           MOVX    @DPTR,A
    162          #endif /* #ifdef FEATURE_CC253X_LOW_POWER_RX */ 
    163          
    164          #if !(defined HAL_PA_LNA || defined HAL_PA_LNA_CC2590)
    165            /* Raises the CCA threshold from about -108 dBm to about -80 dBm input level.
    166             */
    167            CCACTRL0 = CCA_THR;
   \   00001A   906196       MOV     DPTR,#0x6196
   \   00001D   74FC         MOV     A,#-0x4
   \   00001F   F0           MOVX    @DPTR,A
    168          #endif
    169          
    170            /* Makes sync word detection less likely by requiring two zero symbols before the sync word.
    171             * details available in datasheet.
    172             */
    173            MDMCTRL0 = 0x85;
   \   000020   9061A8       MOV     DPTR,#0x61a8
   \   000023   7485         MOV     A,#-0x7b
   \   000025   F0           MOVX    @DPTR,A
    174          
    175            /* In order to make a single library build, CC2533 specific accesses need to
    176             * be detected by reading the Chip ID
    177             */
    178            if ((*(uint8 *)(P_INFOPAGE+0x03) == 0x95) || (*(uint8 *)(P_INFOPAGE+0x03) == 0x34))
   \   000026   907803       MOV     DPTR,#0x7803
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F8           MOV     R0,A
   \   00002B   7495         MOV     A,#-0x6b
   \   00002D   68           XRL     A,R0
   \   00002E   6005         JZ      ??macMcuInit_0
   \   000030   7434         MOV     A,#0x34
   \   000032   68           XRL     A,R0
   \   000033   700C         JNZ     ??macMcuInit_1
    179            {
    180              /* In case the device is a 2533, just update the IVCTRL regoster which is 2533 specific */
    181              #define IVCTRL          XREG( 0x6265 )
    182              IVCTRL = 0xF;
   \                     ??macMcuInit_0:
   \   000035   906265       MOV     DPTR,#0x6265
   \   000038   740F         MOV     A,#0xf
   \   00003A   F0           MOVX    @DPTR,A
    183              CCACTRL0 = CCA_THR_CC2533; 
   \   00003B   906196       MOV     DPTR,#0x6196
   \   00003E   74F8         MOV     A,#-0x8
   \   000040   F0           MOVX    @DPTR,A
    184            }
    185          
    186            /* Adjust current in VCO; details available in datasheet. */
    187          #ifdef FEATURE_VCO_ALTERNATE_SETTING
    188            FSCAL1 = 0x80;
    189          #else
    190            FSCAL1 = 0x00;
   \                     ??macMcuInit_1:
   \   000041   9061AE       MOV     DPTR,#0x61ae
   \   000044   E4           CLR     A
   \   000045   F0           MOVX    @DPTR,A
    191          #endif
    192          
    193            /* Adjust target value for AGC control loop; details available in datasheet. */
    194            AGCCTRL1 = 0x15;
   \   000046   9061B2       MOV     DPTR,#0x61b2
   \   000049   7415         MOV     A,#0x15
   \   00004B   F0           MOVX    @DPTR,A
    195          
    196            /* Disable source address matching an autopend for now */
    197            SRCMATCH = 0;
   \   00004C   906182       MOV     DPTR,#0x6182
   \   00004F   E4           CLR     A
   \   000050   F0           MOVX    @DPTR,A
    198          
    199            /* Tune ADC performance, details available in datasheet. */
    200            ADCTEST0 = 0x10;
   \   000051   9061B5       MOV     DPTR,#0x61b5
   \   000054   7410         MOV     A,#0x10
   \   000056   F0           MOVX    @DPTR,A
    201            ADCTEST1 = 0x0E;
   \   000057   A3           INC     DPTR
   \   000058   740E         MOV     A,#0xe
   \   00005A   F0           MOVX    @DPTR,A
    202            ADCTEST2 = 0x03;
   \   00005B   A3           INC     DPTR
   \   00005C   7403         MOV     A,#0x3
   \   00005E   F0           MOVX    @DPTR,A
    203          
    204            /* Sets TX anti-aliasing filter to appropriate bandwidth.
    205             * Reduces spurious emissions close to signal.
    206             */
    207            TXFILTCFG = TXFILTCFG_RESET_VALUE;
   \   00005F   9061FA       MOV     DPTR,#0x61fa
   \   000062   7409         MOV     A,#0x9
   \   000064   F0           MOVX    @DPTR,A
    208          
    209            /* disable the CSPT register compare function */
    210            CSPT = 0xFF;
   \   000065   9061E5       MOV     DPTR,#0x61e5
   \   000068   74FF         MOV     A,#-0x1
   \   00006A   F0           MOVX    @DPTR,A
    211          
    212            /* enable general RF interrupts */
    213            IEN2 |= RFIE;
   \   00006B   439A01       ORL     0x9a,#0x1
    214          
    215            /* enable general REERR interrupts */
    216            IEN0 |= RFERRIE;
   \   00006E   D2A8         SETB    0xa8.0
    217          
    218            /* set RF interrupts one notch above lowest priority (four levels available) */
    219            IP0 |=  IP_RFERR_RF_DMA_BV;
   \   000070   43A901       ORL     0xa9,#0x1
    220            IP1 &= ~IP_RFERR_RF_DMA_BV;
   \   000073   53B9FE       ANL     0xb9,#0xfe
    221          
    222            /* set T2 interrupts one notch above lowest priority (four levels available)
    223             * This effectively turned off nested interrupt between T2 and RF.
    224             */
    225            IP0 |=  IP_RXTX0_T2_BV;
   \   000076   43A904       ORL     0xa9,#0x4
    226            IP1 &= ~IP_RXTX0_T2_BV;
   \   000079   53B9FB       ANL     0xb9,#0xfb
    227          
    228            /* read chip version */
    229            macChipVersion = CHVER;
   \   00007C   906249       MOV     DPTR,#0x6249
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   90....       MOV     DPTR,#macChipVersion
   \   000083   F0           MOVX    @DPTR,A
    230          
    231            /*-------------------------------------------------------------------------------
    232             *  Initialize MAC timer.
    233             */
    234          
    235            /* set timer rollover */
    236            HAL_ENTER_CRITICAL_SECTION(s);
   \   000084   E5A8         MOV     A,0xa8
   \   000086   C2AF         CLR     0xa8.7
    237            MAC_MCU_T2_ACCESS_PERIOD_VALUE();
   \   000088   75C302       MOV     0xc3,#0x2
    238            T2M0 = MAC_RADIO_TIMER_TICKS_PER_BACKOFF() & 0xFF;
   \   00008B   75A200       MOV     0xa2,#0x0
    239            T2M1 = MAC_RADIO_TIMER_TICKS_PER_BACKOFF() >> 8;
   \   00008E   75A328       MOV     0xa3,#0x28
    240            HAL_EXIT_CRITICAL_SECTION(s);
   \   000091   A2E7         MOV     C,0xE0 /* A   */.7
   \   000093   A2E7         MOV     C,0xE0 /* A   */.7
   \   000095   92AF         MOV     0xa8.7,C
    241          
    242            /* start timer */
    243            MAC_RADIO_TIMER_WAKE_UP();
   \                     ??macMcuInit_2:
   \   000097   E59E         MOV     A,0x9e
   \   000099   70FC         JNZ     ??macMcuInit_2
   \   00009B   439403       ORL     0x94,#0x3
   \                     ??macMcuInit_3:
   \   00009E   E594         MOV     A,0x94
   \   0000A0   A2E2         MOV     C,0xE0 /* A   */.2
   \   0000A2   50FA         JNC     ??macMcuInit_3
    244          
    245            /* Enable latch mode and T2 SYNC start. OSAL timer is based on MAC timer.
    246             * The SYNC start msut be on when POWER_SAVING is on for this design to work.
    247             */
    248            T2CTRL |= (LATCH_MODE | TIMER2_SYNC);
   \   0000A4   43940A       ORL     0x94,#0xa
    249          
    250            /* enable timer interrupts */
    251            T2IE = 1;
   \   0000A7   D2BA         SETB    0xb8.2
    252          
    253           /*----------------------------------------------------------------------------------------------
    254            *  Initialize random seed value.
    255            */
    256          
    257            /*
    258             *  Set radio for infinite reception.  Once radio reaches this state,
    259             *  it will stay in receive mode regardless RF activity.
    260             */
    261            FRMCTRL0 = FRMCTRL0_RESET_VALUE | RX_MODE_INFINITE_RECEPTION;
   \   0000A9   906189       MOV     DPTR,#0x6189
   \   0000AC   7448         MOV     A,#0x48
   \   0000AE   F0           MOVX    @DPTR,A
    262          
    263            /* turn on the receiver */
    264            macRxOn();
   \   0000AF                ; Setup parameters for call to function macRxOn
   \   0000AF   12....       LCALL   ??macRxOn?relay
    265          
    266            /*
    267             *  Wait for radio to reach infinite reception state by checking RSSI valid flag.
    268             *  Once it does, the least significant bit of ADTSTH should be pretty random.
    269             */
    270            while (!(RSSISTAT & 0x01));
   \                     ??macMcuInit_4:
   \   0000B2   906199       MOV     DPTR,#0x6199
   \   0000B5   E0           MOVX    A,@DPTR
   \   0000B6   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000B8   50F8         JNC     ??macMcuInit_4
    271          
    272            /* put 16 random bits into the seed value */
    273            {
    274              uint16 rndSeed;
    275              uint8  i;
    276              rndSeed = 0;
   \   0000BA   7800         MOV     R0,#0x0
   \   0000BC   7900         MOV     R1,#0x0
    277          
    278              for(i=0; i<16; i++)
   \   0000BE   7C10         MOV     R4,#0x10
    279              {
    280                /* use most random bit of analog to digital receive conversion to populate the random seed */
    281                rndSeed = (rndSeed << 1) | (RFRND & 0x01);
   \                     ??macMcuInit_5:
   \   0000C0   E8           MOV     A,R0
   \   0000C1   C3           CLR     C
   \   0000C2   33           RLC     A
   \   0000C3   F8           MOV     R0,A
   \   0000C4   E9           MOV     A,R1
   \   0000C5   33           RLC     A
   \   0000C6   F9           MOV     R1,A
   \   0000C7   9061A7       MOV     DPTR,#0x61a7
   \   0000CA   E0           MOVX    A,@DPTR
   \   0000CB   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000CD   E4           CLR     A
   \   0000CE   33           RLC     A
   \   0000CF   FA           MOV     R2,A
   \   0000D0   E8           MOV     A,R0
   \   0000D1   4A           ORL     A,R2
   \   0000D2   F8           MOV     R0,A
    282              }
   \   0000D3   1C           DEC     R4
   \   0000D4   EC           MOV     A,R4
   \   0000D5   70E9         JNZ     ??macMcuInit_5
    283          
    284              /*
    285               *  The seed value must not be zero or 0x0380 (0x8003 in the polynomial).  If it is, the psuedo
    286               *  random sequence won’t be random.  There is an extremely small chance this seed could randomly
    287               *  be zero or 0x0380.  The following check makes sure this does not happen.
    288               */
    289              if (rndSeed == 0x0000 || rndSeed == 0x0380)
   \   0000D7   E8           MOV     A,R0
   \   0000D8   49           ORL     A,R1
   \   0000D9   600A         JZ      ??macMcuInit_6
   \   0000DB   7480         MOV     A,#-0x80
   \   0000DD   68           XRL     A,R0
   \   0000DE   7003         JNZ     ??macMcuInit_7
   \   0000E0   7403         MOV     A,#0x3
   \   0000E2   69           XRL     A,R1
   \                     ??macMcuInit_7:
   \   0000E3   7004         JNZ     ??macMcuInit_8
    290              {
    291                rndSeed = 0xBABE; /* completely arbitrary "random" value */
   \                     ??macMcuInit_6:
   \   0000E5   78BE         MOV     R0,#-0x42
   \   0000E7   79BA         MOV     R1,#-0x46
    292              }
    293          
    294              /*
    295               *  Two writes to RNDL will set the random seed.  A write to RNDL copies current contents
    296               *  of RNDL to RNDH before writing new the value to RNDL.
    297               */
    298              RNDL = rndSeed & 0xFF;
   \                     ??macMcuInit_8:
   \   0000E9   E8           MOV     A,R0
   \   0000EA   F5BC         MOV     0xbc,A
    299              RNDL = rndSeed >> 8;
   \   0000EC   E9           MOV     A,R1
   \   0000ED   F5BC         MOV     0xbc,A
    300            }
    301          
    302            /* Read MAC_RANDOM_SEED_LEN*8 random bits and store them in flash for
    303             * future use in random key generation for CBKE key establishment
    304             */
    305            if( pRandomSeedCB )
   \   0000EF   90....       MOV     DPTR,#pRandomSeedCB
   \   0000F2   E0           MOVX    A,@DPTR
   \   0000F3   F8           MOV     R0,A
   \   0000F4   A3           INC     DPTR
   \   0000F5   E0           MOVX    A,@DPTR
   \   0000F6   F9           MOV     R1,A
   \   0000F7   E8           MOV     A,R0
   \   0000F8   49           ORL     A,R1
   \   0000F9   604C         JZ      ??macMcuInit_9
    306            {
    307              uint8 randomSeed[MAC_RANDOM_SEED_LEN];
    308              uint8 i,j;
    309          
    310              for(i = 0; i < MAC_RANDOM_SEED_LEN; i++)
   \   0000FB   7800         MOV     R0,#0x0
    311              {
    312                uint8 rndByte = 0;
   \                     ??macMcuInit_10:
   \   0000FD   7B00         MOV     R3,#0x0
    313                for(j = 0; j < 8; j++)
   \   0000FF   7A08         MOV     R2,#0x8
    314                {
    315                  /* use most random bit of analog to digital receive conversion to
    316                     populate the random seed */
    317                  rndByte = (rndByte << 1) | (RFRND & 0x01);
   \                     ??macMcuInit_11:
   \   000101   9061A7       MOV     DPTR,#0x61a7
   \   000104   E0           MOVX    A,@DPTR
   \   000105   A2E0         MOV     C,0xE0 /* A   */.0
   \   000107   E4           CLR     A
   \   000108   33           RLC     A
   \   000109   F9           MOV     R1,A
   \   00010A   EB           MOV     A,R3
   \   00010B   33           RLC     A
   \   00010C   49           ORL     A,R1
   \   00010D   FB           MOV     R3,A
    318                }
   \   00010E   1A           DEC     R2
   \   00010F   EA           MOV     A,R2
   \   000110   70EF         JNZ     ??macMcuInit_11
    319                randomSeed[i] = rndByte;
   \   000112   88..         MOV     ?V0 + 0,R0
   \   000114   85..82       MOV     DPL,?XSP + 0
   \   000117   85..83       MOV     DPH,?XSP + 1
   \   00011A   E582         MOV     A,DPL
   \   00011C   25..         ADD     A,?V0 + 0
   \   00011E   F582         MOV     DPL,A
   \   000120   E583         MOV     A,DPH
   \   000122   3400         ADDC    A,#0x0
   \   000124   F583         MOV     DPH,A
   \   000126   EB           MOV     A,R3
   \   000127   F0           MOVX    @DPTR,A
    320          
    321              }
   \   000128   08           INC     R0
   \   000129   E8           MOV     A,R0
   \   00012A   C3           CLR     C
   \   00012B   9420         SUBB    A,#0x20
   \   00012D   40CE         JC      ??macMcuInit_10
    322              pRandomSeedCB( randomSeed );
   \   00012F                ; Setup parameters for indirect call
   \   00012F   85..82       MOV     DPL,?XSP + 0
   \   000132   85..83       MOV     DPH,?XSP + 1
   \   000135   AA82         MOV     R2,DPL
   \   000137   AB83         MOV     R3,DPH
   \   000139   90....       MOV     DPTR,#pRandomSeedCB
   \   00013C   E0           MOVX    A,@DPTR
   \   00013D   F8           MOV     R0,A
   \   00013E   A3           INC     DPTR
   \   00013F   E0           MOVX    A,@DPTR
   \   000140   F583         MOV     DPH,A
   \   000142   8882         MOV     DPL,R0
   \   000144   12....       LCALL   ?CALL_IND
    323            }
    324          
    325            /* turn off the receiver */
    326            macRxOff();
   \                     ??macMcuInit_9:
   \   000147                ; Setup parameters for call to function macRxOff
   \   000147   12....       LCALL   ??macRxOff?relay
    327          
    328            /* take receiver out of infinite reception mode; set back to normal operation */
    329            FRMCTRL0 = FRMCTRL0_RESET_VALUE | RX_MODE_NORMAL_OPERATION;
   \   00014A   906189       MOV     DPTR,#0x6189
   \   00014D   7440         MOV     A,#0x40
   \   00014F   F0           MOVX    @DPTR,A
    330          
    331            /* Turn on autoack */
    332            MAC_RADIO_TURN_ON_AUTO_ACK();
   \   000150   E0           MOVX    A,@DPTR
   \   000151   D2E5         SETB    0xE0 /* A   */.5
   \   000153   F0           MOVX    @DPTR,A
    333          
    334            /* Initialize SRCEXTPENDEN and SRCSHORTPENDEN to zeros */
    335            MAC_RADIO_SRC_MATCH_INIT_EXTPENDEN();
   \   000154   906164       MOV     DPTR,#0x6164
   \   000157   E4           CLR     A
   \   000158   F0           MOVX    @DPTR,A
   \   000159   A3           INC     DPTR
   \   00015A   F0           MOVX    @DPTR,A
   \   00015B   A3           INC     DPTR
   \   00015C   F0           MOVX    @DPTR,A
    336            MAC_RADIO_SRC_MATCH_INIT_SHORTPENDEN();
   \   00015D   A3           INC     DPTR
   \   00015E   F0           MOVX    @DPTR,A
   \   00015F   A3           INC     DPTR
   \   000160   F0           MOVX    @DPTR,A
   \   000161   A3           INC     DPTR
   \   000162   F0           MOVX    @DPTR,A
    337          }
   \   000163   7420         MOV     A,#0x20
   \   000165   12....       LCALL   ?DEALLOC_XSTACK8
   \   000168   7F02         MOV     R7,#0x2
   \   00016A   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   00016D                REQUIRE IEN2
   \   00016D                REQUIRE _A_IEN0
   \   00016D                REQUIRE IP0
   \   00016D                REQUIRE IP1
   \   00016D                REQUIRE T2MSEL
   \   00016D                REQUIRE T2M0
   \   00016D                REQUIRE T2M1
   \   00016D                REQUIRE CLKCONSTA
   \   00016D                REQUIRE T2CTRL
   \   00016D                REQUIRE _A_IEN1
   \   00016D                REQUIRE RNDL
    338          
    339          
    340          /**************************************************************************************************
    341           * @fn          macMcuRandomByte
    342           *
    343           * @brief       Returns a random byte using a special hardware feature that generates new
    344           *              random values based on the truly random seed set earlier.
    345           *
    346           * @param       none
    347           *
    348           * @return      a random byte
    349           **************************************************************************************************
    350           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    351          MAC_INTERNAL_API uint8 macMcuRandomByte(void)
   \                     macMcuRandomByte:
    352          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    353            /* clock the random generator to get a new random value */
    354            ADCCON1 = (ADCCON1 & ~RCTRL_BITS) | RCTRL_CLOCK_LFSR;
   \   000000   12....       LCALL   ?Subroutine4 & 0xFFFF
    355          
    356            /* return new randomized value from hardware */
    357            return(RNDH);
   \                     ??CrossCallReturnLabel_2:
   \   000003   02....       LJMP    ?BRET
   \   000006                REQUIRE ADCCON1
   \   000006                REQUIRE RNDH
    358          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   E5B4         MOV     A,0xb4
   \   000002   54F3         ANL     A,#0xf3
   \   000004   4404         ORL     A,#0x4
   \   000006   F5B4         MOV     0xb4,A
   \   000008   E5BD         MOV     A,0xbd
   \   00000A   F9           MOV     R1,A
   \   00000B   22           RET
    359          
    360          
    361          /**************************************************************************************************
    362           * @fn          macMcuRandomWord
    363           *
    364           * @brief       Returns a random word using a special hardware feature that generates new
    365           *              random values based on the truly random seed set earlier.
    366           *
    367           * @param       none
    368           *
    369           * @return      a random word
    370           **************************************************************************************************
    371           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    372          MAC_INTERNAL_API uint16 macMcuRandomWord(void)
   \                     macMcuRandomWord:
    373          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    374            uint16 random_word;
    375          
    376            /* clock the random generator to get a new random value */
    377            ADCCON1 = (ADCCON1 & ~RCTRL_BITS) | RCTRL_CLOCK_LFSR;
   \   000000   12....       LCALL   ?Subroutine4 & 0xFFFF
    378          
    379            /* read random word */
    380            random_word  = (RNDH << 8);
    381            random_word +=  RNDL;
    382          
    383            /* return new randomized value from hardware */
    384            return(random_word);
   \                     ??CrossCallReturnLabel_3:
   \   000003   E5BC         MOV     A,0xbc
   \   000005   FA           MOV     R2,A
   \   000006   E9           MOV     A,R1
   \   000007   FB           MOV     R3,A
   \   000008   02....       LJMP    ?BRET
   \   00000B                REQUIRE ADCCON1
   \   00000B                REQUIRE RNDH
   \   00000B                REQUIRE RNDL
    385          }
    386          
    387          
    388          /**************************************************************************************************
    389           * @fn          macMcuTimerForceDelay
    390           *
    391           * @brief       Delay the timer by the requested number of ticks.
    392           *
    393           * @param       none
    394           *
    395           * @return      none
    396           **************************************************************************************************
    397           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    398          MAC_INTERNAL_API void macMcuTimerForceDelay(uint16 x)
   \                     macMcuTimerForceDelay:
    399          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    400            halIntState_t  s;
    401          
    402            HAL_ENTER_CRITICAL_SECTION(s);
   \   000000   E5A8         MOV     A,0xa8
   \   000002   F8           MOV     R0,A
   \   000003   C2AF         CLR     0xa8.7
    403            MAC_MCU_T2_ACCESS_COUNT_VALUE();
   \   000005   75C300       MOV     0xc3,#0x0
    404            T2M0 = (x) & 0xFF;
   \   000008   EA           MOV     A,R2
   \   000009   F5A2         MOV     0xa2,A
    405            T2M1 = (x) >> 8;
   \   00000B   EB           MOV     A,R3
   \   00000C   F5A3         MOV     0xa3,A
    406            HAL_EXIT_CRITICAL_SECTION(s);
   \   00000E   E8           MOV     A,R0
   \   00000F   A2E7         MOV     C,0xE0 /* A   */.7
   \   000011   A2E7         MOV     C,0xE0 /* A   */.7
   \   000013   92AF         MOV     0xa8.7,C
    407          }
   \   000015   02....       LJMP    ?BRET
   \   000018                REQUIRE _A_IEN0
   \   000018                REQUIRE T2MSEL
   \   000018                REQUIRE T2M0
   \   000018                REQUIRE T2M1
    408          
    409          /**************************************************************************************************
    410           * @fn          macMcuTimerCapture
    411           *
    412           * @brief       Returns the last timer capture.  This capture should have occurred at the
    413           *              receive time of the last frame (the last time SFD transitioned to active).
    414           *
    415           * @param       none
    416           *
    417           * @return      last capture of hardware timer (full 16-bit value)
    418           **************************************************************************************************
    419           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    420          MAC_INTERNAL_API uint16 macMcuTimerCapture(void)
   \                     macMcuTimerCapture:
    421          {
   \   000000   C0..         PUSH    ?V0 + 0
   \   000002                ; Saved register size: 2
   \   000002                ; Auto size: 0
    422            uint16         timerCapture;
    423            halIntState_t  s;
    424          
    425            HAL_ENTER_CRITICAL_SECTION(s);
   \   000002   E5A8         MOV     A,0xa8
   \   000004   F8           MOV     R0,A
   \   000005   C2AF         CLR     0xa8.7
    426            MAC_MCU_T2_ACCESS_CAPTURE_VALUE();
   \   000007   75C301       MOV     0xc3,#0x1
    427            timerCapture = T2M1 << 8;
   \   00000A   E5A3         MOV     A,0xa3
   \   00000C   F9           MOV     R1,A
    428            timerCapture |= T2M0;
   \   00000D   E5A2         MOV     A,0xa2
   \   00000F   F5..         MOV     ?V0 + 0,A
    429            HAL_EXIT_CRITICAL_SECTION(s);
   \   000011   E8           MOV     A,R0
   \   000012   A2E7         MOV     C,0xE0 /* A   */.7
   \   000014   A2E7         MOV     C,0xE0 /* A   */.7
   \   000016   92AF         MOV     0xa8.7,C
    430          
    431            return (timerCapture);
   \   000018   AA..         MOV     R2,?V0 + 0
   \   00001A   E9           MOV     A,R1
   \   00001B   FB           MOV     R3,A
   \   00001C   D0..         POP     ?V0 + 0
   \   00001E   02....       LJMP    ?BRET
   \   000021                REQUIRE _A_IEN0
   \   000021                REQUIRE T2MSEL
   \   000021                REQUIRE T2M1
   \   000021                REQUIRE T2M0
    432          }
    433          
    434          
    435          /**************************************************************************************************
    436           * @fn          macMcuOverflowCount
    437           *
    438           * @brief       Returns the value of the overflow counter which is a special hardware feature.
    439           *              The overflow count actually is 24 bits of information.
    440           *
    441           * @param       none
    442           *
    443           * @return      value of overflow counter
    444           **************************************************************************************************
    445           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   E5A4         MOV     A,0xa4
   \   000002   85..82       MOV     DPL,?XSP + 0
   \   000005   85..83       MOV     DPH,?XSP + 1
   \   000008   F0           MOVX    @DPTR,A
   \   000009   E5A5         MOV     A,0xa5
   \   00000B   C0E0         PUSH    A
   \   00000D   7401         MOV     A,#0x1
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   D0E0         POP     A
   \   000014   F0           MOVX    @DPTR,A
   \   000015   E5A6         MOV     A,0xa6
   \   000017   C0E0         PUSH    A
   \   000019   7402         MOV     A,#0x2
   \   00001B   12....       LCALL   ?XSTACK_DISP0_8
   \   00001E   D0E0         POP     A
   \   000020   F0           MOVX    @DPTR,A
   \   000021   7403         MOV     A,#0x3
   \   000023   12....       LCALL   ?XSTACK_DISP0_8
   \   000026   E4           CLR     A
   \   000027   F0           MOVX    @DPTR,A
   \   000028   E8           MOV     A,R0
   \   000029   A2E7         MOV     C,0xE0 /* A   */.7
   \   00002B   A2E7         MOV     C,0xE0 /* A   */.7
   \   00002D   92AF         MOV     0xa8.7,C
   \   00002F   85..82       MOV     DPL,?XSP + 0
   \   000032   85..83       MOV     DPH,?XSP + 1
   \   000035   12....       LCALL   ?XLOAD_R2345
   \   000038   7404         MOV     A,#0x4
   \   00003A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003D                REQUIRE ??Subroutine7_0
   \   00003D                ; // Fall through to label ??Subroutine7_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    446          MAC_INTERNAL_API uint32 macMcuOverflowCount(void)
   \                     macMcuOverflowCount:
    447          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 4
   \   000004   74FC         MOV     A,#-0x4
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    448            uint32         overflowCount;
    449            halIntState_t  s;
    450          
    451            /* for efficiency, the 32-bit value is encoded using endian abstracted indexing */
    452          
    453            HAL_ENTER_CRITICAL_SECTION(s);
   \   000009   E5A8         MOV     A,0xa8
   \   00000B   F8           MOV     R0,A
   \   00000C   C2AF         CLR     0xa8.7
    454          
    455            /* This T2 access macro allows accessing both T2MOVFx and T2Mx */
    456            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
   \   00000E   75C300       MOV     0xc3,#0x0
    457          
    458            /* Latch the entire T2MOVFx first by reading T2M0. */
    459            T2M0;
   \   000011   E5A2         MOV     A,0xa2
    460            ((uint8 *)&overflowCount)[UINT32_NDX0] = T2MOVF0;
   \   000013   02....       LJMP    ?Subroutine0 & 0xFFFF
   \   000016                REQUIRE _A_IEN0
   \   000016                REQUIRE T2MSEL
   \   000016                REQUIRE T2M0
   \   000016                REQUIRE T2MOVF0
   \   000016                REQUIRE T2MOVF1
   \   000016                REQUIRE T2MOVF2
    461            ((uint8 *)&overflowCount)[UINT32_NDX1] = T2MOVF1;
    462            ((uint8 *)&overflowCount)[UINT32_NDX2] = T2MOVF2;
    463            ((uint8 *)&overflowCount)[UINT32_NDX3] = 0;
    464            HAL_EXIT_CRITICAL_SECTION(s);
    465          
    466            return (overflowCount);
    467          }
    468          
    469          
    470          /**************************************************************************************************
    471           * @fn          macMcuOverflowCapture
    472           *
    473           * @brief       Returns the last capture of the overflow counter.  A special hardware feature
    474           *              captures the overflow counter when the regular hardware timer is captured.
    475           *
    476           * @param       none
    477           *
    478           * @return      last capture of overflow count
    479           **************************************************************************************************
    480           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    481          MAC_INTERNAL_API uint32 macMcuOverflowCapture(void)
   \                     macMcuOverflowCapture:
    482          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 4
   \   000004   74FC         MOV     A,#-0x4
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    483            uint32         overflowCapture;
    484            halIntState_t  s;
    485          
    486            /* for efficiency, the 32-bit value is encoded using endian abstracted indexing */
    487            HAL_ENTER_CRITICAL_SECTION(s);
   \   000009   E5A8         MOV     A,0xa8
   \   00000B   F8           MOV     R0,A
   \   00000C   C2AF         CLR     0xa8.7
    488            MAC_MCU_T2_ACCESS_OVF_CAPTURE_VALUE();
   \   00000E   75C310       MOV     0xc3,#0x10
    489            ((uint8 *)&overflowCapture)[UINT32_NDX0] = T2MOVF0;
   \   000011   02....       LJMP    ?Subroutine0 & 0xFFFF
   \   000014                REQUIRE _A_IEN0
   \   000014                REQUIRE T2MSEL
   \   000014                REQUIRE T2MOVF0
   \   000014                REQUIRE T2MOVF1
   \   000014                REQUIRE T2MOVF2
    490            ((uint8 *)&overflowCapture)[UINT32_NDX1] = T2MOVF1;
    491            ((uint8 *)&overflowCapture)[UINT32_NDX2] = T2MOVF2;
    492            ((uint8 *)&overflowCapture)[UINT32_NDX3] = 0;
    493            HAL_EXIT_CRITICAL_SECTION(s);
    494          
    495            return (overflowCapture);
    496          }
    497          
    498          
    499          /**************************************************************************************************
    500           * @fn          macMcuOverflowSetCount
    501           *
    502           * @brief       Sets the value of the hardware overflow counter.
    503           *
    504           * @param       count - new overflow count value
    505           *
    506           * @return      none
    507           **************************************************************************************************
    508           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    509          MAC_INTERNAL_API void macMcuOverflowSetCount(uint32 count)
   \                     macMcuOverflowSetCount:
    510          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   12....       LCALL   ?Subroutine6 & 0xFFFF
    511            halIntState_t  s;
    512          
    513            MAC_ASSERT(! (count >> 24) );   /* illegal count value */
   \                     ??CrossCallReturnLabel_7:
   \   00000D   85..82       MOV     DPL,?XSP + 0
   \   000010   85..83       MOV     DPH,?XSP + 1
   \   000013   78..         MOV     R0,#?V0 + 0
   \   000015   12....       LCALL   ?L_MOV_X
   \   000018   90....       MOV     DPTR,#__Constant_ff000000
   \   00001B   78..         MOV     R0,#?V0 + 0
   \   00001D   12....       LCALL   ?L_AND_X
   \   000020   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000023   6003         JZ      ??macMcuOverflowSetCount_0
   \   000025                ; Setup parameters for call to function halAssertHandler
   \   000025   12....       LCALL   ??halAssertHandler?relay
    514          
    515            /* save the current overflow count */
    516            accumulatedOverflowCount += macMcuOverflowCount();
    517          
    518            /* deduct the initial count */
    519            accumulatedOverflowCount -= count;
   \                     ??macMcuOverflowSetCount_0:
   \   000028   90....       MOV     DPTR,#accumulatedOverflowCount
   \   00002B   C082         PUSH    DPL
   \   00002D   C083         PUSH    DPH
   \   00002F                ; Setup parameters for call to function macMcuOverflowCount
   \   00002F   12....       LCALL   ??macMcuOverflowCount?relay
   \   000032   8A..         MOV     ?V0 + 0,R2
   \   000034   8B..         MOV     ?V0 + 1,R3
   \   000036   8C..         MOV     ?V0 + 2,R4
   \   000038   8D..         MOV     ?V0 + 3,R5
   \   00003A   D083         POP     DPH
   \   00003C   D082         POP     DPL
   \   00003E   78..         MOV     R0,#?V0 + 0
   \   000040   12....       LCALL   ?L_ADD_X
   \   000043   85..82       MOV     DPL,?XSP + 0
   \   000046   85..83       MOV     DPH,?XSP + 1
   \   000049   78..         MOV     R0,#?V0 + 0
   \   00004B   12....       LCALL   ?L_SUB_X
   \   00004E   90....       MOV     DPTR,#accumulatedOverflowCount
   \   000051   78..         MOV     R0,#?V0 + 0
   \   000053   12....       LCALL   ?L_MOV_TO_X
    520          
    521            HAL_ENTER_CRITICAL_SECTION(s);
   \   000056   E5A8         MOV     A,0xa8
   \   000058   F8           MOV     R0,A
   \   000059   C2AF         CLR     0xa8.7
    522            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
   \   00005B   75C300       MOV     0xc3,#0x0
    523          
    524            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    525            /* T2OF2 must be written last */
    526            T2MOVF0 = ((uint8 *)&count)[UINT32_NDX0];
   \   00005E   85..82       MOV     DPL,?XSP + 0
   \   000061   85..83       MOV     DPH,?XSP + 1
   \   000064   E0           MOVX    A,@DPTR
   \   000065   F5A4         MOV     0xa4,A
    527            T2MOVF1 = ((uint8 *)&count)[UINT32_NDX1];
   \   000067   7401         MOV     A,#0x1
   \   000069   12....       LCALL   ?XSTACK_DISP0_8
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   F5A5         MOV     0xa5,A
    528            T2MOVF2 = ((uint8 *)&count)[UINT32_NDX2];
   \   00006F   7402         MOV     A,#0x2
   \   000071   12....       LCALL   ?XSTACK_DISP0_8
   \   000074   E0           MOVX    A,@DPTR
   \   000075   F5A6         MOV     0xa6,A
    529            HAL_EXIT_CRITICAL_SECTION(s);
   \   000077   E8           MOV     A,R0
   \   000078   A2E7         MOV     C,0xE0 /* A   */.7
   \   00007A   A2E7         MOV     C,0xE0 /* A   */.7
   \   00007C   02....       LJMP    ??Subroutine8_0 & 0xFFFF
   \   00007F                REQUIRE _A_IEN0
   \   00007F                REQUIRE T2MSEL
   \   00007F                REQUIRE T2MOVF0
   \   00007F                REQUIRE T2MOVF1
   \   00007F                REQUIRE T2MOVF2
    530          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   E5..         MOV     A,?V0 + 0
   \   000002   45..         ORL     A,?V0 + 1
   \   000004   45..         ORL     A,?V0 + 2
   \   000006   45..         ORL     A,?V0 + 3
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   EA           MOV     A,R2
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   EB           MOV     A,R3
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   EC           MOV     A,R4
   \   00000D   F0           MOVX    @DPTR,A
   \   00000E   A3           INC     DPTR
   \   00000F   ED           MOV     A,R5
   \   000010   F0           MOVX    @DPTR,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine8_0:
   \   000000   92AF         MOV     0xa8.7,C
   \   000002                REQUIRE ??Subroutine9_0
   \   000002                ; // Fall through to label ??Subroutine9_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine9_0:
   \   000000   7404         MOV     A,#0x4
   \   000002   12....       LCALL   ?DEALLOC_XSTACK8
   \   000005                REQUIRE ??Subroutine10_0
   \   000005                ; // Fall through to label ??Subroutine10_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine10_0:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    531          
    532          
    533          /**************************************************************************************************
    534           * @fn          macMcuOverflowSetCompare
    535           *
    536           * @brief       Set overflow count compare value.  An interrupt is triggered when the overflow
    537           *              count equals this compare value.
    538           *
    539           * @param       count - overflow count compare value
    540           *
    541           * @return      none
    542           **************************************************************************************************
    543           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    544          MAC_INTERNAL_API void macMcuOverflowSetCompare(uint32 count)
   \                     macMcuOverflowSetCompare:
    545          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   12....       LCALL   ?Subroutine3 & 0xFFFF
    546            halIntState_t  s;
    547            uint8 enableCompareInt = 0;
    548          
    549            MAC_ASSERT( !(count >> 24) );   /* illegal count value */
   \                     ??CrossCallReturnLabel_0:
   \   00000D   12....       LCALL   ?L_MOV_X
   \   000010   90....       MOV     DPTR,#__Constant_ff000000
   \   000013   78..         MOV     R0,#?V0 + 0
   \   000015   12....       LCALL   ?L_AND_X
   \   000018   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   00001B   6003         JZ      ??macMcuOverflowSetCompare_0
   \   00001D                ; Setup parameters for call to function halAssertHandler
   \   00001D   12....       LCALL   ??halAssertHandler?relay
    550          
    551            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??macMcuOverflowSetCompare_0:
   \   000020   A2AF         MOV     C,0xa8.7
   \   000022   E4           CLR     A
   \   000023   33           RLC     A
   \   000024   F8           MOV     R0,A
   \   000025   C2AF         CLR     0xa8.7
    552          
    553            /*  Disable overflow compare interrupts. */
    554            if (T2IRQM & TIMER2_OVF_COMPARE1M)
   \   000027   E5A7         MOV     A,0xa7
   \   000029   A2E4         MOV     C,0xE0 /* A   */.4
   \   00002B   5004         JNC     ??macMcuOverflowSetCompare_1
    555            {
    556              enableCompareInt = 1;
   \   00002D   0E           INC     R6
    557              T2IRQM &= ~TIMER2_OVF_COMPARE1M;
   \   00002E   53A7EF       ANL     0xa7,#0xef
    558            }
    559          
    560            MAC_MCU_T2_ACCESS_OVF_CMP1_VALUE();
   \                     ??macMcuOverflowSetCompare_1:
   \   000031   75C330       MOV     0xc3,#0x30
    561          
    562            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    563            T2MOVF0 = ((uint8 *)&count)[UINT32_NDX0];
   \   000034   85..82       MOV     DPL,?XSP + 0
   \   000037   85..83       MOV     DPH,?XSP + 1
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F5A4         MOV     0xa4,A
    564            T2MOVF1 = ((uint8 *)&count)[UINT32_NDX1];
   \   00003D   7401         MOV     A,#0x1
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   E0           MOVX    A,@DPTR
   \   000043   F5A5         MOV     0xa5,A
    565            T2MOVF2 = ((uint8 *)&count)[UINT32_NDX2];
   \   000045   7402         MOV     A,#0x2
   \   000047   12....       LCALL   ?XSTACK_DISP0_8
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   F5A6         MOV     0xa6,A
    566          
    567            /*
    568             *  Now that new compare value is stored, clear the interrupt flag.  This is important just
    569             *  in case a false match was generated as the multi-byte compare value was written.
    570             */
    571            T2IRQF = (TIMER2_OVF_COMPARE1F ^ 0xFF);
   \   00004D   75A1EF       MOV     0xa1,#-0x11
    572          
    573            /* re-enable overflow compare interrupts if they were previously enabled */
    574            if (enableCompareInt)
   \   000050   EE           MOV     A,R6
   \   000051   A2E0         MOV     C,0xE0 /* A   */.0
   \   000053   5003         JNC     ??macMcuOverflowSetCompare_2
    575            {
    576              T2IRQM |= TIMER2_OVF_COMPARE1M;
   \   000055   43A710       ORL     0xa7,#0x10
    577            }
    578          
    579            HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??macMcuOverflowSetCompare_2:
   \   000058   E8           MOV     A,R0
   \   000059   02....       LJMP    ?Subroutine1 & 0xFFFF
   \   00005C                REQUIRE _A_IEN0
   \   00005C                REQUIRE T2IRQM
   \   00005C                REQUIRE T2MSEL
   \   00005C                REQUIRE T2MOVF0
   \   00005C                REQUIRE T2MOVF1
   \   00005C                REQUIRE T2MOVF2
   \   00005C                REQUIRE T2IRQF
    580          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000003   7E00         MOV     R6,#0x0
   \   000005   85..82       MOV     DPL,?XSP + 0
   \   000008   85..83       MOV     DPH,?XSP + 1
   \   00000B   78..         MOV     R0,#?V0 + 0
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   A2E0         MOV     C,0xE0 /* A   */.0
   \   000002                REQUIRE ??Subroutine8_0
   \   000002                ; // Fall through to label ??Subroutine8_0
    581          
    582          
    583          /**************************************************************************************************
    584           * @fn          macMcuOverflowSetPeriod
    585           *
    586           * @brief       Set overflow count period value.  An interrupt is triggered when the overflow
    587           *              count equals this period value.
    588           *
    589           * @param       count - overflow count compare value
    590           *
    591           * @return      none
    592           **************************************************************************************************
    593           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    594          MAC_INTERNAL_API void macMcuOverflowSetPeriod(uint32 count)
   \                     macMcuOverflowSetPeriod:
    595          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   12....       LCALL   ?Subroutine3 & 0xFFFF
    596            halIntState_t  s;
    597            uint8 enableCompareInt = 0;
    598          
    599            MAC_ASSERT( !(count >> 24) );   /* illegal count value */
   \                     ??CrossCallReturnLabel_1:
   \   00000D   12....       LCALL   ?L_MOV_X
   \   000010   90....       MOV     DPTR,#__Constant_ff000000
   \   000013   78..         MOV     R0,#?V0 + 0
   \   000015   12....       LCALL   ?L_AND_X
   \   000018   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   00001B   6003         JZ      ??macMcuOverflowSetPeriod_0
   \   00001D                ; Setup parameters for call to function halAssertHandler
   \   00001D   12....       LCALL   ??halAssertHandler?relay
    600          
    601            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??macMcuOverflowSetPeriod_0:
   \   000020   A2AF         MOV     C,0xa8.7
   \   000022   E4           CLR     A
   \   000023   33           RLC     A
   \   000024   FF           MOV     R7,A
   \   000025   C2AF         CLR     0xa8.7
    602          
    603            /*  Disable overflow compare interrupts. */
    604            if (T2IRQM & TIMER2_OVF_PERM)
   \   000027   E5A7         MOV     A,0xa7
   \   000029   A2E3         MOV     C,0xE0 /* A   */.3
   \   00002B   5004         JNC     ??macMcuOverflowSetPeriod_1
    605            {
    606              enableCompareInt = 1;
   \   00002D   0E           INC     R6
    607              T2IRQM &= ~TIMER2_OVF_PERM;
   \   00002E   53A7F7       ANL     0xa7,#0xf7
    608            }
    609          
    610            MAC_MCU_T2_ACCESS_OVF_PERIOD_VALUE();
   \                     ??macMcuOverflowSetPeriod_1:
   \   000031   75C320       MOV     0xc3,#0x20
    611          
    612            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    613            T2MOVF0 = ((uint8 *)&count)[UINT32_NDX0];
   \   000034   85..82       MOV     DPL,?XSP + 0
   \   000037   85..83       MOV     DPH,?XSP + 1
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F5A4         MOV     0xa4,A
    614            T2MOVF1 = ((uint8 *)&count)[UINT32_NDX1];
   \   00003D   7401         MOV     A,#0x1
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   E0           MOVX    A,@DPTR
   \   000043   F5A5         MOV     0xa5,A
    615            T2MOVF2 = ((uint8 *)&count)[UINT32_NDX2];
   \   000045   7402         MOV     A,#0x2
   \   000047   12....       LCALL   ?XSTACK_DISP0_8
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   F5A6         MOV     0xa6,A
    616          
    617            /*
    618             *  Now that new compare value is stored, clear the interrupt flag.  This is important just
    619             *  in case a false match was generated as the multi-byte compare value was written.
    620             */
    621            T2IRQF &= ~TIMER2_OVF_PERF;
   \   00004D   53A1F7       ANL     0xa1,#0xf7
    622          
    623            /* re-enable overflow compare interrupts if they were previously enabled */
    624            if (enableCompareInt)
   \   000050   EE           MOV     A,R6
   \   000051   A2E0         MOV     C,0xE0 /* A   */.0
   \   000053   5003         JNC     ??macMcuOverflowSetPeriod_2
    625            {
    626              T2IRQM |= TIMER2_OVF_PERM;
   \   000055   43A708       ORL     0xa7,#0x8
    627            }
    628            halSetMaxSleepLoopTime(count);
   \                     ??macMcuOverflowSetPeriod_2:
   \   000058                ; Setup parameters for call to function halSetMaxSleepLoopTime
   \   000058   85..82       MOV     DPL,?XSP + 0
   \   00005B   85..83       MOV     DPH,?XSP + 1
   \   00005E   12....       LCALL   ?XLOAD_R2345
   \   000061   12....       LCALL   ??halSetMaxSleepLoopTime?relay
    629            HAL_EXIT_CRITICAL_SECTION(s);
   \   000064   EF           MOV     A,R7
   \   000065   02....       LJMP    ?Subroutine1 & 0xFFFF
   \   000068                REQUIRE _A_IEN0
   \   000068                REQUIRE T2IRQM
   \   000068                REQUIRE T2MSEL
   \   000068                REQUIRE T2MOVF0
   \   000068                REQUIRE T2MOVF1
   \   000068                REQUIRE T2MOVF2
   \   000068                REQUIRE T2IRQF
    630          }
    631          
    632          
    633          /**************************************************************************************************
    634           * @fn          macMcuOverflowGetCompare
    635           *
    636           * @brief       Get overflow count compare value.
    637           *
    638           * @param       none
    639           *
    640           * @return      overflow count compare value
    641           **************************************************************************************************
    642           */
    643          MAC_INTERNAL_API uint32 macMcuOverflowGetCompare(void)
    644          {
    645            halIntState_t  s;
    646            uint32         compare;
    647          
    648            HAL_ENTER_CRITICAL_SECTION(s);
    649          
    650            MAC_MCU_T2_ACCESS_OVF_CMP1_VALUE();
    651          
    652            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    653            ((uint8 *)&compare)[UINT32_NDX0] = T2MOVF0;
    654            ((uint8 *)&compare)[UINT32_NDX1] = T2MOVF1;
    655            ((uint8 *)&compare)[UINT32_NDX2] = T2MOVF2;
    656            ((uint8 *)&compare)[UINT32_NDX3] = 0;
    657          
    658            HAL_EXIT_CRITICAL_SECTION(s);
    659          
    660            return(compare);
    661          }
    662          
    663          
    664          /**************************************************************************************************
    665           * @fn          macMcuTimer2Isr
    666           *
    667           * @brief       Interrupt service routine for timer2, the MAC timer.
    668           *
    669           * @param       none
    670           *
    671           * @return      none
    672           **************************************************************************************************
    673           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    674          HAL_ISR_FUNCTION( macMcuTimer2Isr, T2_VECTOR )
   \                     macMcuTimer2Isr:
    675          {
   \   000000   C0E0         PUSH    A
   \   000002   74F1         MOV     A,#-0xf
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 15
   \   000007                ; Auto size: 0
    676            uint8 t2irqm;
    677            uint8 t2irqf;
    678          
    679            HAL_ENTER_ISR();
   \   000007   A2AF         MOV     C,0xa8.7
   \   000009   E4           CLR     A
   \   00000A   33           RLC     A
   \   00000B   FE           MOV     R6,A
   \   00000C   D2AF         SETB    0xa8.7
    680          
    681            t2irqm = T2IRQM;
   \   00000E   E5A7         MOV     A,0xa7
   \   000010   FF           MOV     R7,A
    682            t2irqf = T2IRQF;
   \   000011   E5A1         MOV     A,0xa1
   \   000013   F5..         MOV     ?V0 + 0,A
    683          
    684            /*------------------------------------------------------------------------------------------------
    685             *  Overflow compare interrupt - triggers when then overflow counter is
    686             *  equal to the overflow compare register.
    687             */
    688            if ((t2irqf & TIMER2_OVF_COMPARE1F) & t2irqm)
   \   000015   5F           ANL     A,R7
   \   000016   F5..         MOV     ?V0 + 1,A
   \   000018   7410         MOV     A,#0x10
   \   00001A   55..         ANL     A,?V0 + 1
   \   00001C   6006         JZ      ??macMcuTimer2Isr_0
    689            {
    690          
    691              /* call function for dealing with the timer compare interrupt */
    692              macBackoffTimerCompareIsr();
   \   00001E                ; Setup parameters for call to function macBackoffTimerCompareIsr
   \   00001E   12....       LCALL   ??macBackoffTimerCompareIsr?relay
    693          
    694              /* clear overflow compare interrupt flag */
    695              T2IRQF = (TIMER2_OVF_COMPARE1F ^ 0xFF);
   \   000021   75A1EF       MOV     0xa1,#-0x11
    696            }
    697          
    698            /*------------------------------------------------------------------------------------------------
    699             *  Overflow compare interrupt - triggers when then overflow counter is
    700             *  equal to the overflow compare register.
    701             */
    702            if ((t2irqf & TIMER2_OVF_PERF) & t2irqm)
   \                     ??macMcuTimer2Isr_0:
   \   000024   7408         MOV     A,#0x8
   \   000026   55..         ANL     A,?V0 + 1
   \   000028   6008         JZ      ??macMcuTimer2Isr_1
    703            {
    704          
    705              /* call function for dealing with the timer compare interrupt */
    706              macBackoffTimerPeriodIsr();
   \   00002A                ; Setup parameters for call to function macBackoffTimerPeriodIsr
   \   00002A   12....       LCALL   ??macBackoffTimerPeriodIsr?relay
    707          
    708              /* clear overflow compare interrupt flag */
    709              T2IRQF = (TIMER2_OVF_PERF ^ 0xFF);
   \   00002D   75A1F7       MOV     0xa1,#-0x9
   \   000030   8024         SJMP    ??macMcuTimer2Isr_2
    710            }
    711          
    712            /*------------------------------------------------------------------------------------------------
    713             *  Overflow interrupt - triggers when the hardware timer rolls over.
    714             */
    715            else if ((t2irqf & TIMER2_PERF) & t2irqm)
   \                     ??macMcuTimer2Isr_1:
   \   000032   E5..         MOV     A,?V0 + 0
   \   000034   A2E0         MOV     C,0xE0 /* A   */.0
   \   000036   92F0         MOV     B.0,C
   \   000038   EF           MOV     A,R7
   \   000039   A2E0         MOV     C,0xE0 /* A   */.0
   \   00003B   82F0         ANL     C,B.0
   \   00003D   5017         JNC     ??macMcuTimer2Isr_2
    716            {
    717              /* call energy detect interrupt function, this interrupt not used for any other functionality */
    718              mcuRecordMaxRssiIsr();
   \   00003F   906198       MOV     DPTR,#0x6198
   \   000042   E0           MOVX    A,@DPTR
   \   000043   F8           MOV     R0,A
   \   000044   90....       MOV     DPTR,#maxRssi
   \   000047   E0           MOVX    A,@DPTR
   \   000048   C3           CLR     C
   \   000049   98           SUBB    A,R0
   \   00004A   A2D2         MOV     C,0xD0 /* PSW */.2
   \   00004C   65D0         XRL     A,PSW
   \   00004E   33           RLC     A
   \   00004F   5002         JNC     ??macMcuTimer2Isr_3
   \   000051   E8           MOV     A,R0
   \   000052   F0           MOVX    @DPTR,A
    719          
    720              /* clear the interrupt flag */
    721              T2IRQF = (TIMER2_PERF ^ 0xFF);
   \                     ??macMcuTimer2Isr_3:
   \   000053   75A1FE       MOV     0xa1,#-0x2
    722            }
    723          
    724            CLEAR_SLEEP_MODE();
    725            HAL_EXIT_ISR();
   \                     ??macMcuTimer2Isr_2:
   \   000056   EE           MOV     A,R6
   \   000057   A2E0         MOV     C,0xE0 /* A   */.0
   \   000059   92AF         MOV     0xa8.7,C
    726          }
   \   00005B   7F02         MOV     R7,#0x2
   \   00005D   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   000060                REQUIRE _A_IEN0
   \   000060                REQUIRE T2IRQM
   \   000060                REQUIRE T2IRQF
    727          
    728          
    729          /**************************************************************************************************
    730           * @fn          macMcuTimer2OverflowWorkaround
    731           *
    732           * @brief       For CC2530, T2 interrupt won’t be generated when the current count is greater than
    733           *              the comparator. The interrupt is only generated when the current count is equal to
    734           *              the comparator. When the CC2530 is waking up from sleep, there is a small window
    735           *              that the count may be grater than the comparator, therefore, missing the interrupt.
    736           *              This workaround will call the T2 ISR when the current T2 count is greater than the
    737           *              comparator.
    738           *
    739           * @param       none
    740           *
    741           * @return      none
    742           **************************************************************************************************
    743           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    744          void macMcuTimer2OverflowWorkaround(void)
   \                     macMcuTimer2OverflowWorkaround:
    745          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    746            if (T2IRQM & TIMER2_OVF_COMPARE1F)
   \   00000A   E5A7         MOV     A,0xa7
   \   00000C   A2E4         MOV     C,0xE0 /* A   */.4
   \   00000E   5059         JNC     ??macMcuTimer2OverflowWorkaround_0
    747            {
    748              /* T2 comapre 1 interrupt is enabled but T2 compare 1 intererrupt is not generated */
    749              if (!(T2IRQF & TIMER2_OVF_COMPARE1F))
   \   000010   E5A1         MOV     A,0xa1
   \   000012   A2E4         MOV     C,0xE0 /* A   */.4
   \   000014   4053         JC      ??macMcuTimer2OverflowWorkaround_0
    750              {
    751                if (MAC_RADIO_BACKOFF_COUNT() > macMcuOverflowGetCompare())
   \   000016   E5A8         MOV     A,0xa8
   \   000018   F8           MOV     R0,A
   \   000019   C2AF         CLR     0xa8.7
   \   00001B   75C330       MOV     0xc3,#0x30
   \   00001E   E5A4         MOV     A,0xa4
   \   000020   85..82       MOV     DPL,?XSP + 0
   \   000023   85..83       MOV     DPH,?XSP + 1
   \   000026   F0           MOVX    @DPTR,A
   \   000027   E5A5         MOV     A,0xa5
   \   000029   C0E0         PUSH    A
   \   00002B   7401         MOV     A,#0x1
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   D0E0         POP     A
   \   000032   F0           MOVX    @DPTR,A
   \   000033   E5A6         MOV     A,0xa6
   \   000035   C0E0         PUSH    A
   \   000037   7402         MOV     A,#0x2
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   D0E0         POP     A
   \   00003E   F0           MOVX    @DPTR,A
   \   00003F   7403         MOV     A,#0x3
   \   000041   12....       LCALL   ?XSTACK_DISP0_8
   \   000044   E4           CLR     A
   \   000045   F0           MOVX    @DPTR,A
   \   000046   E8           MOV     A,R0
   \   000047   A2E7         MOV     C,0xE0 /* A   */.7
   \   000049   92AF         MOV     0xa8.7,C
   \   00004B                ; Setup parameters for call to function macMcuOverflowCount
   \   00004B   12....       LCALL   ??macMcuOverflowCount?relay
   \   00004E   8A..         MOV     ?V0 + 0,R2
   \   000050   8B..         MOV     ?V0 + 1,R3
   \   000052   8C..         MOV     ?V0 + 2,R4
   \   000054   8D..         MOV     ?V0 + 3,R5
   \   000056   85..82       MOV     DPL,?XSP + 0
   \   000059   85..83       MOV     DPH,?XSP + 1
   \   00005C   78..         MOV     R0,#?V0 + 0
   \   00005E   12....       LCALL   ?UL_GT_X
   \   000061   5006         JNC     ??macMcuTimer2OverflowWorkaround_0
    752                {
    753                  /* Set the flag to trigger the timer compare interrupt */
    754                  macBackoffTimerCompareIsr();
   \   000063                ; Setup parameters for call to function macBackoffTimerCompareIsr
   \   000063   12....       LCALL   ??macBackoffTimerCompareIsr?relay
    755                  T2IRQF = (TIMER2_OVF_COMPARE1F ^ 0xFF);
   \   000066   75A1EF       MOV     0xa1,#-0x11
    756                }
    757              }
    758            }
    759          }
   \                     ??macMcuTimer2OverflowWorkaround_0:
   \   000069   80..         SJMP    ??Subroutine9_0
   \   00006B                REQUIRE T2IRQM
   \   00006B                REQUIRE T2IRQF
   \   00006B                REQUIRE _A_IEN0
   \   00006B                REQUIRE T2MSEL
   \   00006B                REQUIRE T2MOVF0
   \   00006B                REQUIRE T2MOVF1
   \   00006B                REQUIRE T2MOVF2
    760          
    761          
    762          /**************************************************************************************************
    763           * @fn          macMcuPrecisionCount
    764           *
    765           * @brief       This function is used by higher layer to read a free running counter driven by
    766           *              MAC timer.
    767           *
    768           * @param       none
    769           *
    770           * @return      overflowCount
    771           **************************************************************************************************
    772           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    773          uint32 macMcuPrecisionCount(void)
   \                     macMcuPrecisionCount:
    774          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    775            uint32         overflowCount = 0;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   E4           CLR     A
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   F0           MOVX    @DPTR,A
   \   000014   A3           INC     DPTR
   \   000015   F0           MOVX    @DPTR,A
   \   000016   A3           INC     DPTR
   \   000017   F0           MOVX    @DPTR,A
    776            halIntState_t  s;
    777          
    778            HAL_ENTER_CRITICAL_SECTION(s);
   \   000018   A2AF         MOV     C,0xa8.7
   \   00001A   33           RLC     A
   \   00001B   FE           MOV     R6,A
   \   00001C   C2AF         CLR     0xa8.7
    779          
    780            /* This T2 access macro allows accessing both T2MOVFx and T2Mx */
    781            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
   \   00001E   75C300       MOV     0xc3,#0x0
    782          
    783            /* Latch the entire T2MOVFx first by reading T2M0.
    784             * T2M0 is discarded.
    785             */
    786            T2M0;
   \   000021   E5A2         MOV     A,0xa2
    787            ((uint8 *)&overflowCount)[UINT32_NDX0] = T2MOVF0;
   \   000023   E5A4         MOV     A,0xa4
   \   000025   85..82       MOV     DPL,?XSP + 0
   \   000028   85..83       MOV     DPH,?XSP + 1
   \   00002B   F0           MOVX    @DPTR,A
    788            ((uint8 *)&overflowCount)[UINT32_NDX1] = T2MOVF1;
   \   00002C   E5A5         MOV     A,0xa5
   \   00002E   C0E0         PUSH    A
   \   000030   7401         MOV     A,#0x1
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   D0E0         POP     A
   \   000037   F0           MOVX    @DPTR,A
    789            ((uint8 *)&overflowCount)[UINT32_NDX2] = T2MOVF2;
   \   000038   E5A6         MOV     A,0xa6
   \   00003A   C0E0         PUSH    A
   \   00003C   7402         MOV     A,#0x2
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   D0E0         POP     A
   \   000043   F0           MOVX    @DPTR,A
    790          
    791            /* the overflowCount needs to account for the accumulated overflow count in Beacon mode */
    792            overflowCount += accumulatedOverflowCount;
   \   000044   90....       MOV     DPTR,#accumulatedOverflowCount
   \   000047   78..         MOV     R0,#?V0 + 0
   \   000049   12....       LCALL   ?L_MOV_X
   \   00004C   85..82       MOV     DPL,?XSP + 0
   \   00004F   85..83       MOV     DPH,?XSP + 1
   \   000052   78..         MOV     R0,#?V0 + 0
   \   000054   12....       LCALL   ?L_ADD_TO_X
    793          
    794            /*
    795             * Workaround to take care of the case where a rollover just occured and the call to
    796             * macBackoffTimerPeriodIsr() hasn't yet occured or if one rollover occured during
    797             * sleep then update the accumulatedoverflowCount with the rollover
    798             */
    799            if((prevoverflowCount > overflowCount) && (prevAccumulatedOverflowCount == accumulatedOverflowCount))
   \   000057   90....       MOV     DPTR,#prevoverflowCount
   \   00005A   78..         MOV     R0,#?V0 + 0
   \   00005C   12....       LCALL   ?L_MOV_X
   \   00005F   85..82       MOV     DPL,?XSP + 0
   \   000062   85..83       MOV     DPH,?XSP + 1
   \   000065   78..         MOV     R0,#?V0 + 0
   \   000067   12....       LCALL   ?UL_GT_X
   \   00006A   5041         JNC     ??macMcuPrecisionCount_0
   \   00006C   90....       MOV     DPTR,#accumulatedOverflowCount
   \   00006F   78..         MOV     R0,#?V0 + 0
   \   000071   12....       LCALL   ?L_MOV_X
   \   000074   90....       MOV     DPTR,#prevAccumulatedOverflowCount
   \   000077   78..         MOV     R0,#?V0 + 0
   \   000079   12....       LCALL   ?L_EQ_X
   \   00007C   702F         JNZ     ??macMcuPrecisionCount_0
    800            {
    801              accumulatedOverflowCount += macGetBackOffTimerRollover();
   \   00007E                ; Setup parameters for call to function macGetBackOffTimerRollover
   \   00007E   12....       LCALL   ??macGetBackOffTimerRollover?relay
   \   000081   8A..         MOV     ?V0 + 0,R2
   \   000083   8B..         MOV     ?V0 + 1,R3
   \   000085   8C..         MOV     ?V0 + 2,R4
   \   000087   8D..         MOV     ?V0 + 3,R5
   \   000089   90....       MOV     DPTR,#accumulatedOverflowCount
   \   00008C   78..         MOV     R0,#?V0 + 0
   \   00008E   12....       LCALL   ?L_ADD_TO_X
    802              overflowCount += macGetBackOffTimerRollover();
   \   000091                ; Setup parameters for call to function macGetBackOffTimerRollover
   \   000091   12....       LCALL   ??macGetBackOffTimerRollover?relay
   \   000094   8A..         MOV     ?V0 + 0,R2
   \   000096   8B..         MOV     ?V0 + 1,R3
   \   000098   8C..         MOV     ?V0 + 2,R4
   \   00009A   8D..         MOV     ?V0 + 3,R5
   \   00009C   85..82       MOV     DPL,?XSP + 0
   \   00009F   85..83       MOV     DPH,?XSP + 1
   \   0000A2   78..         MOV     R0,#?V0 + 0
   \   0000A4   12....       LCALL   ?L_ADD_TO_X
    803              /*don't update the rollover since it has been updated already */
    804              updateRolloverflag = TRUE;
   \   0000A7   90....       MOV     DPTR,#updateRolloverflag
   \   0000AA   7401         MOV     A,#0x1
   \   0000AC   F0           MOVX    @DPTR,A
    805            }
    806          
    807            /* store the current value of overflowcount and accumulatedOverflowCount */
    808            prevoverflowCount = overflowCount;
   \                     ??macMcuPrecisionCount_0:
   \   0000AD   85..82       MOV     DPL,?XSP + 0
   \   0000B0   85..83       MOV     DPH,?XSP + 1
   \   0000B3   12....       LCALL   ?XLOAD_R2345
   \   0000B6   90....       MOV     DPTR,#prevoverflowCount
   \   0000B9   12....       LCALL   ?XSTORE_R2345
    809            prevAccumulatedOverflowCount = accumulatedOverflowCount;
   \   0000BC   90....       MOV     DPTR,#accumulatedOverflowCount
   \   0000BF   12....       LCALL   ?XLOAD_R2345
   \   0000C2   90....       MOV     DPTR,#prevAccumulatedOverflowCount
   \   0000C5   12....       LCALL   ?XSTORE_R2345
    810          
    811            HAL_EXIT_CRITICAL_SECTION(s);
   \   0000C8   EE           MOV     A,R6
   \   0000C9   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000CB   92AF         MOV     0xa8.7,C
    812          
    813            return(overflowCount);
   \   0000CD   85..82       MOV     DPL,?XSP + 0
   \   0000D0   85..83       MOV     DPH,?XSP + 1
   \   0000D3   12....       LCALL   ?XLOAD_R2345
   \   0000D6   02....       LJMP    ??Subroutine9_0 & 0xFFFF
   \   0000D9                REQUIRE _A_IEN0
   \   0000D9                REQUIRE T2MSEL
   \   0000D9                REQUIRE T2M0
   \   0000D9                REQUIRE T2MOVF0
   \   0000D9                REQUIRE T2MOVF1
   \   0000D9                REQUIRE T2MOVF2
    814          }
    815          
    816          
    817          /**************************************************************************************************
    818           * @fn          macMcuRfIsr
    819           *
    820           * @brief       Interrupt service routine that handles all RF interrupts.  There are a number
    821           *              of conditions "ganged" onto this one ISR so each condition must be tested for.
    822           *
    823           * @param       none
    824           *
    825           * @return      none
    826           **************************************************************************************************
    827           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    828          HAL_ISR_FUNCTION( macMcuRfIsr, RF_VECTOR )
   \                     macMcuRfIsr:
    829          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 14
   \   000007                ; Auto size: 0
    830            uint8 rfim;
    831          
    832            HAL_ENTER_ISR();
   \   000007   A2AF         MOV     C,0xa8.7
   \   000009   E4           CLR     A
   \   00000A   33           RLC     A
   \   00000B   FE           MOV     R6,A
   \   00000C   D2AF         SETB    0xa8.7
    833          
    834            rfim = RFIRQM1;
   \   00000E   9061A4       MOV     DPTR,#0x61a4
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F8           MOV     R0,A
    835          
    836            /*  The CPU level RF interrupt flag must be cleared here (before clearing RFIRQFx).
    837             *  to allow the interrupts to be nested.
    838             */
    839            S1CON = 0x00;
   \   000013   759B00       MOV     0x9b,#0x0
    840          
    841            if ((RFIRQF1 & IRQ_CSP_MANINT) & rfim)
   \   000016   E591         MOV     A,0x91
   \   000018   58           ANL     A,R0
   \   000019   5408         ANL     A,#0x8
   \   00001B   6008         JZ      ??macMcuRfIsr_0
    842            {
    843              /*
    844               *  Important!  Because of how the CSP programs are written, CSP_INT interrupts should
    845               *  be processed before CSP_STOP interrupts.  This becomes an issue when there are
    846               *  long critical sections.
    847               */
    848              /* clear flag */
    849              RFIRQF1 = (IRQ_CSP_MANINT ^ 0xFF);
   \   00001D   7591F7       MOV     0x91,#-0x9
    850              macCspTxIntIsr();
   \   000020                ; Setup parameters for call to function macCspTxIntIsr
   \   000020   12....       LCALL   ??macCspTxIntIsr?relay
   \   000023   8023         SJMP    ??macMcuRfIsr_1
    851            }
    852            else if ((RFIRQF1 & IRQ_CSP_STOP) & rfim)
   \                     ??macMcuRfIsr_0:
   \   000025   E591         MOV     A,0x91
   \   000027   58           ANL     A,R0
   \   000028   5410         ANL     A,#0x10
   \   00002A   6008         JZ      ??macMcuRfIsr_2
    853            {
    854              /* clear flag */
    855              RFIRQF1 = (IRQ_CSP_STOP ^ 0xFF);
   \   00002C   7591EF       MOV     0x91,#-0x11
    856              macCspTxStopIsr();
   \   00002F                ; Setup parameters for call to function macCspTxStopIsr
   \   00002F   12....       LCALL   ??macCspTxStopIsr?relay
   \   000032   8014         SJMP    ??macMcuRfIsr_1
    857            }
    858            else if ((RFIRQF1 & IRQ_TXACKDONE) & rfim)
   \                     ??macMcuRfIsr_2:
   \   000034   E591         MOV     A,0x91
   \   000036   A2E0         MOV     C,0xE0 /* A   */.0
   \   000038   92F0         MOV     B.0,C
   \   00003A   E8           MOV     A,R0
   \   00003B   A2E0         MOV     C,0xE0 /* A   */.0
   \   00003D   82F0         ANL     C,B.0
   \   00003F   5007         JNC     ??macMcuRfIsr_1
    859            {
    860              /* disable interrupt - set up is for "one shot" operation */
    861              RFIRQM1 &= ~IM_TXACKDONE;
   \   000041   E0           MOVX    A,@DPTR
   \   000042   C2E0         CLR     0xE0 /* A   */.0
   \   000044   F0           MOVX    @DPTR,A
    862              macRxAckTxDoneCallback();
   \   000045                ; Setup parameters for call to function macRxAckTxDoneCallback
   \   000045   12....       LCALL   ??macRxAckTxDoneCallback?relay
    863            }
    864          
    865            rfim = RFIRQM0;
   \                     ??macMcuRfIsr_1:
   \   000048   9061A3       MOV     DPTR,#0x61a3
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   F8           MOV     R0,A
    866          
    867            /* process RFIRQF0 next */
    868            if ((RFIRQF0 & IRQ_FIFOP) & rfim)
   \   00004D   E5E9         MOV     A,0xe9
   \   00004F   58           ANL     A,R0
   \   000050   5404         ANL     A,#0x4
   \   000052   600E         JZ      ??macMcuRfIsr_3
    869            {
    870              /* continue to execute interrup                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        t handler as long as FIFOP is active */
    871              do
    872              {
    873                macRxThresholdIsr();
   \                     ??macMcuRfIsr_4:
   \   000054                ; Setup parameters for call to function macRxThresholdIsr
   \   000054   12....       LCALL   ??macRxThresholdIsr?relay
    874                RFIRQF0 = (IRQ_FIFOP ^ 0xFF);
   \   000057   75E9FB       MOV     0xe9,#-0x5
    875              } while (FSMSTAT1 & FIFOP);
   \   00005A   906193       MOV     DPTR,#0x6193
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   A2E6         MOV     C,0xE0 /* A   */.6
   \   000060   40F2         JC      ??macMcuRfIsr_4
    876            }
    877          
    878            CLEAR_SLEEP_MODE();
    879            HAL_EXIT_ISR();
   \                     ??macMcuRfIsr_3:
   \   000062                REQUIRE ?Subroutine2
   \   000062                REQUIRE _A_IEN0
   \   000062                REQUIRE S1CON
   \   000062                REQUIRE RFIRQF1
   \   000062                REQUIRE RFIRQF0
   \   000062                ; // Fall through to label ?Subroutine2
    880          }

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   EE           MOV     A,R6
   \   000001   A2E0         MOV     C,0xE0 /* A   */.0
   \   000003   92AF         MOV     0xa8.7,C
   \   000005   7F01         MOV     R7,#0x1
   \   000007   02....       LJMP    ?INTERRUPT_LEAVE_XSP
    881          
    882          
    883          /**************************************************************************************************
    884           * @fn          macMcuRfErrIsr
    885           *
    886           * @brief       Interrupt service routine that handles all RF Error interrupts.  Only the RX FIFO
    887           *              overflow condition is handled.
    888           *
    889           * @param       none
    890           *
    891           * @return      none
    892           **************************************************************************************************
    893           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    894          HAL_ISR_FUNCTION( macMcuRfErrIsr, RFERR_VECTOR )
   \                     macMcuRfErrIsr:
    895          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 14
   \   000007                ; Auto size: 0
    896            uint8 rferrm;
    897          
    898            HAL_ENTER_ISR();
   \   000007   A2AF         MOV     C,0xa8.7
   \   000009   E4           CLR     A
   \   00000A   33           RLC     A
   \   00000B   FE           MOV     R6,A
   \   00000C   D2AF         SETB    0xa8.7
    899          
    900            rferrm = RFERRM;
   \   00000E   9061A5       MOV     DPTR,#0x61a5
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F8           MOV     R0,A
    901          
    902            if ((RFERRF & RFERR_RXOVERF) & rferrm)
   \   000013   E5BF         MOV     A,0xbf
   \   000015   58           ANL     A,R0
   \   000016   5404         ANL     A,#0x4
   \   000018   6006         JZ      ??macMcuRfErrIsr_0
    903            {
    904              RFERRF = (RFERR_RXOVERF ^ 0xFF);
   \   00001A   75BFFB       MOV     0xbf,#-0x5
    905              macRxFifoOverflowIsr();
   \   00001D                ; Setup parameters for call to function macRxFifoOverflowIsr
   \   00001D   12....       LCALL   ??macRxFifoOverflowIsr?relay
    906            }
    907          
    908            CLEAR_SLEEP_MODE();
    909            HAL_EXIT_ISR();
   \                     ??macMcuRfErrIsr_0:
   \   000020   80..         SJMP    ?Subroutine2
   \   000022                REQUIRE _A_IEN0
   \   000022                REQUIRE RFERRF
    910          }
    911          
    912          
    913          /**************************************************************************************************
    914           * @fn          macMcuRecordMaxRssiStart
    915           *
    916           * @brief       Starts recording of the maximum received RSSI value.
    917           *
    918           * @param       none
    919           *
    920           * @return      none
    921           **************************************************************************************************
    922           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    923          MAC_INTERNAL_API void macMcuRecordMaxRssiStart(void)
   \                     macMcuRecordMaxRssiStart:
    924          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    925            /* start maximum recorded value at the lowest possible value */
    926            maxRssi = -128;
   \   000004   90....       MOV     DPTR,#maxRssi
   \   000007   7480         MOV     A,#-0x80
   \   000009   F0           MOVX    @DPTR,A
    927          
    928            /* enable timer overflow interrupt */
    929            T2IRQM |= TIMER2_PERM;
   \   00000A   43A701       ORL     0xa7,#0x1
    930          }
   \   00000D   02....       LJMP    ??Subroutine7_0 & 0xFFFF
   \   000010                REQUIRE T2IRQM
    931          
    932          
    933          /**************************************************************************************************
    934           * @fn          macMcuRecordMaxRssiStop
    935           *
    936           * @brief       Stops recording of the maximum received RSSI.  It returns the maximum value
    937           *              received since starting the recording.
    938           *
    939           * @param       none
    940           *
    941           * @return      maximum received RSSI value
    942           **************************************************************************************************
    943           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    944          MAC_INTERNAL_API int8 macMcuRecordMaxRssiStop(void)
   \                     macMcuRecordMaxRssiStop:
    945          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    946            /* disable timer overflow interrupt */
    947            T2IRQM &= ~TIMER2_PERM;
   \   000004   53A7FE       ANL     0xa7,#0xfe
    948          
    949            return(maxRssi);
   \   000007   90....       MOV     DPTR,#maxRssi
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F9           MOV     R1,A
   \   00000C   02....       LJMP    ??Subroutine7_0 & 0xFFFF
   \   00000F                REQUIRE T2IRQM
    950          }
    951          
    952          
    953          /*=================================================================================================
    954           * @fn          macMcuRecordMaxRssiIsr
    955           *
    956           * @brief       Interrupt service routine called during recording of max RSSI value.
    957           *
    958           * @param       none
    959           *
    960           * @return      none
    961           *=================================================================================================
    962           */
    963          static void mcuRecordMaxRssiIsr(void)
    964          {
    965            int8 rssi;
    966          
    967            /* read latest RSSI value */
    968            rssi = RSSI;
    969          
    970            /* if new RSSI value is greater than the maximum already received, it is the new maximum */
    971            if (rssi > maxRssi)
    972            {
    973              maxRssi = rssi;
    974            }
    975          }
    976          
    977          /**************************************************************************************************
    978           * @fn          macMcuAccumulatedOverFlow
    979           *
    980           * @brief       This function is used to accumulate timer 2 overflow if applicable
    981           *              on the relevant platform
    982           *
    983           * @param       none
    984           *
    985           * @return      none
    986           **************************************************************************************************
    987           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    988          MAC_INTERNAL_API void macMcuAccumulatedOverFlow(void)
   \                     macMcuAccumulatedOverFlow:
    989          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    990            halIntState_t  s;
    991            HAL_ENTER_CRITICAL_SECTION(s);
   \   000005   A2AF         MOV     C,0xa8.7
   \   000007   E4           CLR     A
   \   000008   33           RLC     A
   \   000009   FE           MOV     R6,A
   \   00000A   C2AF         CLR     0xa8.7
    992          
    993            if(updateRolloverflag == FALSE)
   \   00000C   90....       MOV     DPTR,#updateRolloverflag
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   7015         JNZ     ??macMcuAccumulatedOverFlow_0
    994            {
    995              accumulatedOverflowCount += macGetBackOffTimerRollover();
   \   000012                ; Setup parameters for call to function macGetBackOffTimerRollover
   \   000012   12....       LCALL   ??macGetBackOffTimerRollover?relay
   \   000015   8A..         MOV     ?V0 + 0,R2
   \   000017   8B..         MOV     ?V0 + 1,R3
   \   000019   8C..         MOV     ?V0 + 2,R4
   \   00001B   8D..         MOV     ?V0 + 3,R5
   \   00001D   90....       MOV     DPTR,#accumulatedOverflowCount
   \   000020   78..         MOV     R0,#?V0 + 0
   \   000022   12....       LCALL   ?L_ADD_TO_X
   \   000025   8002         SJMP    ??macMcuAccumulatedOverFlow_1
    996            }
    997            else
    998            {
    999              updateRolloverflag = FALSE;
   \                     ??macMcuAccumulatedOverFlow_0:
   \   000027   E4           CLR     A
   \   000028   F0           MOVX    @DPTR,A
   1000            }
   1001          
   1002            HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??macMcuAccumulatedOverFlow_1:
   \   000029   EE           MOV     A,R6
   \   00002A   A2E0         MOV     C,0xE0 /* A   */.0
   \   00002C   92AF         MOV     0xa8.7,C
   1003          }
   \   00002E   02....       LJMP    ??Subroutine10_0 & 0xFFFF
   \   000031                REQUIRE _A_IEN0

   \                                 In  segment INTVEC, offset 0x3, root
   \                     `??macMcuRfErrIsr??INTVEC 3`:
   \   000003   02....       LJMP       (macMcuRfErrIsr)

   \                                 In  segment INTVEC, offset 0x53, root
   \                     `??macMcuTimer2Isr??INTVEC 83`:
   \   000053   02....       LJMP       (macMcuTimer2Isr)

   \                                 In  segment INTVEC, offset 0x83, root
   \                     `??macMcuRfIsr??INTVEC 131`:
   \   000083   02....       LJMP       (macMcuRfIsr)

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ff000000:
   \   000000   000000FF     DD 4278190080

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MAC_SetRandomSeedCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MAC_SetRandomSeedCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuRandomByte?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuRandomByte

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuRandomWord?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuRandomWord

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuTimerForceDelay?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuTimerForceDelay

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuTimerCapture?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuTimerCapture

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuOverflowCount?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowCount

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuOverflowCapture?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowCapture

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuOverflowSetCount?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowSetCount

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuOverflowSetCompare?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowSetCompare

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuOverflowSetPeriod?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowSetPeriod

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuTimer2OverflowWorkaround?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuTimer2OverflowWorkaround

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuPrecisionCount?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuPrecisionCount

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuRecordMaxRssiStart?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuRecordMaxRssiStart

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuRecordMaxRssiStop?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuRecordMaxRssiStop

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuAccumulatedOverFlow?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuAccumulatedOverFlow
   1004          
   1005          
   1006          /**************************************************************************************************
   1007           *                                  Compile Time Integrity Checks
   1008           **************************************************************************************************
   1009           */
   1010          #if ((IRQ_SFD != IM_SFD) || (IRQ_FIFOP != IM_FIFOP) || (IRQ_TXACKDONE != IM_TXACKDONE))
   1011          #error "ERROR: Compile time error with RFIRQFx vs RFIRQMx register defines."
   1012          #endif
   1013          
   1014          #if defined (FEATURE_CC253X_LOW_POWER_RX) && !(defined (HAL_MCU_CC2530) || defined (HAL_MCU_CC2533))
   1015          #error "ERROR: FEATURE_CC253X_LOW_POWER_RX can only be used with CC2530 or CC2533."
   1016          #endif
   1017          
   1018          /**************************************************************************************************
   1019          */

   Maximum stack usage in bytes:

   ISTACK PSTACK XSTACK Function
   ------ ------ ------ --------
       2      0      0  MAC_SetRandomSeedCB
       0      0     12  macMcuAccumulatedOverFlow
                          0 0 12 -> macGetBackOffTimerRollover
       1      0     42  macMcuInit
                          0 0 42 -> macRxOff
                          0 0 42 -> macRxOn
       3      0      4  macMcuOverflowCapture
       3      0     20  macMcuOverflowCount
       0      0     16  macMcuOverflowSetCompare
                          0 0 16 -> halAssertHandler
       2      0     16  macMcuOverflowSetCount
                          0 0 16 -> halAssertHandler
                          2 0 16 -> macMcuOverflowCount
       0      0     16  macMcuOverflowSetPeriod
                          0 0 16 -> halAssertHandler
                          0 0 16 -> halSetMaxSleepLoopTime
       1      0     16  macMcuPrecisionCount
                          0 0 16 -> macGetBackOffTimerRollover
       0      0      0  macMcuRandomByte
       0      0      0  macMcuRandomWord
       2      0      0  macMcuRecordMaxRssiStart
       2      0      0  macMcuRecordMaxRssiStop
       0      0     14  macMcuRfErrIsr
                          0 0 14 -> macRxFifoOverflowIsr
       0      0     14  macMcuRfIsr
                          0 0 14 -> macCspTxIntIsr
                          0 0 14 -> macCspTxStopIsr
                          0 0 14 -> macRxAckTxDoneCallback
                          0 0 14 -> macRxThresholdIsr
       0      0     15  macMcuTimer2Isr
                          0 0 15 -> macBackoffTimerCompareIsr
                          0 0 15 -> macBackoffTimerPeriodIsr
       1      0     16  macMcuTimer2OverflowWorkaround
                          0 0 16 -> macBackoffTimerCompareIsr
                          0 0 16 -> macMcuOverflowCount
       2      0      0  macMcuTimerCapture
       0      0      0  macMcuTimerForceDelay


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       6  ??MAC_SetRandomSeedCB?relay
       5  ??Subroutine10_0
       7  ??Subroutine7_0
       2  ??Subroutine8_0
       5  ??Subroutine9_0
       6  ??macMcuAccumulatedOverFlow?relay
       6  ??macMcuInit?relay
       6  ??macMcuOverflowCapture?relay
       6  ??macMcuOverflowCount?relay
       6  ??macMcuOverflowSetCompare?relay
       6  ??macMcuOverflowSetCount?relay
       6  ??macMcuOverflowSetPeriod?relay
       6  ??macMcuPrecisionCount?relay
       6  ??macMcuRandomByte?relay
       6  ??macMcuRandomWord?relay
       6  ??macMcuRecordMaxRssiStart?relay
       6  ??macMcuRecordMaxRssiStop?relay
       3  ??macMcuRfErrIsr??INTVEC 3
       3  ??macMcuRfIsr??INTVEC 131
       3  ??macMcuTimer2Isr??INTVEC 83
       6  ??macMcuTimer2OverflowWorkaround?relay
       6  ??macMcuTimerCapture?relay
       6  ??macMcuTimerForceDelay?relay
      61  ?Subroutine0
       2  ?Subroutine1
      10  ?Subroutine2
      14  ?Subroutine3
      12  ?Subroutine4
       9  ?Subroutine5
      18  ?Subroutine6
       1  ADCCON1
       1  CLKCONSTA
       1  IEN2
       1  IP0
       1  IP1
      14  MAC_SetRandomSeedCB
       1  RFERRF
       1  RFIRQF0
       1  RFIRQF1
       1  RNDH
       1  RNDL
       1  S1CON
       1  T2CTRL
       1  T2IRQF
       1  T2IRQM
       1  T2M0
       1  T2M1
       1  T2MOVF0
       1  T2MOVF1
       1  T2MOVF2
       1  T2MSEL
       1  _A_IEN0
       1  _A_IEN1
       4  __Constant_ff000000
       4  accumulatedOverflowCount
       1  macChipVersion
      49  macMcuAccumulatedOverFlow
     365  macMcuInit
      20  macMcuOverflowCapture
      22  macMcuOverflowCount
      92  macMcuOverflowSetCompare
     127  macMcuOverflowSetCount
     104  macMcuOverflowSetPeriod
     217  macMcuPrecisionCount
       6  macMcuRandomByte
      11  macMcuRandomWord
      16  macMcuRecordMaxRssiStart
      15  macMcuRecordMaxRssiStop
      34  macMcuRfErrIsr
      98  macMcuRfIsr
      96  macMcuTimer2Isr
     107  macMcuTimer2OverflowWorkaround
      33  macMcuTimerCapture
      24  macMcuTimerForceDelay
       1  maxRssi
       2  pRandomSeedCB
       4  prevAccumulatedOverflowCount
       4  prevoverflowCount
       1  updateRolloverflag

 
 1 357 bytes in segment BANKED_CODE
    96 bytes in segment BANK_RELAYS
     9 bytes in segment INTVEC
   238 bytes in segment NEAR_CODE
    22 bytes in segment SFR_AN
     4 bytes in segment XDATA_ROM_C
    17 bytes in segment XDATA_Z
 
 1 691 bytes of CODE  memory (+  9 bytes shared)
     0 bytes of CONST memory (+  4 bytes shared)
     0 bytes of DATA  memory (+ 22 bytes shared)
    17 bytes of XDATA memory

Errors: none
Warnings: none
