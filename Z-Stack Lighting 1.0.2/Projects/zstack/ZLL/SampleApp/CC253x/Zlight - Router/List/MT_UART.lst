###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.20.2.41139 for 8051             27/May/2014  19:13:48 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  D:\Texas Instruments\Z-Stack Lighting              #
#                          1.0.2\Components\mt\MT_UART.c                      #
#    Command line       =  -f "D:\Texas Instruments\Z-Stack Lighting          #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\Tools\CC2530DB\f8wRouter.cfg" (-DCPU32MHZ        #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8       #
#                          -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f "D:\Texas         #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\Tools\CC2530DB\f8wConfig.cfg" (-DZIGBEEPRO       #
#                          -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR       #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100    #
#                          -DREJOIN_POLL_RATE=440) -f "D:\Texas               #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\Tools\CC2530DB\f8wZCL.cfg" "D:\Texas             #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Components\mt\MT_UART.c" -D                  #
#                          FEATURE_GREEN_POWER -D SECURE=1 -D                 #
#                          TC_LINKKEY_JOIN -D ZDSECMGR_TC_DEVICE_MAX=2 -D     #
#                          NV_RESTORE -D HOLD_AUTO_START -D INTER_PAN -D      #
#                          LCD_SUPPORTED=DEBUG -D ZCL_BASIC -D ZCL_READ -D    #
#                          ZCL_WRITE -D ZCL_IDENTIFY -D ZCL_ON_OFF -D         #
#                          ZCL_SCENES -D ZCL_GROUPS -D                        #
#                          ZCL_LIGHT_LINK_ENHANCE -D ZCL_LEVEL_CTRL -D        #
#                          ZCL_COLOR_CTRL -D MAX_CHANNELS_24GHZ=0x02108800    #
#                          -D xPWM_ALT2 -D xTHERMAL_SHUTDOWN -D               #
#                          ZLL_1_0_HUB_COMPATIBILITY -D DALI_LIGHT -lC        #
#                          "D:\Texas Instruments\Z-Stack Lighting             #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\Zlight  #
#                          - Router\List\" -lA "D:\Texas Instruments\Z-Stack  #
#                          Lighting 1.0.2\Projects\zstack\ZLL\SampleApp\CC253 #
#                          x\Zlight - Router\List\" --diag_suppress           #
#                          Pe001,Pa010 -o "D:\Texas Instruments\Z-Stack       #
#                          Lighting 1.0.2\Projects\zstack\ZLL\SampleApp\CC253 #
#                          x\Zlight - Router\Obj\" -e --debug --core=plain    #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "D:\Texas                  #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\" -I    #
#                          "D:\Texas Instruments\Z-Stack Lighting             #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\Sour #
#                          ce\" -I "D:\Texas Instruments\Z-Stack Lighting     #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\S #
#                          ource\" -I "D:\Texas Instruments\Z-Stack Lighting  #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\HomeAutomation\Source\" -I "D:\Texas             #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\HomeAutomation\SampleLight\Source\" -I           #
#                          "D:\Texas Instruments\Z-Stack Lighting             #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\ZMain\TI2530DB\" -I "D:\Texas                    #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\hal\include\" -I "D:\Texas      #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\hal\target\CC2530PMP4712\" -I   #
#                          "D:\Texas Instruments\Z-Stack Lighting             #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mac\include\" -I "D:\Texas      #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mac\high_level\" -I "D:\Texas   #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mac\low_level\srf04\" -I        #
#                          "D:\Texas Instruments\Z-Stack Lighting             #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mac\low_level\srf04\single_chip #
#                          \" -I "D:\Texas Instruments\Z-Stack Lighting       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mt\" -I "D:\Texas               #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\osal\include\" -I "D:\Texas     #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\services\saddr\" -I "D:\Texas   #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\services\sdata\" -I "D:\Texas   #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\af\" -I "D:\Texas         #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\nwk\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\sapi\" -I "D:\Texas       #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\sec\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\sys\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\zcl\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\zdo\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\zmac\" -I "D:\Texas             #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\zmac\f8w\" -Ohz                 #
#                          --require_prototypes                               #
#    List file          =  D:\Texas Instruments\Z-Stack Lighting              #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\Zlight  #
#                          - Router\List\MT_UART.lst                          #
#    Object file        =  D:\Texas Instruments\Z-Stack Lighting              #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\Zlight  #
#                          - Router\Obj\MT_UART.r51                           #
#                                                                             #
#                                                                             #
###############################################################################

D:\Texas Instruments\Z-Stack Lighting 1.0.2\Components\mt\MT_UART.c
      1          /***************************************************************************************************
      2            Filename:       MT_UART.c
      3            Revised:        $Date: 2009-03-12 16:25:22 -0700 (Thu, 12 Mar 2009) $
      4            Revision:       $Revision: 19404 $
      5          
      6            Description:  This module handles anything dealing with the serial port.
      7          
      8            Copyright 2007 Texas Instruments Incorporated. All rights reserved.
      9          
     10            IMPORTANT: Your use of this Software is limited to those specific rights
     11            granted under the terms of a software license agreement between the user
     12            who downloaded the software, his/her employer (which must be your employer)
     13            and Texas Instruments Incorporated (the "License").  You may not use this
     14            Software unless you agree to abide by the terms of the License. The License
     15            limits your use, and you acknowledge, that the Software may not be modified,
     16            copied or distributed unless embedded on a Texas Instruments microcontroller
     17            or used solely and exclusively in conjunction with a Texas Instruments radio
     18            frequency transceiver, which is integrated into your product.  Other than for
     19            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     20            works of, modify, distribute, perform, display or sell this Software and/or
     21            its documentation for any purpose.
     22          
     23            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     24            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     25            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     26            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     27            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     28            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     29            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     30            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     31            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     32            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     33            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     34          
     35            Should you have any questions regarding your right to use this Software,
     36            contact Texas Instruments Incorporated at www.TI.com.
     37          
     38          ***************************************************************************************************/
     39          
     40          /***************************************************************************************************
     41           * INCLUDES
     42           ***************************************************************************************************/
     43          #include "ZComDef.h"
     44          #include "OSAL.h"
     45          #include "hal_uart.h"
     46          #include "MT.h"
     47          #include "MT_UART.h"
     48          #include "OSAL_Memory.h"
     49          
     50          
     51          /***************************************************************************************************
     52           * MACROS
     53           ***************************************************************************************************/
     54          
     55          /***************************************************************************************************
     56           * CONSTANTS
     57           ***************************************************************************************************/
     58          /* State values for ZTool protocal */
     59          #define SOP_STATE      0x00
     60          #define CMD_STATE1     0x01
     61          #define CMD_STATE2     0x02
     62          #define LEN_STATE      0x03
     63          #define DATA_STATE     0x04
     64          #define FCS_STATE      0x05
     65          
     66          /***************************************************************************************************
     67           *                                         GLOBAL VARIABLES
     68           ***************************************************************************************************/
     69          /* Used to indentify the application ID for osal task */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     70          byte App_TaskID;
   \                     App_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     71          
     72          /* ZTool protocal parameters */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     73          uint8 state;
   \                     state:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     74          uint8  CMD_Token[2];
   \                     CMD_Token:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     75          uint8  LEN_Token;
   \                     LEN_Token:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     76          uint8  FSC_Token;
   \                     FSC_Token:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     77          mtOSALSerialData_t  *pMsg;
   \                     pMsg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     78          uint8  tempDataLen;
   \                     tempDataLen:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     79          
     80          #if defined (ZAPP_P1) || defined (ZAPP_P2)
     81          uint16  MT_UartMaxZAppBufLen;
     82          bool    MT_UartZAppRxStatus;
     83          #endif
     84          
     85          
     86          /***************************************************************************************************
     87           *                                          LOCAL FUNCTIONS
     88           ***************************************************************************************************/
     89          
     90          /***************************************************************************************************
     91           * @fn      MT_UartInit
     92           *
     93           * @brief   Initialize MT with UART support
     94           *
     95           * @param   None
     96           *
     97           * @return  None
     98          ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     99          void MT_UartInit ()
   \                     MT_UartInit:
    100          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    101            halUARTCfg_t uartConfig;
    102          
    103            /* Initialize APP ID */
    104            App_TaskID = 0;
   \   000004   90....       MOV     DPTR,#App_TaskID
   \   000007   E4           CLR     A
   \   000008                REQUIRE ?Subroutine0
   \   000008                ; // Fall through to label ?Subroutine0
    105          
    106            /* UART Configuration */
    107            uartConfig.configured           = TRUE;
    108            uartConfig.baudRate             = MT_UART_DEFAULT_BAUDRATE;
    109            uartConfig.flowControl          = MT_UART_DEFAULT_OVERFLOW;
    110            uartConfig.flowControlThreshold = MT_UART_DEFAULT_THRESHOLD;
    111            uartConfig.rx.maxBufSize        = MT_UART_DEFAULT_MAX_RX_BUFF;
    112            uartConfig.tx.maxBufSize        = MT_UART_DEFAULT_MAX_TX_BUFF;
    113            uartConfig.idleTimeout          = MT_UART_DEFAULT_IDLE_TIMEOUT;
    114            uartConfig.intEnable            = TRUE;
    115          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    116            uartConfig.callBackFunc         = MT_UartProcessZToolData;
    117          #elif defined (ZAPP_P1) || defined (ZAPP_P2)
    118            uartConfig.callBackFunc         = MT_UartProcessZAppData;
    119          #else
    120            uartConfig.callBackFunc         = NULL;
    121          #endif
    122          
    123            /* Start UART */
    124          #if defined (MT_UART_DEFAULT_PORT)
    125            HalUARTOpen (MT_UART_DEFAULT_PORT, &uartConfig);
    126          #else
    127            /* Silence IAR compiler warning */
    128            (void)uartConfig;
    129          #endif
    130          
    131            /* Initialize for ZApp */
    132          #if defined (ZAPP_P1) || defined (ZAPP_P2)
    133            /* Default max bytes that ZAPP can take */
    134            MT_UartMaxZAppBufLen  = 1;
    135            MT_UartZAppRxStatus   = MT_UART_ZAPP_RX_READY;
    136          #endif
    137          
    138          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                REQUIRE ??Subroutine4_0
   \   000001                ; // Fall through to label ??Subroutine4_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine4_0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    139          
    140          /***************************************************************************************************
    141           * @fn      MT_SerialRegisterTaskID
    142           *
    143           * @brief   This function registers the taskID of the application so it knows
    144           *          where to send the messages whent they come in.
    145           *
    146           * @param   void
    147           *
    148           * @return  void
    149           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    150          void MT_UartRegisterTaskID( byte taskID )
   \                     MT_UartRegisterTaskID:
    151          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    152            App_TaskID = taskID;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#App_TaskID
   \   000008   80..         SJMP    ?Subroutine0
    153          }
    154          
    155          /***************************************************************************************************
    156           * @fn      SPIMgr_CalcFCS
    157           *
    158           * @brief   Calculate the FCS of a message buffer by XOR'ing each byte.
    159           *          Remember to NOT include SOP and FCS fields, so start at the CMD field.
    160           *
    161           * @param   byte *msg_ptr - message pointer
    162           * @param   byte len - length (in bytes) of message
    163           *
    164           * @return  result byte
    165           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    166          byte MT_UartCalcFCS( uint8 *msg_ptr, uint8 len )
   \                     MT_UartCalcFCS:
    167          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   FC           MOV     R4,A
    168            byte x;
    169            byte xorResult;
    170          
    171            xorResult = 0;
   \   000006   7900         MOV     R1,#0x0
    172          
    173            for ( x = 0; x < len; x++, msg_ptr++ )
   \   000008   7800         MOV     R0,#0x0
   \   00000A   800E         SJMP    ??MT_UartCalcFCS_0
    174              xorResult = xorResult ^ *msg_ptr;
   \                     ??MT_UartCalcFCS_1:
   \   00000C   8A82         MOV     DPL,R2
   \   00000E   8B83         MOV     DPH,R3
   \   000010   E0           MOVX    A,@DPTR
   \   000011   C9           XCH     A,R1
   \   000012   69           XRL     A,R1
   \   000013   F9           MOV     R1,A
   \   000014   08           INC     R0
   \   000015   A3           INC     DPTR
   \   000016   AA82         MOV     R2,DPL
   \   000018   AB83         MOV     R3,DPH
   \                     ??MT_UartCalcFCS_0:
   \   00001A   E8           MOV     A,R0
   \   00001B   C3           CLR     C
   \   00001C   9C           SUBB    A,R4
   \   00001D   40ED         JC      ??MT_UartCalcFCS_1
    175          
    176            return ( xorResult );
   \   00001F   80..         SJMP    ??Subroutine4_0
    177          }
    178          
    179          
    180          /***************************************************************************************************
    181           * @fn      MT_UartProcessZToolData
    182           *
    183           * @brief   | SOP | Data Length  |   CMD   |   Data   |  FCS  |
    184           *          |  1  |     1        |    2    |  0-Len   |   1   |
    185           *
    186           *          Parses the data and determine either is SPI or just simply serial data
    187           *          then send the data to correct place (MT or APP)
    188           *
    189           * @param   port     - UART port
    190           *          event    - Event that causes the callback
    191           *
    192           *
    193           * @return  None
    194           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    195          void MT_UartProcessZToolData ( uint8 port, uint8 event )
   \                     MT_UartProcessZToolData:
    196          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
    197            uint8  ch;
    198            uint8  bytesInRxBuffer;
    199            
    200            (void)event;  // Intentionally unreferenced parameter
   \   00000C   803D         SJMP    ??MT_UartProcessZToolData_0
    201          
    202            while (Hal_UART_RxBufLen(port))
    203            {
    204          //    HalUARTRead (port, &ch, 1);
    205              HalUARTReadAndFormate (port, &ch, 1);
    206              //HalUARTWrite(0,&ch,1);
    207          
    208              switch (state)
    209              {
    210                case SOP_STATE:
    211                  if (ch == MT_UART_SOF)
    212                  {
    213                    state = LEN_STATE;
    214                  }
    215                  break;
    216          
    217                case LEN_STATE:
    218                  LEN_Token = ch;
    219          
    220                  tempDataLen = 0;
    221          
    222                  /* Allocate memory for the data */
    223                  pMsg = (mtOSALSerialData_t *)osal_msg_allocate( sizeof ( mtOSALSerialData_t ) +
    224                                                                  MT_RPC_FRAME_HDR_SZ + LEN_Token );
    225          
    226                  if (pMsg)
    227                  {
    228                    /* Fill up what we can */
    229                    pMsg->hdr.event = CMD_SERIAL_MSG;
   \                     ??MT_UartProcessZToolData_1:
   \   00000E   12....       LCALL   ??Subroutine5_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000011   7401         MOV     A,#0x1
   \   000013   F0           MOVX    @DPTR,A
    230                    pMsg->msg = (uint8*)(pMsg+1);
   \   000014   90....       MOV     DPTR,#pMsg
   \   000017   E0           MOVX    A,@DPTR
   \   000018   2402         ADD     A,#0x2
   \   00001A   F8           MOV     R0,A
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   3400         ADDC    A,#0x0
   \   00001F   F9           MOV     R1,A
   \   000020   90....       MOV     DPTR,#pMsg
   \   000023   E0           MOVX    A,@DPTR
   \   000024   2404         ADD     A,#0x4
   \   000026   FA           MOV     R2,A
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   3400         ADDC    A,#0x0
   \   00002B   FB           MOV     R3,A
   \   00002C   8882         MOV     DPL,R0
   \   00002E   8983         MOV     DPH,R1
   \   000030   EA           MOV     A,R2
   \   000031   F0           MOVX    @DPTR,A
   \   000032   A3           INC     DPTR
   \   000033   EB           MOV     A,R3
   \   000034   F0           MOVX    @DPTR,A
    231                    pMsg->msg[MT_RPC_POS_LEN] = LEN_Token;
   \   000035   90....       MOV     DPTR,#LEN_Token
   \   000038   E0           MOVX    A,@DPTR
   \   000039   C0E0         PUSH    A
   \   00003B   8882         MOV     DPL,R0
   \   00003D   8983         MOV     DPH,R1
   \   00003F   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000042   D0E0         POP     A
   \   000044   F0           MOVX    @DPTR,A
    232                    state = CMD_STATE1;
   \   000045   90....       MOV     DPTR,#state
   \   000048   7401         MOV     A,#0x1
   \                     ??MT_UartProcessZToolData_2:
   \   00004A   F0           MOVX    @DPTR,A
    233                  }
    234                  else
    235                  {
    236                    state = SOP_STATE;
    237                    return;
    238                  }
    239                  break;
   \                     ??MT_UartProcessZToolData_0:
   \   00004B                ; Setup parameters for call to function Hal_UART_RxBufLen
   \   00004B   EE           MOV     A,R6
   \   00004C   F9           MOV     R1,A
   \   00004D   12....       LCALL   ??Hal_UART_RxBufLen?relay
   \   000050   8B..         MOV     ?V0 + 1,R3
   \   000052   EA           MOV     A,R2
   \   000053   45..         ORL     A,?V0 + 1
   \   000055   607C         JZ      ??MT_UartProcessZToolData_3
   \   000057                ; Setup parameters for call to function HalUARTReadAndFormate
   \   000057   7C01         MOV     R4,#0x1
   \   000059   7D00         MOV     R5,#0x0
   \   00005B   85..82       MOV     DPL,?XSP + 0
   \   00005E   85..83       MOV     DPH,?XSP + 1
   \   000061   AA82         MOV     R2,DPL
   \   000063   AB83         MOV     R3,DPH
   \   000065   EE           MOV     A,R6
   \   000066   F9           MOV     R1,A
   \   000067   12....       LCALL   ??HalUARTReadAndFormate?relay
   \   00006A   90....       MOV     DPTR,#state
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   6017         JZ      ??MT_UartProcessZToolData_4
   \   000070   14           DEC     A
   \   000071   606A         JZ      ??MT_UartProcessZToolData_5
   \   000073   14           DEC     A
   \   000074   607E         JZ      ??MT_UartProcessZToolData_6
   \   000076   14           DEC     A
   \   000077   6020         JZ      ??MT_UartProcessZToolData_7
   \   000079   14           DEC     A
   \   00007A   7003         JNZ     $+5
   \   00007C   02....       LJMP    ??MT_UartProcessZToolData_8 & 0xFFFF
   \   00007F   14           DEC     A
   \   000080   7003         JNZ     $+5
   \   000082   02....       LJMP    ??MT_UartProcessZToolData_9 & 0xFFFF
   \   000085   80C4         SJMP    ??MT_UartProcessZToolData_0
   \                     ??MT_UartProcessZToolData_4:
   \   000087   85..82       MOV     DPL,?XSP + 0
   \   00008A   85..83       MOV     DPH,?XSP + 1
   \   00008D   E0           MOVX    A,@DPTR
   \   00008E   64FE         XRL     A,#0xfe
   \   000090   70B9         JNZ     ??MT_UartProcessZToolData_0
   \   000092   90....       MOV     DPTR,#state
   \   000095   7403         MOV     A,#0x3
   \   000097   80B1         SJMP    ??MT_UartProcessZToolData_2
   \                     ??MT_UartProcessZToolData_7:
   \   000099   85..82       MOV     DPL,?XSP + 0
   \   00009C   85..83       MOV     DPH,?XSP + 1
   \   00009F   E0           MOVX    A,@DPTR
   \   0000A0   90....       MOV     DPTR,#LEN_Token
   \   0000A3   F0           MOVX    @DPTR,A
   \   0000A4   90....       MOV     DPTR,#tempDataLen
   \   0000A7   E4           CLR     A
   \   0000A8   F0           MOVX    @DPTR,A
   \   0000A9                ; Setup parameters for call to function osal_msg_allocate
   \   0000A9   90....       MOV     DPTR,#LEN_Token
   \   0000AC   E0           MOVX    A,@DPTR
   \   0000AD   2407         ADD     A,#0x7
   \   0000AF   FA           MOV     R2,A
   \   0000B0   E4           CLR     A
   \   0000B1   3400         ADDC    A,#0x0
   \   0000B3   FB           MOV     R3,A
   \   0000B4   12....       LCALL   ??osal_msg_allocate?relay
   \   0000B7   90....       MOV     DPTR,#pMsg
   \   0000BA   EA           MOV     A,R2
   \   0000BB   F0           MOVX    @DPTR,A
   \   0000BC   A3           INC     DPTR
   \   0000BD   EB           MOV     A,R3
   \   0000BE   F0           MOVX    @DPTR,A
   \   0000BF   90....       MOV     DPTR,#pMsg
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   F8           MOV     R0,A
   \   0000C4   A3           INC     DPTR
   \   0000C5   E0           MOVX    A,@DPTR
   \   0000C6   F9           MOV     R1,A
   \   0000C7   E8           MOV     A,R0
   \   0000C8   49           ORL     A,R1
   \   0000C9   6003         JZ      $+5
   \   0000CB   02....       LJMP    ??MT_UartProcessZToolData_1 & 0xFFFF
   \   0000CE   90....       MOV     DPTR,#state
   \   0000D1   E4           CLR     A
   \   0000D2   F0           MOVX    @DPTR,A
   \                     ??MT_UartProcessZToolData_3:
   \   0000D3   7401         MOV     A,#0x1
   \   0000D5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D8   7F02         MOV     R7,#0x2
   \   0000DA   02....       LJMP    ?BANKED_LEAVE_XDATA
    240          
    241                case CMD_STATE1:
    242                  pMsg->msg[MT_RPC_POS_CMD0] = ch;
   \                     ??MT_UartProcessZToolData_5:
   \   0000DD   85..82       MOV     DPL,?XSP + 0
   \   0000E0   85..83       MOV     DPH,?XSP + 1
   \   0000E3   E0           MOVX    A,@DPTR
   \   0000E4   C0E0         PUSH    A
   \   0000E6   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   0000E9   D0E0         POP     A
   \   0000EB   F0           MOVX    @DPTR,A
    243                  state = CMD_STATE2;
   \   0000EC   90....       MOV     DPTR,#state
   \   0000EF   7402         MOV     A,#0x2
   \   0000F1   02....       LJMP    ??MT_UartProcessZToolData_2 & 0xFFFF
    244                  break;
    245          
    246                case CMD_STATE2:
    247                  pMsg->msg[MT_RPC_POS_CMD1] = ch;
   \                     ??MT_UartProcessZToolData_6:
   \   0000F4   85..82       MOV     DPL,?XSP + 0
   \   0000F7   85..83       MOV     DPH,?XSP + 1
   \   0000FA   E0           MOVX    A,@DPTR
   \   0000FB   C0E0         PUSH    A
   \   0000FD   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000100   A3           INC     DPTR
   \   000101   D0E0         POP     A
   \   000103   F0           MOVX    @DPTR,A
    248                  /* If there is no data, skip to FCS state */
    249                  if (LEN_Token)
   \   000104   90....       MOV     DPTR,#LEN_Token
   \   000107   E0           MOVX    A,@DPTR
   \   000108   6072         JZ      ??MT_UartProcessZToolData_10
    250                  {
    251                    state = DATA_STATE;
   \   00010A   90....       MOV     DPTR,#state
   \   00010D   7404         MOV     A,#0x4
   \   00010F   02....       LJMP    ??MT_UartProcessZToolData_2 & 0xFFFF
    252                  }
    253                  else
    254                  {
    255                    state = FCS_STATE;
    256                  }
    257                  break;
    258          
    259                case DATA_STATE:
    260          
    261                  /* Fill in the buffer the first byte of the data */
    262                  pMsg->msg[MT_RPC_FRAME_HDR_SZ + tempDataLen++] = ch;
   \                     ??MT_UartProcessZToolData_8:
   \   000112   85..82       MOV     DPL,?XSP + 0
   \   000115   85..83       MOV     DPH,?XSP + 1
   \   000118   E0           MOVX    A,@DPTR
   \   000119   C0E0         PUSH    A
   \   00011B   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   00011E   D0E0         POP     A
   \   000120   F0           MOVX    @DPTR,A
   \   000121   90....       MOV     DPTR,#tempDataLen
   \   000124   E0           MOVX    A,@DPTR
   \   000125   04           INC     A
   \   000126   F0           MOVX    @DPTR,A
    263          
    264                  /* Check number of bytes left in the Rx buffer */
    265          //        bytesInRxBuffer = Hal_UART_RxBufLen(port);
    266                  bytesInRxBuffer = (Hal_UART_RxBufLen(port)/2);
   \   000127                ; Setup parameters for call to function Hal_UART_RxBufLen
   \   000127   EE           MOV     A,R6
   \   000128   F9           MOV     R1,A
   \   000129   12....       LCALL   ??Hal_UART_RxBufLen?relay
   \   00012C   EB           MOV     A,R3
   \   00012D   C3           CLR     C
   \   00012E   13           RRC     A
   \   00012F   EA           MOV     A,R2
   \   000130   13           RRC     A
   \   000131   FF           MOV     R7,A
    267          
    268                  /* If the remain of the data is there, read them all, otherwise, just read enough */
    269                  if (bytesInRxBuffer <= LEN_Token - tempDataLen)
   \   000132   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   000135   AA82         MOV     R2,DPL
   \   000137   AB83         MOV     R3,DPH
   \   000139   90....       MOV     DPTR,#LEN_Token
   \   00013C   E0           MOVX    A,@DPTR
   \   00013D   C3           CLR     C
   \   00013E   98           SUBB    A,R0
   \   00013F   FC           MOV     R4,A
   \   000140   95E0         SUBB    A,0xE0 /* A   */
   \   000142   FD           MOV     R5,A
   \   000143   8F..         MOV     ?V0 + 0,R7
   \   000145   C3           CLR     C
   \   000146   EC           MOV     A,R4
   \   000147   95..         SUBB    A,?V0 + 0
   \   000149   ED           MOV     A,R5
   \   00014A   9400         SUBB    A,#0x0
   \   00014C   A2D2         MOV     C,0xD0 /* PSW */.2
   \   00014E   65D0         XRL     A,PSW
   \   000150   33           RLC     A
   \   000151   4010         JC      ??MT_UartProcessZToolData_11
    270                  {
    271          //          HalUARTRead (port, &pMsg->msg[MT_RPC_FRAME_HDR_SZ + tempDataLen], bytesInRxBuffer);
    272                    HalUARTReadAndFormate (port, &pMsg->msg[MT_RPC_FRAME_HDR_SZ + tempDataLen], bytesInRxBuffer);
   \   000153                ; Setup parameters for call to function HalUARTReadAndFormate
   \   000153   AC..         MOV     R4,?V0 + 0
   \   000155   7D00         MOV     R5,#0x0
   \   000157   EE           MOV     A,R6
   \   000158   F9           MOV     R1,A
   \   000159   12....       LCALL   ??HalUARTReadAndFormate?relay
    273                    tempDataLen += bytesInRxBuffer;
   \   00015C   90....       MOV     DPTR,#tempDataLen
   \   00015F   E0           MOVX    A,@DPTR
   \   000160   2F           ADD     A,R7
   \   000161   800C         SJMP    ??MT_UartProcessZToolData_12
    274                  }
    275                  else
    276                  {
    277          //          HalUARTRead (port, &pMsg->msg[MT_RPC_FRAME_HDR_SZ + tempDataLen], LEN_Token - tempDataLen);
    278                    HalUARTReadAndFormate (port, &pMsg->msg[MT_RPC_FRAME_HDR_SZ + tempDataLen], LEN_Token - tempDataLen);
   \                     ??MT_UartProcessZToolData_11:
   \   000163                ; Setup parameters for call to function HalUARTReadAndFormate
   \   000163   EE           MOV     A,R6
   \   000164   F9           MOV     R1,A
   \   000165   12....       LCALL   ??HalUARTReadAndFormate?relay
    279                    tempDataLen += (LEN_Token - tempDataLen);
   \   000168   90....       MOV     DPTR,#LEN_Token
   \   00016B   E0           MOVX    A,@DPTR
   \   00016C   90....       MOV     DPTR,#tempDataLen
   \                     ??MT_UartProcessZToolData_12:
   \   00016F   F0           MOVX    @DPTR,A
    280                  }
    281          
    282                  /* If number of bytes read is equal to data length, time to move on to FCS */
    283                  if ( tempDataLen == LEN_Token )
   \   000170   E0           MOVX    A,@DPTR
   \   000171   F8           MOV     R0,A
   \   000172   90....       MOV     DPTR,#LEN_Token
   \   000175   E0           MOVX    A,@DPTR
   \   000176   68           XRL     A,R0
   \   000177   6003         JZ      $+5
   \   000179   02....       LJMP    ??MT_UartProcessZToolData_0 & 0xFFFF
    284                      state = FCS_STATE;
   \                     ??MT_UartProcessZToolData_10:
   \   00017C   90....       MOV     DPTR,#state
   \   00017F   7405         MOV     A,#0x5
   \   000181   02....       LJMP    ??MT_UartProcessZToolData_2 & 0xFFFF
    285          
    286                  break;
    287          
    288                case FCS_STATE:
    289          
    290                  FSC_Token = ch;
   \                     ??MT_UartProcessZToolData_9:
   \   000184   85..82       MOV     DPL,?XSP + 0
   \   000187   85..83       MOV     DPH,?XSP + 1
   \   00018A   E0           MOVX    A,@DPTR
   \   00018B   90....       MOV     DPTR,#FSC_Token
   \   00018E   F0           MOVX    @DPTR,A
    291          
    292                  /* Make sure it's correct */
    293          //        if ((MT_UartCalcFCS ((uint8*)&pMsg->msg[0], MT_RPC_FRAME_HDR_SZ + LEN_Token) == FSC_Token))
    294          //        {
    295                    osal_msg_send( App_TaskID, (byte *)pMsg );
   \   00018F                ; Setup parameters for call to function osal_msg_send
   \   00018F   90....       MOV     DPTR,#pMsg
   \   000192   E0           MOVX    A,@DPTR
   \   000193   FA           MOV     R2,A
   \   000194   A3           INC     DPTR
   \   000195   E0           MOVX    A,@DPTR
   \   000196   FB           MOV     R3,A
   \   000197   90....       MOV     DPTR,#App_TaskID
   \   00019A   E0           MOVX    A,@DPTR
   \   00019B   F9           MOV     R1,A
   \   00019C   12....       LCALL   ??osal_msg_send?relay
    296          //        }
    297          //        else
    298          //        {
    299                    /* deallocate the msg */
    300          //          osal_msg_deallocate ( (uint8 *)pMsg );
    301          //        }
    302          
    303                  /* Reset the state, send or discard the buffers at this point */
    304                  state = SOP_STATE;
   \   00019F   90....       MOV     DPTR,#state
   \   0001A2   E4           CLR     A
   \   0001A3   02....       LJMP    ??MT_UartProcessZToolData_2 & 0xFFFF
    305          
    306                  break;
    307          
    308                default:
    309                 break;
    310              }
    311            }
    312          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   90....       MOV     DPTR,#pMsg
   \   000003   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   00000B   A3           INC     DPTR
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine5_0
   \   000003                ; // Fall through to label ??Subroutine5_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine5_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F583         MOV     DPH,A
   \   000003   8882         MOV     DPL,R0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   90....       MOV     DPTR,#tempDataLen
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F8           MOV     R0,A
   \   000005   90....       MOV     DPTR,#pMsg
   \   000008   E0           MOVX    A,@DPTR
   \   000009   FA           MOV     R2,A
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F583         MOV     DPH,A
   \   00000E   8A82         MOV     DPL,R2
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   28           ADD     A,R0
   \   000014   FA           MOV     R2,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   3400         ADDC    A,#0x0
   \   000019   8A82         MOV     DPL,R2
   \   00001B   F583         MOV     DPH,A
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   22           RET

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_UartInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_UartRegisterTaskID?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartRegisterTaskID

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_UartCalcFCS?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartCalcFCS

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_UartProcessZToolData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartProcessZToolData
    313          
    314          #if defined (ZAPP_P1) || defined (ZAPP_P2)
    315          /***************************************************************************************************
    316           * @fn      MT_UartProcessZAppData
    317           *
    318           * @brief   | SOP | CMD  |   Data Length   | FSC  |
    319           *          |  1  |  2   |       1         |  1   |
    320           *
    321           *          Parses the data and determine either is SPI or just simply serial data
    322           *          then send the data to correct place (MT or APP)
    323           *
    324           * @param   port    - UART port
    325           *          event   - Event that causes the callback
    326           *
    327           *
    328           * @return  None
    329           ***************************************************************************************************/
    330          void MT_UartProcessZAppData ( uint8 port, uint8 event )
    331          {
    332          
    333            osal_event_hdr_t  *msg_ptr;
    334            uint16 length = 0;
    335            uint16 rxBufLen  = Hal_UART_RxBufLen(MT_UART_DEFAULT_PORT);
    336          
    337            /*
    338               If maxZAppBufferLength is 0 or larger than current length
    339               the entire length of the current buffer is returned.
    340            */
    341            if ((MT_UartMaxZAppBufLen != 0) && (MT_UartMaxZAppBufLen <= rxBufLen))
    342            {
    343              length = MT_UartMaxZAppBufLen;
    344            }
    345            else
    346            {
    347              length = rxBufLen;
    348            }
    349          
    350            /* Verify events */
    351            if (event == HAL_UART_TX_FULL)
    352            {
    353              // Do something when TX if full
    354              return;
    355            }
    356          
    357            if (event & ( HAL_UART_RX_FULL | HAL_UART_RX_ABOUT_FULL | HAL_UART_RX_TIMEOUT))
    358            {
    359              if ( App_TaskID )
    360              {
    361                /*
    362                   If Application is ready to receive and there is something
    363                   in the Rx buffer then send it up
    364                */
    365                if ((MT_UartZAppRxStatus == MT_UART_ZAPP_RX_READY ) && (length != 0))
    366                {
    367                  /* Disable App flow control until it processes the current data */
    368                   MT_UartAppFlowControl (MT_UART_ZAPP_RX_NOT_READY);
    369          
    370                  /* 2 more bytes are added, 1 for CMD type, other for length */
    371                  msg_ptr = (osal_event_hdr_t *)osal_msg_allocate( length + sizeof(osal_event_hdr_t) );
    372                  if ( msg_ptr )
    373                  {
    374                    msg_ptr->event = SPI_INCOMING_ZAPP_DATA;
    375                    msg_ptr->status = length;
    376          
    377                    /* Read the data of Rx buffer */
    378                    HalUARTRead( MT_UART_DEFAULT_PORT, (uint8 *)(msg_ptr + 1), length );
    379          
    380                    /* Send the raw data to application...or where ever */
    381                    osal_msg_send( App_TaskID, (uint8 *)msg_ptr );
    382                  }
    383                }
    384              }
    385            }
    386          }
    387          
    388          /***************************************************************************************************
    389           * @fn      SPIMgr_ZAppBufferLengthRegister
    390           *
    391           * @brief
    392           *
    393           * @param   maxLen - Max Length that the application wants at a time
    394           *
    395           * @return  None
    396           *
    397           ***************************************************************************************************/
    398          void MT_UartZAppBufferLengthRegister ( uint16 maxLen )
    399          {
    400            /* If the maxLen is larger than the RX buff, something is not right */
    401            if (maxLen <= MT_UART_DEFAULT_MAX_RX_BUFF)
    402              MT_UartMaxZAppBufLen = maxLen;
    403            else
    404              MT_UartMaxZAppBufLen = 1; /* default is 1 byte */
    405          }
    406          
    407          /***************************************************************************************************
    408           * @fn      SPIMgr_AppFlowControl
    409           *
    410           * @brief
    411           *
    412           * @param   status - ready to send or not
    413           *
    414           * @return  None
    415           *
    416           ***************************************************************************************************/
    417          void MT_UartAppFlowControl ( bool status )
    418          {
    419          
    420            /* Make sure only update if needed */
    421            if (status != MT_UartZAppRxStatus )
    422            {
    423              MT_UartZAppRxStatus = status;
    424            }
    425          
    426            /* App is ready to read again, ProcessZAppData have to be triggered too */
    427            if (status == MT_UART_ZAPP_RX_READY)
    428            {
    429              MT_UartProcessZAppData (MT_UART_DEFAULT_PORT, HAL_UART_RX_TIMEOUT );
    430            }
    431          
    432          }
    433          
    434          #endif //ZAPP
    435          
    436          /***************************************************************************************************
    437          ***************************************************************************************************/

   Maximum stack usage in bytes:

   ISTACK PSTACK XSTACK Function
   ------ ------ ------ --------
       2      0      0  MT_UartCalcFCS
       2      0      0  MT_UartInit
       1      0     11  MT_UartProcessZToolData
                          0 0 11 -> HalUARTReadAndFormate
                          0 0 11 -> Hal_UART_RxBufLen
                          0 0 11 -> osal_msg_allocate
                          0 0 11 -> osal_msg_send
       2      0      0  MT_UartRegisterTaskID


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       6  ??MT_UartCalcFCS?relay
       6  ??MT_UartInit?relay
       6  ??MT_UartProcessZToolData?relay
       6  ??MT_UartRegisterTaskID?relay
       7  ??Subroutine4_0
       6  ??Subroutine5_0
       1  ?Subroutine0
      33  ?Subroutine1
      13  ?Subroutine2
       3  ?Subroutine3
       1  App_TaskID
       2  CMD_Token
       1  FSC_Token
       1  LEN_Token
      33  MT_UartCalcFCS
       8  MT_UartInit
     422  MT_UartProcessZToolData
      10  MT_UartRegisterTaskID
       2  pMsg
       1  state
       1  tempDataLen

 
 536 bytes in segment BANKED_CODE
  24 bytes in segment BANK_RELAYS
   9 bytes in segment XDATA_Z
 
 560 bytes of CODE  memory
   9 bytes of XDATA memory

Errors: none
Warnings: none
