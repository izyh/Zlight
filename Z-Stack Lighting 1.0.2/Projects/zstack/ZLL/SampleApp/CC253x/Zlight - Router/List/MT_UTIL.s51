///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V8.20.2.41139 for 8051            27/May/2014  19:13:48 /
// Copyright 2004-2013 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  banked                                            /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data_rom                                          /
//    Dptr setup         =  1,16                                              /
//                                                                            /
//    Source file        =  D:\Texas Instruments\Z-Stack Lighting             /
//                          1.0.2\Components\mt\MT_UTIL.c                     /
//    Command line       =  -f "D:\Texas Instruments\Z-Stack Lighting         /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          ..\Tools\CC2530DB\f8wRouter.cfg" (-DCPU32MHZ      /
//                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TR /
//                          UE -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8     /
//                          -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f "D:\Texas        /
//                          Instruments\Z-Stack Lighting                      /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          ..\Tools\CC2530DB\f8wConfig.cfg" (-DZIGBEEPRO     /
//                          -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR      /
//                          -DDEFAULT_CHANLIST=0x00000800                     /
//                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                      /
//                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_M /
//                          ASK=0x007F -DBEACON_REQUEST_DELAY=100             /
//                          -DBEACON_REQ_DELAY_MASK=0x00FF                    /
//                          -DLINK_STATUS_JITTER_MASK=0x007F                  /
//                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_P /
//                          OLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7           /
//                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3   /
//                          -DNWK_MAX_DATA_RETRIES=2                          /
//                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9        /
//                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40          /
//                          -DNWK_MAX_BINDING_ENTRIES=4                       /
//                          -DMAX_BINDING_CLUSTER_IDS=4                       /
//                          "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07, 0x09,     /
//                          0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08,   /
//                          0x0A, 0x0C, 0x0D}" -DMAC_MAX_FRAME_SIZE=116       /
//                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const    /
//                          __code" -DGENERIC=__generic                       /
//                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000       /
//                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100   /
//                          -DREJOIN_POLL_RATE=440) -f "D:\Texas              /
//                          Instruments\Z-Stack Lighting                      /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          ..\Tools\CC2530DB\f8wZCL.cfg" "D:\Texas           /
//                          Instruments\Z-Stack Lighting                      /
//                          1.0.2\Components\mt\MT_UTIL.c" -D                 /
//                          FEATURE_GREEN_POWER -D SECURE=1 -D                /
//                          TC_LINKKEY_JOIN -D ZDSECMGR_TC_DEVICE_MAX=2 -D    /
//                          NV_RESTORE -D HOLD_AUTO_START -D INTER_PAN -D     /
//                          LCD_SUPPORTED=DEBUG -D ZCL_BASIC -D ZCL_READ -D   /
//                          ZCL_WRITE -D ZCL_IDENTIFY -D ZCL_ON_OFF -D        /
//                          ZCL_SCENES -D ZCL_GROUPS -D                       /
//                          ZCL_LIGHT_LINK_ENHANCE -D ZCL_LEVEL_CTRL -D       /
//                          ZCL_COLOR_CTRL -D MAX_CHANNELS_24GHZ=0x02108800   /
//                          -D xPWM_ALT2 -D xTHERMAL_SHUTDOWN -D              /
//                          ZLL_1_0_HUB_COMPATIBILITY -D DALI_LIGHT -lC       /
//                          "D:\Texas Instruments\Z-Stack Lighting            /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\Zlight /
//                           - Router\List\" -lA "D:\Texas                    /
//                          Instruments\Z-Stack Lighting                      /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\Zlight /
//                           - Router\List\" --diag_suppress Pe001,Pa010 -o   /
//                          "D:\Texas Instruments\Z-Stack Lighting            /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\Zlight /
//                           - Router\Obj\" -e --debug --core=plain           /
//                          --dptr=16,1 --data_model=large                    /
//                          --code_model=banked --calling_convention=xdata_re /
//                          entrant --place_constants=data_rom                /
//                          --nr_virtual_regs 16 -I "D:\Texas                 /
//                          Instruments\Z-Stack Lighting                      /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\" -I   /
//                          "D:\Texas Instruments\Z-Stack Lighting            /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\Sou /
//                          rce\" -I "D:\Texas Instruments\Z-Stack Lighting   /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          Source\" -I "D:\Texas Instruments\Z-Stack         /
//                          Lighting 1.0.2\Projects\zstack\ZLL\SampleApp\CC25 /
//                          3x\..\..\..\HomeAutomation\Source\" -I "D:\Texas  /
//                          Instruments\Z-Stack Lighting                      /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          ..\HomeAutomation\SampleLight\Source\" -I         /
//                          "D:\Texas Instruments\Z-Stack Lighting            /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          ..\ZMain\TI2530DB\" -I "D:\Texas                  /
//                          Instruments\Z-Stack Lighting                      /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          ..\..\..\Components\hal\include\" -I "D:\Texas    /
//                          Instruments\Z-Stack Lighting                      /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          ..\..\..\Components\hal\target\CC2530PMP4712\"    /
//                          -I "D:\Texas Instruments\Z-Stack Lighting         /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          ..\..\..\Components\mac\include\" -I "D:\Texas    /
//                          Instruments\Z-Stack Lighting                      /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          ..\..\..\Components\mac\high_level\" -I           /
//                          "D:\Texas Instruments\Z-Stack Lighting            /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          ..\..\..\Components\mac\low_level\srf04\" -I      /
//                          "D:\Texas Instruments\Z-Stack Lighting            /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          ..\..\..\Components\mac\low_level\srf04\single_ch /
//                          ip\" -I "D:\Texas Instruments\Z-Stack Lighting    /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          ..\..\..\Components\mt\" -I "D:\Texas             /
//                          Instruments\Z-Stack Lighting                      /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          ..\..\..\Components\osal\include\" -I "D:\Texas   /
//                          Instruments\Z-Stack Lighting                      /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          ..\..\..\Components\services\saddr\" -I           /
//                          "D:\Texas Instruments\Z-Stack Lighting            /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          ..\..\..\Components\services\sdata\" -I           /
//                          "D:\Texas Instruments\Z-Stack Lighting            /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          ..\..\..\Components\stack\af\" -I "D:\Texas       /
//                          Instruments\Z-Stack Lighting                      /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          ..\..\..\Components\stack\nwk\" -I "D:\Texas      /
//                          Instruments\Z-Stack Lighting                      /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          ..\..\..\Components\stack\sapi\" -I "D:\Texas     /
//                          Instruments\Z-Stack Lighting                      /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          ..\..\..\Components\stack\sec\" -I "D:\Texas      /
//                          Instruments\Z-Stack Lighting                      /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          ..\..\..\Components\stack\sys\" -I "D:\Texas      /
//                          Instruments\Z-Stack Lighting                      /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          ..\..\..\Components\stack\zcl\" -I "D:\Texas      /
//                          Instruments\Z-Stack Lighting                      /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          ..\..\..\Components\stack\zdo\" -I "D:\Texas      /
//                          Instruments\Z-Stack Lighting                      /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          ..\..\..\Components\zmac\" -I "D:\Texas           /
//                          Instruments\Z-Stack Lighting                      /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\ /
//                          ..\..\..\Components\zmac\f8w\" -Ohz               /
//                          --require_prototypes                              /
//    List file          =  D:\Texas Instruments\Z-Stack Lighting             /
//                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\Zlight /
//                           - Router\List\MT_UTIL.s51                        /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME MT_UTIL

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)


        END
// D:\Texas Instruments\Z-Stack Lighting 1.0.2\Components\mt\MT_UTIL.c
//    1 /***************************************************************************************************
//    2   Filename:       MT_UTIL.c
//    3   Revised:        $Date: 2013-11-13 13:09:12 -0800 (Wed, 13 Nov 2013) $
//    4   Revision:       $Revision: 36079 $
//    5 
//    6   Description:    MonitorTest Utility Functions
//    7 
//    8   Copyright 2007-2013 Texas Instruments Incorporated. All rights reserved.
//    9 
//   10   IMPORTANT: Your use of this Software is limited to those specific rights
//   11   granted under the terms of a software license agreement between the user
//   12   who downloaded the software, his/her employer (which must be your employer)
//   13   and Texas Instruments Incorporated (the "License"). You may not use this
//   14   Software unless you agree to abide by the terms of the License. The License
//   15   limits your use, and you acknowledge, that the Software may not be modified,
//   16   copied or distributed unless embedded on a Texas Instruments microcontroller
//   17   or used solely and exclusively in conjunction with a Texas Instruments radio
//   18   frequency transceiver, which is integrated into your product. Other than for
//   19   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   20   works of, modify, distribute, perform, display or sell this Software and/or
//   21   its documentation for any purpose.
//   22 
//   23   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   24   PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   25   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   26   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   27   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   28   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   29   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   30   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   31   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   32   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   33   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   34 
//   35   Should you have any questions regarding your right to use this Software,
//   36   contact Texas Instruments Incorporated at www.TI.com.
//   37 
//   38  ***************************************************************************************************/
//   39 
//   40 /***************************************************************************************************
//   41  * INCLUDES
//   42  ***************************************************************************************************/
//   43 #include "ZComDef.h"
//   44 
//   45 #include "AddrMgr.h"
//   46 
//   47 #include "OnBoard.h"   /* This is here because of the key reading */
//   48 #include "hal_key.h"
//   49 #include "hal_led.h"
//   50 #include "OSAL_Nv.h"
//   51 #include "osal.h"
//   52 #include "NLMEDE.h"
//   53 #include "MT.h"
//   54 #include "MT_UTIL.h"
//   55 #include "MT_MAC.h"
//   56 #include "ssp.h"
//   57 #if defined ZCL_KEY_ESTABLISH
//   58 #include "zcl_key_establish.h"
//   59 #if defined TC_LINKKEY_JOIN
//   60 #include "zcl_se.h"
//   61 #endif
//   62 #endif
//   63 
//   64 #if !defined NONWK
//   65 #include "MT_ZDO.h"
//   66 #include "MT_SAPI.h"
//   67 #include "MT_NWK.h"
//   68 #include "MT_AF.h"
//   69 #include "AssocList.h"
//   70 #include "ZDApp.h"
//   71 #include "ZDSecMgr.h"
//   72 #endif
//   73 
//   74 #if defined MT_SRNG
//   75 #include "hal_srng.h"
//   76 #endif
//   77 /***************************************************************************************************
//   78  * CONSTANTS
//   79  ***************************************************************************************************/
//   80 #define MT_UTIL_DEVICE_INFO_RESPONSE_LEN 14
//   81 #define MT_UTIL_STATUS_LEN    1
//   82 #define MT_UTIL_FRM_CTR_LEN   4
//   83 // Status + LinkKeyDataLen + Tx+Rx Frame counter.
//   84 #define MT_APSME_LINKKEY_GET_RSP_LEN (MT_UTIL_STATUS_LEN + SEC_KEY_LEN + (MT_UTIL_FRM_CTR_LEN * 2))
//   85 // Status + NV id
//   86 #define MT_APSME_LINKKEY_NV_ID_GET_RSP_LEN (MT_UTIL_STATUS_LEN + 2)
//   87 
//   88 /***************************************************************************************************
//   89  * LOCAL VARIABLES
//   90  ***************************************************************************************************/
//   91 #if defined ZCL_KEY_ESTABLISH
//   92 uint8 zcl_key_establish_task_id;
//   93 #endif
//   94 
//   95 /***************************************************************************************************
//   96  * LOCAL FUNCTIONS
//   97  ***************************************************************************************************/
//   98 #ifdef AUTO_PEND
//   99 static void MT_UtilRevExtCpy( uint8 *pDst, uint8 *pSrc );
//  100 static void MT_UtilSpi2Addr( zAddrType_t *pDst, uint8 *pSrc );
//  101 #endif
//  102 
//  103 #if defined (MT_UTIL_FUNC)
//  104 void MT_UtilGetDeviceInfo(void);
//  105 void MT_UtilGetNvInfo(void);
//  106 void MT_UtilSetPanID(uint8 *pBuf);
//  107 void MT_UtilSetChannels(uint8 *pBuf);
//  108 void MT_UtilSetSecLevel(uint8 *pBuf);
//  109 void MT_UtilSetPreCfgKey(uint8 *pBuf);
//  110 void MT_UtilCallbackSub(uint8 *pData);
//  111 void MT_UtilKeyEvent(uint8 *pBuf);
//  112 void MT_UtilTimeAlive(void);
//  113 void MT_UtilLedControl(uint8 *pBuf);
//  114 void MT_UtilSrcMatchEnable (uint8 *pBuf);
//  115 void MT_UtilSrcMatchAddEntry (uint8 *pBuf);
//  116 void MT_UtilSrcMatchDeleteEntry (uint8 *pBuf);
//  117 void MT_UtilSrcMatchCheckSrcAddr (uint8 *pBuf);
//  118 void MT_UtilSrcMatchAckAllPending (uint8 *pBuf);
//  119 void MT_UtilSrcMatchCheckAllPending (uint8 *pBuf);
//  120 #ifdef MT_SRNG
//  121 void MT_UtilSrngGen(void);
//  122 #endif
//  123 
//  124 #if !defined NONWK
//  125 void MT_UtilDataReq(uint8 *pBuf);
//  126 static void MT_UtilAddrMgrEntryLookupExt(uint8 *pBuf);
//  127 static void MT_UtilAddrMgrEntryLookupNwk(uint8 *pBuf);
//  128 #if defined MT_SYS_KEY_MANAGEMENT
//  129 static void MT_UtilAPSME_LinkKeyDataGet(uint8 *pBuf);
//  130 static void MT_UtilAPSME_LinkKeyNvIdGet(uint8 *pBuf);
//  131 #endif //MT_SYS_KEY_MANAGEMENT
//  132 static void MT_UtilAPSME_RequestKeyCmd(uint8 *pBuf);
//  133 static void MT_UtilAssocCount(uint8 *pBuf);
//  134 static void MT_UtilAssocFindDevice(uint8 *pBuf);
//  135 static void MT_UtilAssocGetWithAddress(uint8 *pBuf);
//  136 static void MT_UtilBindAddEntry(uint8 *pBuf);
//  137 static void packDev_t(uint8 *pBuf, associated_devices_t *pDev);
//  138 static void packBindEntry_t(uint8 *pBuf, BindingEntry_t *pBind);
//  139 #if defined ZCL_KEY_ESTABLISH
//  140 static void MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment(uint8 *pBuf);
//  141 static void MT_UtilzclGeneral_KeyEstablishment_ECDSASign(uint8 *pBuf);
//  142 #endif // ZCL_KEY_ESTABLISH
//  143 static void MT_UtilSync(void);
//  144 #endif // !defined NONWK
//  145 #endif // MT_UTIL_FUNC
//  146 
//  147 #if defined (MT_UTIL_FUNC)
//  148 /***************************************************************************************************
//  149 * @fn      MT_UtilProcessing
//  150 *
//  151 * @brief   Process all the DEBUG commands that are issued by test tool
//  152 *
//  153 * @param   pBuf  - pointer to received SPI data message
//  154 *
//  155 * @return  status
//  156 ***************************************************************************************************/
//  157 uint8 MT_UtilCommandProcessing(uint8 *pBuf)
//  158 {
//  159   uint8 status = MT_RPC_SUCCESS;
//  160 
//  161   switch (pBuf[MT_RPC_POS_CMD1])
//  162   {
//  163     // CC253X MAC Network Processor does not have NV support
//  164 #if !defined(CC253X_MACNP)
//  165   case MT_UTIL_GET_DEVICE_INFO:
//  166     MT_UtilGetDeviceInfo();
//  167     break;
//  168 
//  169   case MT_UTIL_GET_NV_INFO:
//  170     MT_UtilGetNvInfo();
//  171     break;
//  172 
//  173   case MT_UTIL_SET_PANID:
//  174     MT_UtilSetPanID(pBuf);
//  175     break;
//  176 
//  177   case MT_UTIL_SET_CHANNELS:
//  178     MT_UtilSetChannels(pBuf);
//  179     break;
//  180 
//  181   case MT_UTIL_SET_SECLEVEL:
//  182     MT_UtilSetSecLevel(pBuf);
//  183     break;
//  184 
//  185   case MT_UTIL_SET_PRECFGKEY:
//  186     MT_UtilSetPreCfgKey(pBuf);
//  187     break;
//  188 #endif
//  189   case MT_UTIL_CALLBACK_SUB_CMD:
//  190     MT_UtilCallbackSub(pBuf);
//  191     break;
//  192 
//  193   case MT_UTIL_KEY_EVENT:
//  194 #if (defined HAL_KEY) && (HAL_KEY == TRUE)
//  195     MT_UtilKeyEvent(pBuf);
//  196 #endif
//  197     break;
//  198 
//  199   case MT_UTIL_TIME_ALIVE:
//  200     MT_UtilTimeAlive();
//  201     break;
//  202 
//  203   case MT_UTIL_LED_CONTROL:
//  204 #if (defined HAL_LED) && (HAL_LED == TRUE)
//  205     MT_UtilLedControl(pBuf);
//  206 #endif
//  207     break;
//  208 
//  209   case MT_UTIL_SRC_MATCH_ENABLE:
//  210     MT_UtilSrcMatchEnable(pBuf);
//  211     break;
//  212 
//  213   case MT_UTIL_SRC_MATCH_ADD_ENTRY:
//  214     MT_UtilSrcMatchAddEntry(pBuf);
//  215     break;
//  216 
//  217   case MT_UTIL_SRC_MATCH_DEL_ENTRY:
//  218     MT_UtilSrcMatchDeleteEntry(pBuf);
//  219     break;
//  220 
//  221   case MT_UTIL_SRC_MATCH_CHECK_SRC_ADDR:
//  222     MT_UtilSrcMatchCheckSrcAddr(pBuf);
//  223     break;
//  224 
//  225   case MT_UTIL_SRC_MATCH_ACK_ALL_PENDING:
//  226     MT_UtilSrcMatchAckAllPending(pBuf);
//  227     break;
//  228 
//  229   case MT_UTIL_SRC_MATCH_CHECK_ALL_PENDING:
//  230     MT_UtilSrcMatchCheckAllPending(pBuf);
//  231     break;
//  232 
//  233   case MT_UTIL_TEST_LOOPBACK:
//  234     MT_BuildAndSendZToolResponse((MT_RPC_CMD_SRSP|(uint8)MT_RPC_SYS_UTIL), MT_UTIL_TEST_LOOPBACK,
//  235                                  pBuf[MT_RPC_POS_LEN], (pBuf+MT_RPC_FRAME_HDR_SZ));
//  236     break;
//  237 
//  238 #if !defined NONWK
//  239   case MT_UTIL_DATA_REQ:
//  240     MT_UtilDataReq(pBuf);
//  241     break;
//  242 
//  243   case MT_UTIL_ADDRMGR_EXT_ADDR_LOOKUP:
//  244     MT_UtilAddrMgrEntryLookupExt(pBuf);
//  245     break;
//  246 
//  247   case MT_UTIL_ADDRMGR_NWK_ADDR_LOOKUP:
//  248     MT_UtilAddrMgrEntryLookupNwk(pBuf);
//  249     break;
//  250 
//  251 #if defined MT_SYS_KEY_MANAGEMENT
//  252   case MT_UTIL_APSME_LINK_KEY_DATA_GET:
//  253     MT_UtilAPSME_LinkKeyDataGet(pBuf);
//  254     break;
//  255 
//  256   case MT_UTIL_APSME_LINK_KEY_NV_ID_GET:
//  257     MT_UtilAPSME_LinkKeyNvIdGet(pBuf);
//  258     break;
//  259 #endif // MT_SYS_KEY_MANAGEMENT
//  260 
//  261   case MT_UTIL_APSME_REQUEST_KEY_CMD:
//  262     MT_UtilAPSME_RequestKeyCmd(pBuf);
//  263     break;
//  264 
//  265   case MT_UTIL_ASSOC_COUNT:
//  266     MT_UtilAssocCount(pBuf);
//  267     break;
//  268 
//  269   case MT_UTIL_ASSOC_FIND_DEVICE:
//  270     MT_UtilAssocFindDevice(pBuf);
//  271     break;
//  272 
//  273   case MT_UTIL_ASSOC_GET_WITH_ADDRESS:
//  274     MT_UtilAssocGetWithAddress(pBuf);
//  275     break;
//  276 
//  277   case MT_UTIL_BIND_ADD_ENTRY:
//  278     MT_UtilBindAddEntry(pBuf);
//  279     break;
//  280 
//  281 #if defined ZCL_KEY_ESTABLISH
//  282   case MT_UTIL_ZCL_KEY_EST_INIT_EST:
//  283     MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment(pBuf);
//  284     break;
//  285 
//  286   case MT_UTIL_ZCL_KEY_EST_SIGN:
//  287     MT_UtilzclGeneral_KeyEstablishment_ECDSASign(pBuf);
//  288     break;
//  289 #endif
//  290 
//  291   case MT_UTIL_SYNC_REQ:
//  292     MT_UtilSync();
//  293     break;
//  294 #endif /* !defined NONWK */
//  295 
//  296 #ifdef MT_SRNG
//  297   case MT_UTIL_SRNG_GENERATE:
//  298     MT_UtilSrngGen();
//  299     break;
//  300 #endif
//  301 
//  302   default:
//  303     status = MT_RPC_ERR_COMMAND_ID;
//  304     break;
//  305   }
//  306 
//  307   return status;
//  308 }
//  309 
//  310 /***************************************************************************************************
//  311 * @fn      MT_UtilGetDeviceInfo
//  312 *
//  313 * @brief   The Get Device Info serial message.
//  314 *
//  315 * @param   None.
//  316 *
//  317 * @return  void
//  318 ***************************************************************************************************/
//  319 void MT_UtilGetDeviceInfo(void)
//  320 {
//  321   uint8  *buf;
//  322   uint8  *pBuf;
//  323   uint8  bufLen = MT_UTIL_DEVICE_INFO_RESPONSE_LEN;
//  324   uint16 *assocList = NULL;
//  325 
//  326 #if !defined NONWK
//  327   uint8  assocCnt = 0;
//  328 
//  329   if (ZG_DEVICE_RTR_TYPE)
//  330   {
//  331     assocList = AssocMakeList( &assocCnt );
//  332     bufLen += (assocCnt * sizeof(uint16));
//  333   }
//  334 #endif
//  335 
//  336   buf = osal_mem_alloc( bufLen );
//  337   if ( buf )
//  338   {
//  339     pBuf = buf;
//  340 
//  341     *pBuf++ = ZSUCCESS; // Status
//  342 
//  343     osal_nv_read( ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, pBuf );
//  344     pBuf += Z_EXTADDR_LEN;
//  345 
//  346 #if defined NONWK
//  347     // Skip past ZStack only parameters for NONWK
//  348     *pBuf++ = 0;
//  349     *pBuf++ = 0;
//  350     *pBuf++ = 0;
//  351     *pBuf++ = 0;
//  352     *pBuf = 0;
//  353 #else
//  354     {
//  355       uint16 shortAddr = NLME_GetShortAddr();
//  356       *pBuf++ = LO_UINT16( shortAddr );
//  357       *pBuf++ = HI_UINT16( shortAddr );
//  358     }
//  359 
//  360     /* Return device type */
//  361     *pBuf++ = ZSTACK_DEVICE_BUILD;
//  362 
//  363     /*Return device state */
//  364     *pBuf++ = (uint8)devState;
//  365 
//  366     if (ZG_DEVICE_RTR_TYPE)
//  367     {
//  368       *pBuf++ = assocCnt;
//  369 
//  370       if ( assocCnt )
//  371       {
//  372         uint8 x;
//  373         uint16 *puint16 = assocList;
//  374 
//  375         for ( x = 0; x < assocCnt; x++, puint16++ )
//  376         {
//  377           *pBuf++ = LO_UINT16( *puint16 );
//  378           *pBuf++ = HI_UINT16( *puint16 );
//  379         }
//  380       }
//  381     }
//  382     else
//  383     {
//  384       *pBuf++ = 0;
//  385     }
//  386 #endif
//  387 
//  388     MT_BuildAndSendZToolResponse( ((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
//  389                                  MT_UTIL_GET_DEVICE_INFO,
//  390                                  bufLen, buf );
//  391 
//  392     osal_mem_free( buf );
//  393   }
//  394 
//  395   if ( assocList )
//  396   {
//  397     osal_mem_free( assocList );
//  398   }
//  399 }
//  400 
//  401 #ifdef MT_SRNG
//  402 /***************************************************************************************************
//  403 * @fn      MT_UtilSrngGen
//  404 *
//  405 * @brief   Generate Secure Random Numbers
//  406 *
//  407 * @param   None.
//  408 *
//  409 * @return  void
//  410 ***************************************************************************************************/
//  411 void MT_UtilSrngGen(void)
//  412 {
//  413   static uint32 count = 125000; /* 125000 * 8 bits = 1000000 bits */
//  414   uint8 outrng[100];
//  415   uint8 status;
//  416 
//  417   if(count > 0)
//  418   {
//  419     status = ssp_srng_generate((uint8 *)outrng, 100, NULL);
//  420     if (status != SRNG_SUCCESS)
//  421     {
//  422       if(RNG_INIT_ERROR == status)
//  423       {
//  424         ssp_srng_reseed();
//  425       }
//  426       else
//  427       {
//  428         while(1)
//  429         {
//  430           ASM_NOP;
//  431         }
//  432       } /* if(RNG_INIT_ERROR == status) */
//  433     }/*if (status != SRNG_SUCCESS) */
//  434 
//  435     if(count >= 100)
//  436     {
//  437     count-=100;
//  438     }
//  439     else
//  440     {
//  441      count = 0;
//  442     }
//  443     MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ |
//  444                                  (uint8)MT_RPC_SYS_DBG),
//  445                                   MT_DEBUG_MSG,
//  446                                   100,
//  447                                   outrng);
//  448     osal_start_timerEx(MT_TaskID, MT_SRNG_EVENT, 100);
//  449   }
//  450 }
//  451 #endif
//  452 
//  453 /***************************************************************************************************
//  454  * @fn      MT_UtilGetNvInfo
//  455  *
//  456  * @brief   The Get NV Info serial message.
//  457  *
//  458  * @param   None.
//  459  *
//  460  * @return  void
//  461  ***************************************************************************************************/
//  462 void MT_UtilGetNvInfo(void)
//  463 {
//  464   uint8 len;
//  465   uint8 stat;
//  466   uint8 *buf;
//  467   uint8 *pBuf;
//  468   uint16 tmp16;
//  469   uint32 tmp32;
//  470 
//  471   /*
//  472     Get required length of buffer
//  473     Status + ExtAddr + ChanList + PanID  + SecLevel + PreCfgKey
//  474   */
//  475   len = 1 + Z_EXTADDR_LEN + 4 + 2 + 1 + SEC_KEY_LEN;
//  476 
//  477   buf = osal_mem_alloc( len );
//  478   if ( buf )
//  479   {
//  480     /* Assume NV not available */
//  481     osal_memset( buf, 0xFF, len );
//  482 
//  483     /* Skip over status */
//  484     pBuf = buf + 1;
//  485 
//  486     /* Start with 64-bit extended address */
//  487     stat = osal_nv_read( ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, pBuf );
//  488     if ( stat ) stat = 0x01;
//  489     pBuf += Z_EXTADDR_LEN;
//  490 
//  491     /* Scan channel list (bit mask) */
//  492     if (  osal_nv_read( ZCD_NV_CHANLIST, 0, sizeof( tmp32 ), &tmp32 ) )
//  493       stat |= 0x02;
//  494     else
//  495     {
//  496       pBuf[0] = BREAK_UINT32( tmp32, 3 );
//  497       pBuf[1] = BREAK_UINT32( tmp32, 2 );
//  498       pBuf[2] = BREAK_UINT32( tmp32, 1 );
//  499       pBuf[3] = BREAK_UINT32( tmp32, 0 );
//  500     }
//  501     pBuf += sizeof( tmp32 );
//  502 
//  503     /* ZigBee PanID */
//  504     if ( osal_nv_read( ZCD_NV_PANID, 0, sizeof( tmp16 ), &tmp16 ) )
//  505       stat |= 0x04;
//  506     else
//  507     {
//  508       pBuf[0] = LO_UINT16( tmp16 );
//  509       pBuf[1] = HI_UINT16( tmp16 );
//  510     }
//  511     pBuf += sizeof( tmp16 );
//  512 
//  513     /* Security level */
//  514     if ( osal_nv_read( ZCD_NV_SECURITY_LEVEL, 0, sizeof( uint8 ), pBuf++ ) )
//  515       stat |= 0x08;
//  516 
//  517     /* Pre-configured security key */
//  518     if ( osal_nv_read( ZCD_NV_PRECFGKEY, 0, SEC_KEY_LEN, pBuf ) )
//  519       stat |= 0x10;
//  520 
//  521     /* Status bit mask - bit=1 indicates failure */
//  522     *buf = stat;
//  523 
//  524     MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_GET_NV_INFO,
//  525                                   len, buf );
//  526 
//  527     osal_mem_free( buf );
//  528   }
//  529 }
//  530 
//  531 /***************************************************************************************************
//  532  * @fn      MT_UtilSetPanID
//  533  *
//  534  * @brief   Set PanID message
//  535  *
//  536  * @param   pBuf - pointer to the data
//  537  *
//  538  * @return  void
//  539  ***************************************************************************************************/
//  540 void MT_UtilSetPanID(uint8 *pBuf)
//  541 {
//  542   uint16 temp16;
//  543   uint8 retValue = ZFailure;
//  544   uint8 cmdId;
//  545 
//  546   /* parse header */
//  547   cmdId = pBuf[MT_RPC_POS_CMD1];
//  548   pBuf += MT_RPC_FRAME_HDR_SZ;
//  549 
//  550   temp16 = BUILD_UINT16(pBuf[0], pBuf[1]);
//  551   pBuf += sizeof(uint16);
//  552 
//  553   retValue = osal_nv_write(ZCD_NV_PANID, 0, osal_nv_item_len( ZCD_NV_PANID ), &temp16);
//  554 
//  555   /* Build and send back the response */
//  556   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue);
//  557 }
//  558 
//  559 /***************************************************************************************************
//  560  * @fn      MT_UtilSetChannels
//  561  *
//  562  * @brief   Set Channels
//  563  *
//  564  * @param   pBuf - pointer to the data
//  565  *
//  566  * @return  void
//  567  ***************************************************************************************************/
//  568 void MT_UtilSetChannels(uint8 *pBuf)
//  569 {
//  570   uint32 tmp32;
//  571   uint8 retValue = ZFailure;
//  572   uint8 cmdId;
//  573 
//  574   /* parse header */
//  575   cmdId = pBuf[MT_RPC_POS_CMD1];
//  576   pBuf += MT_RPC_FRAME_HDR_SZ;
//  577 
//  578   tmp32 = BUILD_UINT32(pBuf[0], pBuf[1], pBuf[2], pBuf[3]);
//  579 
//  580   retValue = osal_nv_write(ZCD_NV_CHANLIST, 0, osal_nv_item_len( ZCD_NV_CHANLIST ), &tmp32);
//  581 
//  582   /* Build and send back the response */
//  583   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue);
//  584 }
//  585 
//  586 /***************************************************************************************************
//  587  * @fn      MT_UtilSetSecLevel
//  588  *
//  589  * @brief   Set Sec Level
//  590  *
//  591  * @param   byte *msg - pointer to the data
//  592  *
//  593  * @return  void
//  594  ***************************************************************************************************/
//  595 void MT_UtilSetSecLevel(uint8 *pBuf)
//  596 {
//  597   uint8 retValue = ZFailure;
//  598   uint8 cmdId;
//  599 
//  600   /* parse header */
//  601   cmdId = pBuf[MT_RPC_POS_CMD1];
//  602   pBuf += MT_RPC_FRAME_HDR_SZ;
//  603 
//  604   retValue = osal_nv_write( ZCD_NV_SECURITY_LEVEL, 0, osal_nv_item_len( ZCD_NV_SECURITY_LEVEL ), pBuf);
//  605 
//  606   /* Build and send back the response */
//  607   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  608 
//  609 }
//  610 
//  611 /***************************************************************************************************
//  612  * @fn      MT_UtilSetPreCfgKey
//  613  *
//  614  * @brief   Set Pre Cfg Key
//  615  *
//  616  * @param   pBuf - pointer to the data
//  617  *
//  618  * @return  void
//  619  ***************************************************************************************************/
//  620 void MT_UtilSetPreCfgKey(uint8 *pBuf)
//  621 {
//  622   uint8 retValue = ZFailure;
//  623   uint8 cmdId;
//  624 
//  625   /* parse header */
//  626   cmdId = pBuf[MT_RPC_POS_CMD1];
//  627   pBuf += MT_RPC_FRAME_HDR_SZ;
//  628 
//  629   retValue = osal_nv_write( ZCD_NV_PRECFGKEY, 0, osal_nv_item_len( ZCD_NV_PRECFGKEY ), pBuf);
//  630 
//  631   /* Build and send back the response */
//  632   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  633 
//  634 }
//  635 
//  636 /***************************************************************************************************
//  637  * @fn      MT_UtilCallbackSub
//  638  *
//  639  * @brief   The Callback subscribe.
//  640  *
//  641  * @param   pBuf - pointer to the data
//  642  *
//  643  * @return  void
//  644  ***************************************************************************************************/
//  645 void MT_UtilCallbackSub(uint8 *pBuf)
//  646 {
//  647   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
//  648   uint8 retValue = ZFailure;
//  649 
//  650 #if defined(MT_MAC_CB_FUNC) || defined(MT_NWK_CB_FUNC) || defined(MT_ZDO_CB_FUNC) || defined(MT_AF_CB_FUNC) || defined(MT_SAPI_CB_FUNC)
//  651   uint8 subSystem;
//  652   uint16 subscribed_command;
//  653 
//  654   // Move past header
//  655   retValue = ZSuccess;
//  656   pBuf += MT_RPC_FRAME_HDR_SZ;
//  657 
//  658   /* Command */
//  659   subscribed_command = BUILD_UINT16(pBuf[0], pBuf[1]);
//  660   pBuf += 2;
//  661 
//  662   /* Subsystem - 5 bits on the MSB of the command */
//  663   subSystem = HI_UINT16(subscribed_command) & 0x1F ;
//  664 
//  665   /* What is the action - SUBSCRIBE or !SUBSCRIBE */
//  666   if (*pBuf)
//  667   {
//  668     /* Turn ON */
//  669   #if defined( MT_MAC_CB_FUNC )
//  670     if ((subSystem == MT_RPC_SYS_MAC) || (subscribed_command == 0xFFFF))
//  671       _macCallbackSub = 0xFFFF;
//  672   #endif
//  673 
//  674   #if defined( MT_NWK_CB_FUNC )
//  675     if ((subSystem == MT_RPC_SYS_NWK) || (subscribed_command == 0xFFFF))
//  676       _nwkCallbackSub = 0xFFFF;
//  677   #endif
//  678 
//  679   #if defined( MT_ZDO_CB_FUNC )
//  680     if ((subSystem == MT_RPC_SYS_ZDO) || (subscribed_command == 0xFFFF))
//  681       _zdoCallbackSub = 0xFFFFFFFF;
//  682   #endif
//  683 
//  684   #if defined( MT_AF_CB_FUNC )
//  685     if ((subSystem == MT_RPC_SYS_AF) || (subscribed_command == 0xFFFF))
//  686       _afCallbackSub = 0xFFFF;
//  687   #endif
//  688 
//  689   #if defined( MT_SAPI_CB_FUNC )
//  690     if ((subSystem == MT_RPC_SYS_SAPI) || (subscribed_command == 0xFFFF))
//  691       _sapiCallbackSub = 0xFFFF;
//  692   #endif
//  693   }
//  694   else
//  695   {
//  696     /* Turn OFF */
//  697   #if defined( MT_MAC_CB_FUNC )
//  698     if ((subSystem == MT_RPC_SYS_MAC) || (subscribed_command == 0xFFFF))
//  699       _macCallbackSub = 0x0000;
//  700   #endif
//  701 
//  702   #if defined( MT_NWK_CB_FUNC )
//  703     if ((subSystem == MT_RPC_SYS_NWK) || (subscribed_command == 0xFFFF))
//  704       _nwkCallbackSub = 0x0000;
//  705   #endif
//  706 
//  707   #if defined( MT_ZDO_CB_FUNC )
//  708     if ((subSystem == MT_RPC_SYS_ZDO) || (subscribed_command == 0xFFFF))
//  709       _zdoCallbackSub = 0x00000000;
//  710   #endif
//  711 
//  712   #if defined( MT_AF_CB_FUNC )
//  713     if ((subSystem == MT_RPC_SYS_AF) || (subscribed_command == 0xFFFF))
//  714       _afCallbackSub = 0x0000;
//  715   #endif
//  716 
//  717   #if defined( MT_SAPI_CB_FUNC )
//  718     if ((subSystem == MT_RPC_SYS_SAPI) || (subscribed_command == 0xFFFF))
//  719         _sapiCallbackSub = 0x0000;
//  720   #endif
//  721   }
//  722 #endif  // MT_MAC_CB_FUNC || MT_NWK_CB_FUNC || MT_ZDO_CB_FUNC || MT_AF_CB_FUNC || MT_SAPI_CB_FUNC || MT_SAPI_CB_FUNC
//  723 
//  724   /* Build and send back the response */
//  725   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  726 }
//  727 
//  728 #if (defined HAL_KEY) && (HAL_KEY == TRUE)
//  729 /***************************************************************************************************
//  730  * @fn      MT_UtilKeyEvent
//  731  *
//  732  * @brief   Process Key Event
//  733  *
//  734  * @param   pBuf - pointer to the data
//  735  *
//  736  * @return  void
//  737  ***************************************************************************************************/
//  738 void MT_UtilKeyEvent(uint8 *pBuf)
//  739 {
//  740   uint8 x = 0;
//  741   uint8 retValue = ZFailure;
//  742   uint8 cmdId;
//  743 
//  744   /* parse header */
//  745   cmdId = pBuf[MT_RPC_POS_CMD1];
//  746   pBuf += MT_RPC_FRAME_HDR_SZ;
//  747 
//  748   /* Translate between SPI values to device values */
//  749   if ( *pBuf & 0x01 )
//  750     x |= HAL_KEY_SW_1;
//  751   if ( *pBuf & 0x02 )
//  752     x |= HAL_KEY_SW_2;
//  753   if ( *pBuf & 0x04 )
//  754     x |= HAL_KEY_SW_3;
//  755   if ( *pBuf & 0x08 )
//  756   x |= HAL_KEY_SW_4;
//  757 #if defined ( HAL_KEY_SW_5 )
//  758   if ( *pBuf & 0x10 )
//  759     x |= HAL_KEY_SW_5;
//  760 #endif
//  761 #if defined ( HAL_KEY_SW_6 )
//  762   if ( *pBuf & 0x20 )
//  763     x |= HAL_KEY_SW_6;
//  764 #endif
//  765 #if defined ( HAL_KEY_SW_7 )
//  766   if ( *pBuf & 0x40 )
//  767     x |= HAL_KEY_SW_7;
//  768 #endif
//  769 #if defined ( HAL_KEY_SW_8 )
//  770   if ( *pBuf & 0x80 )
//  771     x |= HAL_KEY_SW_8;
//  772 #endif
//  773   pBuf++;
//  774 
//  775   retValue = OnBoard_SendKeys(x, *pBuf);
//  776 
//  777   /* Build and send back the response */
//  778   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  779 }
//  780 #endif
//  781 
//  782 /***************************************************************************************************
//  783  * @fn      MT_UtilTimeAlive
//  784  *
//  785  * @brief   Process Time Alive
//  786  *
//  787  * @param   None.
//  788  *
//  789  * @return  None
//  790  ***************************************************************************************************/
//  791 void MT_UtilTimeAlive(void)
//  792 {
//  793   uint8 timeAlive[4];
//  794   uint32 tmp32;
//  795 
//  796   /* Time since last reset (seconds) */
//  797   tmp32 = osal_GetSystemClock() / 1000;
//  798 
//  799   /* Convert to high byte first into temp buffer */
//  800   timeAlive[0] = BREAK_UINT32(tmp32, 0);
//  801   timeAlive[1] = BREAK_UINT32(tmp32, 1);
//  802   timeAlive[2] = BREAK_UINT32(tmp32, 2);
//  803   timeAlive[3] = BREAK_UINT32(tmp32, 3);
//  804 
//  805   /* Build and send back the response */
//  806   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
//  807                                        MT_UTIL_TIME_ALIVE, sizeof(timeAlive), timeAlive);
//  808 }
//  809 
//  810 #if (defined HAL_LED) && (HAL_LED == TRUE)
//  811 /***************************************************************************************************
//  812  * @fn      MT_UtilLedControl
//  813  *
//  814  * @brief   Process the LED Control Message
//  815  *
//  816  * @param   pBuf - pointer to the received data
//  817  *
//  818  * @return  None
//  819  ***************************************************************************************************/
//  820 void MT_UtilLedControl(uint8 *pBuf)
//  821 {
//  822   uint8 iLed, Led, iMode, Mode, cmdId;
//  823   uint8 retValue = ZFailure;
//  824 
//  825   /* parse header */
//  826   cmdId = pBuf[MT_RPC_POS_CMD1];
//  827   pBuf += MT_RPC_FRAME_HDR_SZ;
//  828 
//  829   /* LED and Mode */
//  830   iLed = *pBuf++;
//  831   iMode = *pBuf;
//  832 
//  833   if ( iLed == 1 )
//  834     Led = HAL_LED_1;
//  835   else if ( iLed == 2 )
//  836     Led = HAL_LED_2;
//  837   else if ( iLed == 3 )
//  838     Led = HAL_LED_3;
//  839   else if ( iLed == 4 )
//  840     Led = HAL_LED_4;
//  841   else if ( iLed == 0xFF )
//  842     Led = HAL_LED_ALL;
//  843   else
//  844     Led = 0;
//  845 
//  846   if ( iMode == 0 )
//  847     Mode = HAL_LED_MODE_OFF;
//  848   else if ( iMode == 1 )
//  849     Mode = HAL_LED_MODE_ON;
//  850   else if ( iMode == 2 )
//  851     Mode = HAL_LED_MODE_BLINK;
//  852   else if ( iMode == 3 )
//  853     Mode = HAL_LED_MODE_FLASH;
//  854   else if ( iMode == 4 )
//  855     Mode = HAL_LED_MODE_TOGGLE;
//  856   else
//  857     Led = 0;
//  858 
//  859   if ( Led != 0 )
//  860   {
//  861     HalLedSet (Led, Mode);
//  862     retValue = ZSuccess;
//  863   }
//  864 
//  865   /* Build and send back the response */
//  866   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  867 }
//  868 #endif /* HAL_LED */
//  869 
//  870 
//  871 /***************************************************************************************************
//  872  * @fn          MT_UtilSrcMatchEnable
//  873  *
//  874  * @brief      Enabled AUTOPEND and source address matching.
//  875  *
//  876  * @param      pBuf - Buffer contains the data
//  877  *
//  878  * @return     void
//  879  ***************************************************************************************************/
//  880 void MT_UtilSrcMatchEnable (uint8 *pBuf)
//  881 {
//  882   uint8 retValue, cmdId;
//  883 
//  884   /* Parse header */
//  885   cmdId = pBuf[MT_RPC_POS_CMD1];
//  886   pBuf += MT_RPC_FRAME_HDR_SZ;
//  887 
//  888 #ifdef AUTO_PEND
//  889   /* Call the routine */
//  890   retValue = ZMacSrcMatchEnable();
//  891 #else
//  892   retValue = ZMacUnsupported;
//  893 #endif
//  894 
//  895   /* Build and send back the response */
//  896   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  897 
//  898 }
//  899 
//  900 /***************************************************************************************************
//  901  * @fn          MT_UtilSrcMatchAddEntry
//  902  *
//  903  * @brief       Add a short or extended address to source address table.
//  904  *
//  905  * @param       pBuf - Buffer contains the data
//  906  *
//  907  * @return      void
//  908  ***************************************************************************************************/
//  909 void MT_UtilSrcMatchAddEntry (uint8 *pBuf)
//  910 {
//  911   uint8 retValue, cmdId;
//  912 
//  913   /* Parse header */
//  914   cmdId = pBuf[MT_RPC_POS_CMD1];
//  915   pBuf += MT_RPC_FRAME_HDR_SZ;
//  916 
//  917 #ifdef AUTO_PEND
//  918   uint16 panID;
//  919   zAddrType_t devAddr;
//  920 
//  921   /* Address mode */
//  922   devAddr.addrMode = *pBuf++;
//  923 
//  924   /* Address based on the address mode */
//  925   MT_UtilSpi2Addr( &devAddr, pBuf);
//  926   pBuf += Z_EXTADDR_LEN;
//  927 
//  928   /* PanID */
//  929   panID = BUILD_UINT16( pBuf[0] , pBuf[1] );
//  930 
//  931   /* Call the routine */
//  932   retValue =  ZMacSrcMatchAddEntry (&devAddr, panID);
//  933 #else
//  934   retValue = ZMacUnsupported;
//  935 #endif
//  936 
//  937   /* Build and send back the response */
//  938   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  939 }
//  940 
//  941 /***************************************************************************************************
//  942  * @fn          MT_UtilSrcMatchDeleteEntry
//  943  *
//  944  * @brief      Delete a short or extended address from source address table.
//  945  *
//  946  * @param      pBuf - Buffer contains the data
//  947  *
//  948  * @return     void
//  949  ***************************************************************************************************/
//  950 void MT_UtilSrcMatchDeleteEntry (uint8 *pBuf)
//  951 {
//  952   uint8 retValue, cmdId;
//  953 
//  954   /* Parse header */
//  955   cmdId = pBuf[MT_RPC_POS_CMD1];
//  956   pBuf += MT_RPC_FRAME_HDR_SZ;
//  957 
//  958 #ifdef AUTO_PEND
//  959   uint16 panID;
//  960   zAddrType_t devAddr;
//  961 
//  962   /* Address mode */
//  963   devAddr.addrMode = *pBuf++;
//  964 
//  965   /* Address based on the address mode */
//  966   MT_UtilSpi2Addr( &devAddr, pBuf);
//  967   pBuf += Z_EXTADDR_LEN;
//  968 
//  969   /* PanID */
//  970   panID = BUILD_UINT16( pBuf[0] , pBuf[1] );
//  971 
//  972   /* Call the routine */
//  973   retValue =  ZMacSrcMatchDeleteEntry (&devAddr, panID);
//  974 #else
//  975   retValue = ZMacUnsupported;
//  976 #endif
//  977 
//  978   /* Build and send back the response */
//  979   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  980 }
//  981 
//  982 /***************************************************************************************************
//  983  * @fn          MT_UtilSrcMatchCheckSrcAddr
//  984  *
//  985  * @brief      Check if a short or extended address is in the source address table.
//  986  *
//  987  * @param      pBuf - Buffer contains the data
//  988  *
//  989  * @return     void
//  990  ***************************************************************************************************/
//  991 void MT_UtilSrcMatchCheckSrcAddr (uint8 *pBuf)
//  992 {
//  993   uint8 cmdId;
//  994   uint8 retArray[2];
//  995 
//  996   /* Parse header */
//  997   cmdId = pBuf[MT_RPC_POS_CMD1];
//  998   pBuf += MT_RPC_FRAME_HDR_SZ;
//  999 
// 1000 #if 0  /* Unsupported  */
// 1001   uint16 panID;
// 1002   zAddrType_t devAddr;
// 1003 
// 1004   /* Address mode */
// 1005   devAddr.addrMode = *pBuf++;
// 1006 
// 1007   /* Address based on the address mode */
// 1008   MT_UtilSpi2Addr( &devAddr, pBuf);
// 1009   pBuf += Z_EXTADDR_LEN;
// 1010 
// 1011   /* PanID */
// 1012   panID = BUILD_UINT16( pBuf[0] , pBuf[1] );
// 1013 
// 1014   /* Call the routine */
// 1015   retArray[1] =  ZMacSrcMatchCheckSrcAddr (&devAddr, panID);
// 1016 
// 1017     /* Return failure if the index is invalid */
// 1018   if (retArray[1] == ZMacSrcMatchInvalidIndex )
// 1019   {
// 1020     retArray[0] = ZFailure;
// 1021   }
// 1022   else
// 1023   {
// 1024     retArray[0] = ZSuccess;
// 1025   }
// 1026 #else
// 1027   retArray[0] = ZMacUnsupported;
// 1028   retArray[1] = ZMacSrcMatchInvalidIndex;
// 1029 #endif
// 1030 
// 1031   /* Build and send back the response */
// 1032   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 2, retArray );
// 1033 }
// 1034 
// 1035 /***************************************************************************************************
// 1036  * @fn          MT_UtilSrcMatchAckAllPending
// 1037  *
// 1038  * @brief       Enabled/disable acknowledging all packets with pending bit set
// 1039  *              It is normally enabled when adding new entries to
// 1040  *              the source address table fails due to the table is full, or
// 1041  *              disabled when more entries are deleted and the table has
// 1042  *              empty slots.
// 1043  *
// 1044  * @param       pBuf - Buffer contains the data
// 1045  *
// 1046  * @return      void
// 1047  ***************************************************************************************************/
// 1048 void MT_UtilSrcMatchAckAllPending (uint8 *pBuf)
// 1049 {
// 1050   uint8 retValue, cmdId;
// 1051 
// 1052   /* Parse header */
// 1053   cmdId = pBuf[MT_RPC_POS_CMD1];
// 1054   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1055 
// 1056 #ifdef AUTO_PEND
// 1057   /* Call the routine */
// 1058   retValue = ZMacSrcMatchAckAllPending(*pBuf);
// 1059 #else
// 1060   retValue = ZMacUnsupported;
// 1061 #endif
// 1062 
// 1063   /* Build and send back the response */
// 1064   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
// 1065 }
// 1066 
// 1067 /***************************************************************************************************
// 1068  * @fn          MT_UtilSrcMatchCheckAllPending
// 1069  *
// 1070  * @brief       Check if acknowledging all packets with pending bit set
// 1071  *              is enabled.
// 1072  *
// 1073  * @param       pBuf - Buffer contains the data
// 1074  *
// 1075  * @return      void
// 1076  ***************************************************************************************************/
// 1077 void MT_UtilSrcMatchCheckAllPending (uint8 *pBuf)
// 1078 {
// 1079   uint8 retArray[2], cmdId;
// 1080 
// 1081   /* Parse header */
// 1082   cmdId = pBuf[MT_RPC_POS_CMD1];
// 1083   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1084 
// 1085 #ifdef AUTO_PEND
// 1086   /* Call the routine */
// 1087   retArray[0] = ZMacSuccess;
// 1088   retArray[1] = ZMacSrcMatchCheckAllPending();
// 1089 #else
// 1090   retArray[0] = ZMacUnsupported;
// 1091   retArray[1] = FALSE;
// 1092 #endif
// 1093 
// 1094   /* Build and send back the response */
// 1095   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 2, retArray );
// 1096 }
// 1097 
// 1098 /***************************************************************************************************
// 1099  * SUPPORT
// 1100  ***************************************************************************************************/
// 1101 
// 1102 #ifdef AUTO_PEND
// 1103 /***************************************************************************************************
// 1104  * @fn      MT_UtilRevExtCpy
// 1105  *
// 1106  * @brief
// 1107  *
// 1108  *   Reverse-copy an extended address.
// 1109  *
// 1110  * @param   pDst - Pointer to data destination
// 1111  * @param   pSrc - Pointer to data source
// 1112  *
// 1113  * @return  void
// 1114  ***************************************************************************************************/
// 1115 static void MT_UtilRevExtCpy( uint8 *pDst, uint8 *pSrc )
// 1116 {
// 1117   int8 i;
// 1118 
// 1119   for ( i = Z_EXTADDR_LEN - 1; i >= 0; i-- )
// 1120   {
// 1121     *pDst++ = pSrc[i];
// 1122   }
// 1123 }
// 1124 
// 1125 /***************************************************************************************************
// 1126  * @fn      MT_UtilSpi2Addr
// 1127  *
// 1128  * @brief   Copy an address from an SPI message to an address struct.  The
// 1129  *          addrMode in pAddr must already be set.
// 1130  *
// 1131  * @param   pDst - Pointer to address struct
// 1132  * @param   pSrc - Pointer SPI message byte array
// 1133  *
// 1134  * @return  void
// 1135  ***************************************************************************************************/
// 1136 static void MT_UtilSpi2Addr( zAddrType_t *pDst, uint8 *pSrc )
// 1137 {
// 1138   if ( pDst->addrMode == Addr16Bit )
// 1139   {
// 1140     pDst->addr.shortAddr = BUILD_UINT16( pSrc[0] , pSrc[1] );
// 1141   }
// 1142   else if ( pDst->addrMode == Addr64Bit )
// 1143   {
// 1144     MT_UtilRevExtCpy( pDst->addr.extAddr, pSrc );
// 1145   }
// 1146 }
// 1147 #endif // AUTO_PEND
// 1148 
// 1149 #if !defined NONWK
// 1150 /**************************************************************************************************
// 1151  * @fn      MT_UtilDataReq
// 1152  *
// 1153  * @brief   Process the MAC Data Request command.
// 1154  *
// 1155  * @param   pBuf - pointer to the received data
// 1156  *
// 1157  * @return  None
// 1158 **************************************************************************************************/
// 1159 void MT_UtilDataReq(uint8 *pBuf)
// 1160 {
// 1161   uint8 rtrn = NwkPollReq(pBuf[MT_RPC_POS_DAT0]);
// 1162   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_DATA_REQ,
// 1163                                                                                1, &rtrn);
// 1164 }
// 1165 
// 1166 /***************************************************************************************************
// 1167  * @fn      MT_UtilAddrMgrEntryLookupExt
// 1168  *
// 1169  * @brief   Proxy the AddrMgrEntryLookupExt() function.
// 1170  *
// 1171  * @param   pBuf - pointer to the received buffer
// 1172  *
// 1173  * @return  void
// 1174  ***************************************************************************************************/
// 1175 static void MT_UtilAddrMgrEntryLookupExt(uint8 *pBuf)
// 1176 {
// 1177   uint8 nwkAddr[2];
// 1178   AddrMgrEntry_t entry;
// 1179   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1180   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1181 
// 1182   osal_memcpy(entry.extAddr, pBuf, Z_EXTADDR_LEN);
// 1183   (void)AddrMgrEntryLookupExt(&entry);
// 1184 
// 1185   nwkAddr[0] = LO_UINT16(entry.nwkAddr);
// 1186   nwkAddr[1] = HI_UINT16(entry.nwkAddr);
// 1187   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
// 1188                                        cmdId, sizeof(uint16), nwkAddr);
// 1189 }
// 1190 
// 1191 /***************************************************************************************************
// 1192  * @fn      MT_UtilAddrMgrEntryLookupNwk
// 1193  *
// 1194  * @brief   Proxy the AddrMgrEntryLookupNwk() function.
// 1195  *
// 1196  * @param   pBuf - pointer to the received buffer
// 1197  *
// 1198  * @return  void
// 1199  ***************************************************************************************************/
// 1200 static void MT_UtilAddrMgrEntryLookupNwk(uint8 *pBuf)
// 1201 {
// 1202   AddrMgrEntry_t entry;
// 1203   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1204   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1205 
// 1206   entry.nwkAddr = BUILD_UINT16(pBuf[0], pBuf[1]);
// 1207   (void)AddrMgrEntryLookupNwk(&entry);
// 1208 
// 1209   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
// 1210                                        cmdId, Z_EXTADDR_LEN, entry.extAddr);
// 1211 }
// 1212 
// 1213 #if defined MT_SYS_KEY_MANAGEMENT
// 1214 /***************************************************************************************************
// 1215  * @fn      MT_UtilAPSME_LinkKeyDataGet
// 1216  *
// 1217  * @brief   Retrieves APS Link Key data from NV.
// 1218  *
// 1219  * @param   pBuf - pointer to the received buffer
// 1220  *
// 1221  * @return  void
// 1222  ***************************************************************************************************/
// 1223 static void MT_UtilAPSME_LinkKeyDataGet(uint8 *pBuf)
// 1224 {
// 1225   uint8 rsp[MT_APSME_LINKKEY_GET_RSP_LEN];
// 1226   APSME_LinkKeyData_t *pData = NULL;
// 1227   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1228   uint16 apsLinkKeyNvId;
// 1229   uint32 *apsRxFrmCntr;
// 1230   uint32 *apsTxFrmCntr;
// 1231 
// 1232   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1233 
// 1234   *rsp = APSME_LinkKeyNVIdGet(pBuf, &apsLinkKeyNvId);
// 1235 
// 1236   if (SUCCESS == *rsp)
// 1237   {
// 1238     pData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
// 1239 
// 1240     if (pData != NULL)
// 1241     {
// 1242       // retrieve key from NV
// 1243       if ( osal_nv_read( apsLinkKeyNvId, 0,
// 1244                         sizeof(APSME_LinkKeyData_t), pData) == SUCCESS)
// 1245 
// 1246       {
// 1247         uint8 *ptr = rsp+1;
// 1248         apsRxFrmCntr = &ApsLinkKeyFrmCntr[apsLinkKeyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr;
// 1249         apsTxFrmCntr = &ApsLinkKeyFrmCntr[apsLinkKeyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr;
// 1250 
// 1251         (void)osal_memcpy(ptr, pData->key, SEC_KEY_LEN);
// 1252         ptr += SEC_KEY_LEN;
// 1253         *ptr++ = BREAK_UINT32(*apsTxFrmCntr, 0);
// 1254         *ptr++ = BREAK_UINT32(*apsTxFrmCntr, 1);
// 1255         *ptr++ = BREAK_UINT32(*apsTxFrmCntr, 2);
// 1256         *ptr++ = BREAK_UINT32(*apsTxFrmCntr, 3);
// 1257         *ptr++ = BREAK_UINT32(*apsRxFrmCntr, 0);
// 1258         *ptr++ = BREAK_UINT32(*apsRxFrmCntr, 1);
// 1259         *ptr++ = BREAK_UINT32(*apsRxFrmCntr, 2);
// 1260         *ptr++ = BREAK_UINT32(*apsRxFrmCntr, 3);
// 1261       }
// 1262 
// 1263       // clear copy of key in RAM
// 1264       osal_memset( pData, 0x00, sizeof(APSME_LinkKeyData_t) );
// 1265 
// 1266       osal_mem_free(pData);
// 1267     }
// 1268   }
// 1269   else
// 1270   {
// 1271     // set data key and counters 0xFF
// 1272     osal_memset(&rsp[1], 0xFF, SEC_KEY_LEN + (MT_UTIL_FRM_CTR_LEN * 2));
// 1273   }
// 1274 
// 1275   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1276                                        MT_APSME_LINKKEY_GET_RSP_LEN, rsp);
// 1277 
// 1278   // clear key data
// 1279   osal_memset(rsp, 0x00, MT_APSME_LINKKEY_GET_RSP_LEN);
// 1280 
// 1281 }
// 1282 
// 1283 /***************************************************************************************************
// 1284  * @fn      MT_UtilAPSME_LinkKeyNvIdGet
// 1285  *
// 1286  * @brief   Retrieves APS Link Key NV ID from the entry table.
// 1287  *
// 1288  * @param   pBuf - pointer to the received buffer
// 1289  *
// 1290  * @return  void
// 1291  ***************************************************************************************************/
// 1292 static void MT_UtilAPSME_LinkKeyNvIdGet(uint8 *pBuf)
// 1293 {
// 1294   uint8 rsp[MT_APSME_LINKKEY_NV_ID_GET_RSP_LEN];
// 1295   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1296   uint16 apsLinkKeyNvId;
// 1297 
// 1298   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1299 
// 1300   *rsp = APSME_LinkKeyNVIdGet(pBuf, &apsLinkKeyNvId);
// 1301 
// 1302   if (SUCCESS == *rsp)
// 1303   {
// 1304     rsp[1] = LO_UINT16(apsLinkKeyNvId);
// 1305     rsp[2] = HI_UINT16(apsLinkKeyNvId);
// 1306   }
// 1307   else
// 1308   {
// 1309     // send failure response with invalid NV ID
// 1310     osal_memset(&rsp[1], 0xFF, 2);
// 1311   }
// 1312 
// 1313   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1314                                        MT_APSME_LINKKEY_NV_ID_GET_RSP_LEN, rsp);
// 1315 }
// 1316 #endif // MT_SYS_KEY_MANAGEMENT
// 1317 
// 1318 /***************************************************************************************************
// 1319  * @fn      MT_UtilAPSME_RequestKeyCmd
// 1320  *
// 1321  * @brief   Send RequestKey command message to TC for a specific partner Address.
// 1322  *
// 1323  * @param   pBuf  - pointer to the received buffer
// 1324  *
// 1325  * @return  void
// 1326  ***************************************************************************************************/
// 1327 void MT_UtilAPSME_RequestKeyCmd(uint8 *pBuf)
// 1328 {
// 1329   uint8 cmdId;
// 1330   uint8 partnerAddr[Z_EXTADDR_LEN];
// 1331   uint8 retValue;
// 1332 
// 1333   // parse header
// 1334   cmdId = pBuf[MT_RPC_POS_CMD1];
// 1335   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1336 
// 1337   /* PartnerAddress */
// 1338   osal_memcpy(partnerAddr, pBuf, Z_EXTADDR_LEN);
// 1339 
// 1340   retValue = (uint8)ZDSecMgrRequestAppKey(partnerAddr);
// 1341 
// 1342   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue);
// 1343 }
// 1344 
// 1345 /***************************************************************************************************
// 1346  * @fn      MT_UtilAssocCount
// 1347  *
// 1348  * @brief   Proxy the AssocCount() function.
// 1349  *
// 1350  * @param   pBuf - pointer to the received buffer
// 1351  *
// 1352  * @return  void
// 1353  ***************************************************************************************************/
// 1354 static void MT_UtilAssocCount(uint8 *pBuf)
// 1355 {
// 1356   uint16 cnt;
// 1357   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1358   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1359 
// 1360   cnt = AssocCount(pBuf[0], pBuf[1]);
// 1361   pBuf[0] = LO_UINT16(cnt);
// 1362   pBuf[1] = HI_UINT16(cnt);
// 1363 
// 1364   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 2, pBuf);
// 1365 }
// 1366 
// 1367 /***************************************************************************************************
// 1368  * @fn      MT_UtilAssocFindDevice
// 1369  *
// 1370  * @brief   Get an associated device by index.
// 1371  *
// 1372  * @param   pBuf - pointer to the received buffer
// 1373  *
// 1374  * @return  void
// 1375  ***************************************************************************************************/
// 1376 static void MT_UtilAssocFindDevice(uint8 *pBuf)
// 1377 {
// 1378   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1379   uint8 buf[sizeof(associated_devices_t)];
// 1380 
// 1381   packDev_t(buf, AssocFindDevice(pBuf[MT_RPC_FRAME_HDR_SZ]));
// 1382   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1383                                        sizeof(associated_devices_t), buf);
// 1384 }
// 1385 
// 1386 /***************************************************************************************************
// 1387  * @fn      MT_UtilAssocGetWithAddress
// 1388  *
// 1389  * @brief   Get an associated device by address.
// 1390  *
// 1391  * @param   pBuf - pointer to the received buffer
// 1392  *
// 1393  * @return  void
// 1394  ***************************************************************************************************/
// 1395 static void MT_UtilAssocGetWithAddress(uint8 *pBuf)
// 1396 {
// 1397   extern associated_devices_t *AssocGetWithAddress(uint8 *extAddr, uint16 shortAddr);
// 1398   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1399   uint8 buf[sizeof(associated_devices_t)];
// 1400 
// 1401   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1402   packDev_t(buf, AssocGetWithAddress(((AddrMgrExtAddrValid(pBuf)) ? pBuf : NULL),
// 1403                                   BUILD_UINT16(pBuf[Z_EXTADDR_LEN], pBuf[Z_EXTADDR_LEN+1])));
// 1404 
// 1405   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1406                                        sizeof(associated_devices_t), buf);
// 1407 }
// 1408 
// 1409 /***************************************************************************************************
// 1410  * @fn      MT_UtilBindAddEntry
// 1411  *
// 1412  * @brief   Add Binding Entry into Local Table.
// 1413  *
// 1414  * @param   pBuf - pointer to the received buffer
// 1415  *
// 1416  * @return  void
// 1417  ***************************************************************************************************/
// 1418 static void MT_UtilBindAddEntry(uint8 *pBuf)
// 1419 {
// 1420   uint8 srcEp;
// 1421   zAddrType_t dstAddr;
// 1422   uint8 dstEp;
// 1423   uint8 numClusterIds;
// 1424   uint16 *clusterIds;
// 1425   uint8 buf[sizeof(BindingEntry_t)];
// 1426   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1427   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1428 
// 1429   // Initialize the return buffer
// 1430   osal_memset( buf, 0xFF, sizeof(BindingEntry_t) );
// 1431   buf[2] = 0xFE;    // set the default value of INVALID_NODE_ADDR
// 1432   buf[3] = 0xFF;    // set the default value of INVALID_NODE_ADDR
// 1433 
// 1434   srcEp = *pBuf++;
// 1435 
// 1436   // Destination Address mode
// 1437   dstAddr.addrMode = *pBuf++;
// 1438 
// 1439   // Destination Address
// 1440   if ( dstAddr.addrMode == Addr64Bit )
// 1441   {
// 1442     uint8 *ptr; // Use this additional pointer because *pBuf is incremented later for both cases
// 1443 
// 1444     ptr = pBuf;
// 1445     osal_cpyExtAddr( dstAddr.addr.extAddr, ptr );
// 1446   }
// 1447   else
// 1448   {
// 1449     dstAddr.addr.shortAddr = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1450   }
// 1451   // The short address occupies LSB two bytes
// 1452   pBuf += Z_EXTADDR_LEN;
// 1453 
// 1454   // DstEPInt
// 1455   dstEp = *pBuf++;
// 1456 
// 1457   numClusterIds = *pBuf++;
// 1458 
// 1459   if ( numClusterIds > 0 )
// 1460   {
// 1461     // copy list of clusters
// 1462     clusterIds = (uint16 *)osal_mem_alloc( numClusterIds * sizeof(uint16) );
// 1463     osal_memcpy( clusterIds, pBuf, numClusterIds * sizeof(uint16));
// 1464 
// 1465     if ( clusterIds != NULL )
// 1466     {
// 1467       // The response to MT interface has to be pack into buf
// 1468       packBindEntry_t( buf, bindAddEntry( srcEp, &dstAddr, dstEp, numClusterIds, clusterIds ));
// 1469 
// 1470       osal_mem_free( clusterIds );
// 1471     }
// 1472   }
// 1473 
// 1474   MT_BuildAndSendZToolResponse( ( (uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL ),
// 1475                                 cmdId, sizeof(BindingEntry_t), buf );
// 1476 }
// 1477 
// 1478 /***************************************************************************************************
// 1479  * @fn      packDev_t
// 1480  *
// 1481  * @brief   Pack an associated_devices_t structure into a byte buffer (pack INVALID_NODE_ADDR if
// 1482  *          the pDev parameter is NULL).
// 1483  *
// 1484  * @param   pBuf - pointer to the buffer into which to pack the structure.
// 1485  * @param   pDev - pointer to the structure.
// 1486  *
// 1487  * @return  void
// 1488  ***************************************************************************************************/
// 1489 static void packDev_t(uint8 *pBuf, associated_devices_t *pDev)
// 1490 {
// 1491   if (NULL == pDev)
// 1492   {
// 1493     uint16 rtrn = INVALID_NODE_ADDR;
// 1494     *pBuf++ = LO_UINT16(rtrn);
// 1495     *pBuf++ = HI_UINT16(rtrn);
// 1496   }
// 1497   else
// 1498   {
// 1499     *pBuf++ = LO_UINT16(pDev->shortAddr);
// 1500     *pBuf++ = HI_UINT16(pDev->shortAddr);
// 1501     *pBuf++ = LO_UINT16(pDev->addrIdx);
// 1502     *pBuf++ = HI_UINT16(pDev->addrIdx);
// 1503     *pBuf++ = pDev->nodeRelation;
// 1504     *pBuf++ = pDev->devStatus;
// 1505     *pBuf++ = pDev->assocCnt;
// 1506     *pBuf++ = pDev->age;
// 1507     *pBuf++ = pDev->linkInfo.txCounter;
// 1508     *pBuf++ = pDev->linkInfo.txCost;
// 1509     *pBuf++ = pDev->linkInfo.rxLqi;
// 1510     *pBuf++ = pDev->linkInfo.inKeySeqNum;
// 1511     *pBuf++ = BREAK_UINT32(pDev->linkInfo.inFrmCntr, 0);
// 1512     *pBuf++ = BREAK_UINT32(pDev->linkInfo.inFrmCntr, 1);
// 1513     *pBuf++ = BREAK_UINT32(pDev->linkInfo.inFrmCntr, 2);
// 1514     *pBuf++ = BREAK_UINT32(pDev->linkInfo.inFrmCntr, 3);
// 1515     *pBuf++ = LO_UINT16(pDev->linkInfo.txFailure);
// 1516     *pBuf++ = HI_UINT16(pDev->linkInfo.txFailure);
// 1517   }
// 1518 }
// 1519 
// 1520 /***************************************************************************************************
// 1521  * @fn      packBindEntry_t
// 1522  *
// 1523  * @brief   Pack a BindingEntry_t structure into a byte buffer (pack INVALID_NODE_ADDR
// 1524  *          as dstIdx if the pBind parameter is NULL).
// 1525  *
// 1526  * @param   pBuf - pointer to the buffer into which to pack the structure.
// 1527  * @param   pBind - pointer to the structure.
// 1528  *
// 1529  * @return  void
// 1530  ***************************************************************************************************/
// 1531 static void packBindEntry_t(uint8 *pBuf, BindingEntry_t *pBind)
// 1532 {
// 1533   if ( NULL == pBind )
// 1534   {
// 1535     uint16 rtrn = INVALID_NODE_ADDR;
// 1536     *pBuf++ = 0xFF;
// 1537     *pBuf++ = 0xFF;
// 1538     *pBuf++ = LO_UINT16(rtrn);
// 1539     *pBuf++ = HI_UINT16(rtrn);
// 1540     *pBuf++ = 0xFF;
// 1541     *pBuf++ = 0xFF;
// 1542 
// 1543   }
// 1544   else
// 1545   {
// 1546     *pBuf++ = pBind->srcEP;
// 1547     *pBuf++ = pBind->dstGroupMode;
// 1548     *pBuf++ = LO_UINT16( pBind->dstIdx );
// 1549     *pBuf++ = HI_UINT16( pBind->dstIdx );
// 1550     *pBuf++ = pBind->dstEP;
// 1551     *pBuf++ = pBind->numClusterIds;
// 1552 
// 1553     osal_memcpy( pBuf, pBind->clusterIdList, pBind->numClusterIds * sizeof(uint16));
// 1554   }
// 1555 }
// 1556 
// 1557 #if defined ZCL_KEY_ESTABLISH
// 1558 /***************************************************************************************************
// 1559  * @fn      MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment
// 1560  *
// 1561  * @brief   Proxy the zclGeneral_KeyEstablish_InitiateKeyEstablishment() function.
// 1562  *
// 1563  * @param   pBuf - pointer to the received buffer
// 1564  *
// 1565  * @return  void
// 1566  ***************************************************************************************************/
// 1567 static void MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment(uint8 *pBuf)
// 1568 {
// 1569   afAddrType_t partnerAddr;
// 1570   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1571   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1572 
// 1573   partnerAddr.panId = 0;  // Not an inter-pan message.
// 1574   partnerAddr.endPoint = pBuf[2];
// 1575   partnerAddr.addrMode = (afAddrMode_t)pBuf[3];
// 1576   if (afAddr64Bit == partnerAddr.addrMode)
// 1577   {
// 1578     (void)osal_memcpy(partnerAddr.addr.extAddr, pBuf+4, Z_EXTADDR_LEN);
// 1579   }
// 1580   else
// 1581   {
// 1582     partnerAddr.addr.shortAddr = BUILD_UINT16(pBuf[4], pBuf[5]);
// 1583   }
// 1584 
// 1585   zcl_key_establish_task_id = pBuf[0];
// 1586   *pBuf = zclGeneral_KeyEstablish_InitiateKeyEstablishment(MT_TaskID, &partnerAddr, pBuf[1]);
// 1587   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, pBuf);
// 1588 }
// 1589 
// 1590 /***************************************************************************************************
// 1591  * @fn      MT_UtilzclGeneral_KeyEstablishment_ECDSASign
// 1592  *
// 1593  * @brief   Proxy the zclGeneral_KeyEstablishment_ECDSASign() function.
// 1594  *
// 1595  * @param   pBuf - pointer to the received buffer
// 1596  *
// 1597  * @return  void
// 1598  ***************************************************************************************************/
// 1599 static void MT_UtilzclGeneral_KeyEstablishment_ECDSASign(uint8 *pBuf)
// 1600 {
// 1601 #if defined TC_LINKKEY_JOIN
// 1602   uint8 *output = osal_mem_alloc(SE_PROFILE_SIGNATURE_LENGTH+1);
// 1603   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1604   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1605 
// 1606   if (NULL == output)
// 1607   {
// 1608     *pBuf = FAILURE;
// 1609     MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, pBuf);
// 1610   }
// 1611   else
// 1612   {
// 1613     *output = zclGeneral_KeyEstablishment_ECDSASign(pBuf+1, *pBuf, output+1);
// 1614     MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1615                                          SE_PROFILE_SIGNATURE_LENGTH+1, output);
// 1616     osal_mem_free(output);
// 1617   }
// 1618 #endif
// 1619 }
// 1620 
// 1621 /***************************************************************************************************
// 1622  * @fn      MT_UtilKeyEstablishInd
// 1623  *
// 1624  * @brief   Proxy the ZCL_KEY_ESTABLISH_IND command.
// 1625  *
// 1626  * @param   pInd - Pointer to a keyEstablishmentInd_t structure.
// 1627  *
// 1628  * @return  None
// 1629  ***************************************************************************************************/
// 1630 void MT_UtilKeyEstablishInd(keyEstablishmentInd_t *pInd)
// 1631 {
// 1632   uint8 msg[6];
// 1633 
// 1634   msg[0] = zcl_key_establish_task_id;
// 1635   msg[1] = pInd->hdr.event;
// 1636   msg[2] = pInd->hdr.status;
// 1637   msg[3] = pInd->waitTime;
// 1638   msg[4] = LO_UINT16(pInd->keyEstablishmentSuite);
// 1639   msg[5] = HI_UINT16(pInd->keyEstablishmentSuite);
// 1640 
// 1641   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_UTIL),
// 1642                                        MT_UTIL_ZCL_KEY_ESTABLISH_IND, 6, msg);
// 1643 }
// 1644 #endif
// 1645 
// 1646 /***************************************************************************************************
// 1647  * @fn      MT_UtilSync
// 1648  *
// 1649  * @brief   Process the MT_UTIL_SYNC command
// 1650  *
// 1651  * @param   None
// 1652  *
// 1653  * @return  None
// 1654  ***************************************************************************************************/
// 1655 static void MT_UtilSync(void)
// 1656 {
// 1657  MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ|(uint8)MT_RPC_SYS_UTIL),MT_UTIL_SYNC_REQ,0,0);
// 1658 }
// 1659 #endif /* !defined NONWK */
// 1660 #endif /* MT_UTIL_FUNC */
// 1661 /**************************************************************************************************
// 1662  **************************************************************************************************/
// 
//
// 
//
//
//Errors: none
//Warnings: none
