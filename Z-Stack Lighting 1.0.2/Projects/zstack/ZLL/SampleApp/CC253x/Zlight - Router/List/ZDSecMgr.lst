###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.20.2.41139 for 8051             27/May/2014  19:14:02 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  D:\Texas Instruments\Z-Stack Lighting              #
#                          1.0.2\Components\stack\zdo\ZDSecMgr.c              #
#    Command line       =  -f "D:\Texas Instruments\Z-Stack Lighting          #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\Tools\CC2530DB\f8wRouter.cfg" (-DCPU32MHZ        #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8       #
#                          -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f "D:\Texas         #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\Tools\CC2530DB\f8wConfig.cfg" (-DZIGBEEPRO       #
#                          -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR       #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100    #
#                          -DREJOIN_POLL_RATE=440) -f "D:\Texas               #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\Tools\CC2530DB\f8wZCL.cfg" "D:\Texas             #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Components\stack\zdo\ZDSecMgr.c" -D          #
#                          FEATURE_GREEN_POWER -D SECURE=1 -D                 #
#                          TC_LINKKEY_JOIN -D ZDSECMGR_TC_DEVICE_MAX=2 -D     #
#                          NV_RESTORE -D HOLD_AUTO_START -D INTER_PAN -D      #
#                          LCD_SUPPORTED=DEBUG -D ZCL_BASIC -D ZCL_READ -D    #
#                          ZCL_WRITE -D ZCL_IDENTIFY -D ZCL_ON_OFF -D         #
#                          ZCL_SCENES -D ZCL_GROUPS -D                        #
#                          ZCL_LIGHT_LINK_ENHANCE -D ZCL_LEVEL_CTRL -D        #
#                          ZCL_COLOR_CTRL -D MAX_CHANNELS_24GHZ=0x02108800    #
#                          -D xPWM_ALT2 -D xTHERMAL_SHUTDOWN -D               #
#                          ZLL_1_0_HUB_COMPATIBILITY -D DALI_LIGHT -lC        #
#                          "D:\Texas Instruments\Z-Stack Lighting             #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\Zlight  #
#                          - Router\List\" -lA "D:\Texas Instruments\Z-Stack  #
#                          Lighting 1.0.2\Projects\zstack\ZLL\SampleApp\CC253 #
#                          x\Zlight - Router\List\" --diag_suppress           #
#                          Pe001,Pa010 -o "D:\Texas Instruments\Z-Stack       #
#                          Lighting 1.0.2\Projects\zstack\ZLL\SampleApp\CC253 #
#                          x\Zlight - Router\Obj\" -e --debug --core=plain    #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "D:\Texas                  #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\" -I    #
#                          "D:\Texas Instruments\Z-Stack Lighting             #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\Sour #
#                          ce\" -I "D:\Texas Instruments\Z-Stack Lighting     #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\S #
#                          ource\" -I "D:\Texas Instruments\Z-Stack Lighting  #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\HomeAutomation\Source\" -I "D:\Texas             #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\HomeAutomation\SampleLight\Source\" -I           #
#                          "D:\Texas Instruments\Z-Stack Lighting             #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\ZMain\TI2530DB\" -I "D:\Texas                    #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\hal\include\" -I "D:\Texas      #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\hal\target\CC2530PMP4712\" -I   #
#                          "D:\Texas Instruments\Z-Stack Lighting             #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mac\include\" -I "D:\Texas      #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mac\high_level\" -I "D:\Texas   #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mac\low_level\srf04\" -I        #
#                          "D:\Texas Instruments\Z-Stack Lighting             #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mac\low_level\srf04\single_chip #
#                          \" -I "D:\Texas Instruments\Z-Stack Lighting       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mt\" -I "D:\Texas               #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\osal\include\" -I "D:\Texas     #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\services\saddr\" -I "D:\Texas   #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\services\sdata\" -I "D:\Texas   #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\af\" -I "D:\Texas         #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\nwk\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\sapi\" -I "D:\Texas       #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\sec\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\sys\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\zcl\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\zdo\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\zmac\" -I "D:\Texas             #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\zmac\f8w\" -Ohz                 #
#                          --require_prototypes                               #
#    List file          =  D:\Texas Instruments\Z-Stack Lighting              #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\Zlight  #
#                          - Router\List\ZDSecMgr.lst                         #
#    Object file        =  D:\Texas Instruments\Z-Stack Lighting              #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\Zlight  #
#                          - Router\Obj\ZDSecMgr.r51                          #
#                                                                             #
#                                                                             #
###############################################################################

D:\Texas Instruments\Z-Stack Lighting 1.0.2\Components\stack\zdo\ZDSecMgr.c
      1          /******************************************************************************
      2            Filename:       ZDSecMgr.c
      3            Revised:        $Date: 2013-10-11 17:01:59 -0700 (Fri, 11 Oct 2013) $
      4            Revision:       $Revision: 35655 $
      5          
      6            Description:    The ZigBee Device Security Manager.
      7          
      8          
      9            Copyright 2005-2013 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License"). You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product. Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          ******************************************************************************/
     39          
     40          #ifdef __cplusplus
     41          extern "C"
     42          {
     43          #endif
     44          
     45          /******************************************************************************
     46           * INCLUDES
     47           */
     48          #include "ZComDef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_Nv.h"
     51          #include "ZGlobals.h"
     52          #include "ssp.h"
     53          #include "nwk_globals.h"
     54          #include "nwk.h"
     55          #include "NLMEDE.h"
     56          #include "AddrMgr.h"
     57          #include "AssocList.h"
     58          #include "APSMEDE.h"
     59          #include "ZDConfig.h"
     60          #include "ZDSecMgr.h"
     61          
     62          /******************************************************************************
     63           * CONSTANTS
     64           */
     65          // maximum number of devices managed by this Security Manager
     66          #if !defined ( ZDSECMGR_DEVICE_MAX )
     67            #define ZDSECMGR_DEVICE_MAX 3
     68          #endif
     69          
     70          // maximum number of LINK keys this device may store
     71          #define ZDSECMGR_ENTRY_MAX ZDSECMGR_DEVICE_MAX
     72          
     73          // total number of stored devices
     74          #if !defined ( ZDSECMGR_STORED_DEVICES )
     75            #define ZDSECMGR_STORED_DEVICES 3
     76          #endif
     77          
     78          // Total number of preconfigured trust center link key
     79          #if !defined ( ZDSECMGR_TC_DEVICE_MAX )
     80            #define ZDSECMGR_TC_DEVICE_MAX 1
     81          #endif
     82          
     83          #if ( ZDSECMGR_TC_DEVICE_MAX < 1 ) || ( ZDSECMGR_TC_DEVICE_MAX > 255 )
     84            #error "ZDSECMGR_TC_DEVICE_MAX shall be between 1 and 255 !"
     85          #endif
     86          
     87          // APSME Stub Implementations
     88          #define ZDSecMgrLinkKeySet     APSME_LinkKeySet
     89          #define ZDSecMgrLinkKeyNVIdGet APSME_LinkKeyNVIdGet
     90          #define ZDSecMgrKeyFwdToChild  APSME_KeyFwdToChild
     91          #define ZDSecMgrIsLinkKeyValid APSME_IsLinkKeyValid
     92          
     93          /******************************************************************************
     94           * TYPEDEFS
     95           */
     96          typedef struct
     97          {
     98            uint16            ami;
     99            uint16            keyNvId;   // index to the Link Key table in NV
    100            ZDSecMgr_Authentication_Option authenticateOption;
    101          } ZDSecMgrEntry_t;
    102          
    103          typedef struct
    104          {
    105            uint16          nwkAddr;
    106            uint8*          extAddr;
    107            uint16          parentAddr;
    108            uint8           secure;
    109            uint8           devStatus;
    110          } ZDSecMgrDevice_t;
    111          
    112          /******************************************************************************
    113           * LOCAL VARIABLES
    114           */
    115          #if 0 // Taken out because the following functionality is only used for test
    116                // purpose. A more efficient (above) way is used. It can be put
    117                // back in if customers request for a white/black list feature.
    118          uint8 ZDSecMgrStoredDeviceList[ZDSECMGR_STORED_DEVICES][Z_EXTADDR_LEN] =
    119          {
    120            { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    121            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
    122            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    123          };
    124          #endif
    125          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    126          uint8 ZDSecMgrTCExtAddr[Z_EXTADDR_LEN]=
   \                     ZDSecMgrTCExtAddr:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
    127            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    128          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    129          uint8 ZDSecMgrTCAuthenticated = FALSE;
   \                     ZDSecMgrTCAuthenticated:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    130          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    131          ZDSecMgrEntry_t* ZDSecMgrEntries  = NULL;
   \                     ZDSecMgrEntries:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    132          
    133          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
    134          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    135          uint8 ZDSecMgrPermitJoiningEnabled;
   \                     ZDSecMgrPermitJoiningEnabled:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    136          uint8 ZDSecMgrPermitJoiningTimed;
   \                     ZDSecMgrPermitJoiningTimed:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    137          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    138          APSME_TCLinkKey_t TrustCenterLinkKey;
   \                     TrustCenterLinkKey:
   \   000000                DS 32
   \   000020                REQUIRE __INIT_XDATA_Z
    139          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    140          APSME_ApsLinkKeyFrmCntr_t ApsLinkKeyFrmCntr[ZDSECMGR_ENTRY_MAX];
   \                     ApsLinkKeyFrmCntr:
   \   000000                DS 27
   \   00001B                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    141          APSME_TCLinkKeyFrmCntr_t TCLinkKeyFrmCntr[ZDSECMGR_TC_DEVICE_MAX];
   \                     TCLinkKeyFrmCntr:
   \   000000                DS 18
   \   000012                REQUIRE __INIT_XDATA_Z
    142          
    143          /******************************************************************************
    144           * PRIVATE FUNCTIONS
    145           *
    146           *   ZDSecMgrAddrStore
    147           *   ZDSecMgrExtAddrStore
    148           *   ZDSecMgrExtAddrLookup
    149           *   ZDSecMgrEntryInit
    150           *   ZDSecMgrEntryLookup
    151           *   ZDSecMgrEntryLookupAMI
    152           *   ZDSecMgrEntryLookupExt
    153           *   ZDSecMgrEntryLookupExtGetIndex
    154           *   ZDSecMgrEntryFree
    155           *   ZDSecMgrEntryNew
    156           *   ZDSecMgrAppKeyGet
    157           *   ZDSecMgrAppKeyReq
    158           *   ZDSecMgrSendNwkKey
    159           *   ZDSecMgrDeviceRemove
    160           *   ZDSecMgrDeviceValidateRM
    161           *   ZDSecMgrDeviceValidate
    162           *   ZDSecMgrDeviceJoin
    163           *   ZDSecMgrDeviceJoinDirect
    164           *   ZDSecMgrDeviceJoinFwd
    165           *   ZDSecMgrDeviceNew
    166           *   ZDSecMgrAssocDeviceAuth
    167           *   ZDSecMgrAuthNwkKey
    168           *   APSME_TCLinkKeyInit
    169           *   APSME_IsDefaultTCLK
    170           */
    171          
    172          //-----------------------------------------------------------------------------
    173          // address management
    174          //-----------------------------------------------------------------------------
    175          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    176          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    177          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami );
    178          
    179          //-----------------------------------------------------------------------------
    180          // Trust Center management
    181          //-----------------------------------------------------------------------------
    182          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr );
    183          void ZDSecMgrTCDataLoad( uint8* extAddr );
    184          
    185          //-----------------------------------------------------------------------------
    186          // entry data
    187          //-----------------------------------------------------------------------------
    188          void ZDSecMgrEntryInit(uint8 state);
    189          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry );
    190          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry );
    191          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry );
    192          ZStatus_t ZDSecMgrEntryLookupExtGetIndex( uint8* extAddr, ZDSecMgrEntry_t** entry, uint16* entryIndex );
    193          ZStatus_t ZDSecMgrEntryLookupAMIGetIndex( uint16 ami, uint16* entryIndex );
    194          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry );
    195          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry );
    196          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option );
    197          void ZDSecMgrApsLinkKeyInit(void);
    198          #if defined ( NV_RESTORE )
    199          static void ZDSecMgrWriteNV(void);
    200          static void ZDSecMgrRestoreFromNV(void);
    201          static void ZDSecMgrUpdateNV( uint16 index );
    202          #endif
    203          
    204          //-----------------------------------------------------------------------------
    205          // key support
    206          //-----------------------------------------------------------------------------
    207          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
    208                                       uint8*  initExtAddr,
    209                                       uint16  partNwkAddr,
    210                                       uint8*  partExtAddr,
    211                                       uint8** key,
    212                                       uint8*  keyType );
    213          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind );
    214          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device );
    215          void ZDSecMgrNwkKeyInit(uint8 setDefault);
    216          
    217          //-----------------------------------------------------------------------------
    218          // device management
    219          //-----------------------------------------------------------------------------
    220          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device );
    221          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device );
    222          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device );
    223          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device );
    224          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device );
    225          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device );
    226          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* device );
    227          
    228          //-----------------------------------------------------------------------------
    229          // association management
    230          //-----------------------------------------------------------------------------
    231          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc );
    232          
    233          //-----------------------------------------------------------------------------
    234          // authentication management
    235          //-----------------------------------------------------------------------------
    236          void ZDSecMgrAuthNwkKey( void );
    237          
    238          //-----------------------------------------------------------------------------
    239          // APSME function
    240          //-----------------------------------------------------------------------------
    241          void APSME_TCLinkKeyInit( uint8 setDefault );
    242          uint8 APSME_IsDefaultTCLK( uint8 *extAddr );
    243          
    244          /******************************************************************************
    245           * @fn          ZDSecMgrAddrStore
    246           *
    247           * @brief       Store device addresses.
    248           *
    249           * @param       nwkAddr - [in] NWK address
    250           * @param       extAddr - [in] EXT address
    251           * @param       ami     - [out] Address Manager index
    252           *
    253           * @return      ZStatus_t
    254           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    255          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrAddrStore:
    256          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    257            ZStatus_t      status;
    258            AddrMgrEntry_t entry;
    259          
    260          
    261            // add entry
    262            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   7402         MOV     A,#0x2
   \   000012   F0           MOVX    @DPTR,A
    263            entry.nwkAddr = nwkAddr;
   \   000013   14           DEC     A
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   12....       LCALL   ?Subroutine18 & 0xFFFF
    264            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \                     ??CrossCallReturnLabel_8:
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   AA82         MOV     R2,DPL
   \   00001F   AB83         MOV     R3,DPH
   \   000021   12....       LCALL   ??AddrMgrExtAddrSet?relay
   \   000024   7416         MOV     A,#0x16
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   12....       LCALL   ?Subroutine24 & 0xFFFF
    265          
    266            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_14:
   \   00002C   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   00002F   E9           MOV     A,R1
   \   000030   6401         XRL     A,#0x1
   \   000032   700A         JNZ     ??ZDSecMgrAddrStore_0
    267            {
    268              // return successful results
    269              *ami   = entry.index;
   \   000034   740B         MOV     A,#0xb
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   12....       LCALL   ?Subroutine12 & 0xFFFF
    270              status = ZSuccess;
    271            }
   \                     ??CrossCallReturnLabel_70:
   \   00003C   8008         SJMP    ??CrossCallReturnLabel_11
    272            else
    273            {
    274              // return failed results
    275              *ami   = entry.index;
   \                     ??ZDSecMgrAddrStore_0:
   \   00003E   740B         MOV     A,#0xb
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   12....       LCALL   ?Subroutine19 & 0xFFFF
    276              status = ZNwkUnknownDevice;
    277            }
    278          
    279            return status;
   \                     ??CrossCallReturnLabel_11:
   \   000046   02....       LJMP    ?Subroutine0 & 0xFFFF
    280          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_163:
   \   000003   FE           MOV     R6,A
   \   000004   E9           MOV     A,R1
   \   000005   FF           MOV     R7,A
   \   000006                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000006                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000006   85..82       MOV     DPL,?XSP + 0
   \   000009   85..83       MOV     DPH,?XSP + 1
   \   00000C   AA82         MOV     R2,DPL
   \   00000E   AB83         MOV     R3,DPH
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_177:
   \   000003   8E82         MOV     DPL,R6
   \   000005   8F83         MOV     DPH,R7
   \   000007   E8           MOV     A,R0
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   E9           MOV     A,R1
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   79C8         MOV     R1,#-0x38
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   12....       LCALL   ??Subroutine62_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_114:
   \   000003                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000003                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000003                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000003   7403         MOV     A,#0x3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004                REQUIRE ??Subroutine53_0
   \   000004                ; // Fall through to label ??Subroutine53_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine53_0:
   \   000000   F9           MOV     R1,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005                REQUIRE ??Subroutine54_0
   \   000005                ; // Fall through to label ??Subroutine54_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine54_0:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   7900         MOV     R1,#0x0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine62_0:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   E8           MOV     A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   740D         MOV     A,#0xd
   \   000002                REQUIRE ??Subroutine67_0
   \   000002                ; // Fall through to label ??Subroutine67_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine67_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine68_0
   \   000003                ; // Fall through to label ??Subroutine68_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine68_0:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET
    281          
    282          /******************************************************************************
    283           * @fn          ZDSecMgrExtAddrStore
    284           *
    285           * @brief       Store EXT address.
    286           *
    287           * @param       extAddr - [in] EXT address
    288           * @param       ami     - [out] Address Manager index
    289           *
    290           * @return      ZStatus_t
    291           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    292          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrStore:
    293          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    294            ZStatus_t      status;
    295            AddrMgrEntry_t entry;
    296          
    297          
    298            // add entry
    299            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   7402         MOV     A,#0x2
   \   000012   F0           MOVX    @DPTR,A
    300            entry.nwkAddr = nwkAddr;
   \   000013   14           DEC     A
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   12....       LCALL   ?Subroutine18 & 0xFFFF
    301            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \                     ??CrossCallReturnLabel_9:
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   AA82         MOV     R2,DPL
   \   00001F   AB83         MOV     R3,DPH
   \   000021   12....       LCALL   ??AddrMgrExtAddrSet?relay
   \   000024   7416         MOV     A,#0x16
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   12....       LCALL   ?Subroutine24 & 0xFFFF
    302          
    303            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_15:
   \   00002C   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   00002F   E9           MOV     A,R1
   \   000030   6401         XRL     A,#0x1
   \   000032   700A         JNZ     ??ZDSecMgrExtAddrStore_0
    304            {
    305              // return successful results
    306              *ami   = entry.index;
   \   000034   740B         MOV     A,#0xb
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   12....       LCALL   ?Subroutine12 & 0xFFFF
    307              status = ZSuccess;
    308            }
   \                     ??CrossCallReturnLabel_71:
   \   00003C   8008         SJMP    ??CrossCallReturnLabel_12
    309            else
    310            {
    311              // return failed results
    312              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrStore_0:
   \   00003E   740B         MOV     A,#0xb
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   12....       LCALL   ?Subroutine19 & 0xFFFF
    313              status = ZNwkUnknownDevice;
    314            }
    315          
    316            return status;
   \                     ??CrossCallReturnLabel_12:
   \   000046   02....       LJMP    ?Subroutine0 & 0xFFFF
    317          }
    318          
    319          /******************************************************************************
    320           * @fn          ZDSecMgrExtAddrLookup
    321           *
    322           * @brief       Lookup index for specified EXT address.
    323           *
    324           * @param       extAddr - [in] EXT address
    325           * @param       ami     - [out] Address Manager index
    326           *
    327           * @return      ZStatus_t
    328           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    329          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrLookup:
    330          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    331            ZStatus_t      status;
    332            AddrMgrEntry_t entry;
    333          
    334          
    335            // lookup entry
    336            entry.user = ADDRMGR_USER_SECURITY;
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   7402         MOV     A,#0x2
   \   000016   F0           MOVX    @DPTR,A
    337            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   000017                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000017   EA           MOV     A,R2
   \   000018   FC           MOV     R4,A
   \   000019   EB           MOV     A,R3
   \   00001A   FD           MOV     R5,A
   \   00001B   7403         MOV     A,#0x3
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   AA82         MOV     R2,DPL
   \   000022   AB83         MOV     R3,DPH
   \   000024   12....       LCALL   ??AddrMgrExtAddrSet?relay
    338          
    339            if ( AddrMgrEntryLookupExt( &entry ) == TRUE )
   \   000027                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   000027   85..82       MOV     DPL,?XSP + 0
   \   00002A   85..83       MOV     DPH,?XSP + 1
   \   00002D   AA82         MOV     R2,DPL
   \   00002F   AB83         MOV     R3,DPH
   \   000031   12....       LCALL   ??AddrMgrEntryLookupExt?relay
   \   000034   E9           MOV     A,R1
   \   000035   6401         XRL     A,#0x1
   \   000037   700A         JNZ     ??ZDSecMgrExtAddrLookup_0
    340            {
    341              // return successful results
    342              *ami   = entry.index;
   \   000039   740B         MOV     A,#0xb
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   12....       LCALL   ?Subroutine12 & 0xFFFF
    343              status = ZSuccess;
    344            }
   \                     ??CrossCallReturnLabel_72:
   \   000041   8008         SJMP    ??CrossCallReturnLabel_13
    345            else
    346            {
    347              // return failed results
    348              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrLookup_0:
   \   000043   740B         MOV     A,#0xb
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   12....       LCALL   ?Subroutine19 & 0xFFFF
    349              status = ZNwkUnknownDevice;
    350            }
    351          
    352            return status;
   \                     ??CrossCallReturnLabel_13:
   \   00004B   02....       LJMP    ?Subroutine0 & 0xFFFF
    353          }
    354          
    355          /******************************************************************************
    356           * @fn          ZDSecMgrAddrClear
    357           *
    358           * @brief       Clear security bit from Address Manager for specific device.
    359           *
    360           * @param       extAddr - [in] EXT address
    361           *
    362           * @return      ZStatus_t
    363           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    364          ZStatus_t ZDSecMgrAddrClear( uint8* extAddr )
   \                     ZDSecMgrAddrClear:
    365          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 15
   \   000005   74F1         MOV     A,#-0xf
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    366            ZStatus_t status;
    367            uint16 entryAmi;
    368          
    369            // get Address Manager Index
    370            status = ZDSecMgrExtAddrLookup( extAddr, &entryAmi );
   \   00000A                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   AC82         MOV     R4,DPL
   \   000012   AD83         MOV     R5,DPH
   \   000014   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   000017   E9           MOV     A,R1
   \   000018   FE           MOV     R6,A
    371          
    372            if ( status == ZSuccess )
   \   000019   7026         JNZ     ??ZDSecMgrAddrClear_0
    373            {
    374              AddrMgrEntry_t addrEntry;
    375          
    376              // Clear SECURITY User bit from the address manager
    377              addrEntry.user = ADDRMGR_USER_SECURITY;
   \   00001B   7402         MOV     A,#0x2
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   7402         MOV     A,#0x2
   \   000022   F0           MOVX    @DPTR,A
    378              addrEntry.index = entryAmi;
   \   000023   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_172:
   \   000026   740D         MOV     A,#0xd
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   12....       LCALL   ??Subroutine63_0 & 0xFFFF
    379          
    380              if ( AddrMgrEntryRelease( &addrEntry ) != TRUE )
   \                     ??CrossCallReturnLabel_119:
   \   00002E                ; Setup parameters for call to function AddrMgrEntryRelease
   \   00002E   7402         MOV     A,#0x2
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   AA82         MOV     R2,DPL
   \   000035   AB83         MOV     R3,DPH
   \   000037   12....       LCALL   ??AddrMgrEntryRelease?relay
   \   00003A   E9           MOV     A,R1
   \   00003B   6401         XRL     A,#0x1
   \   00003D   6002         JZ      ??ZDSecMgrAddrClear_0
    381              {
    382                // return failure results
    383                status = ZFailure;
   \   00003F   7E01         MOV     R6,#0x1
    384              }
    385            }
    386          
    387            return status;
   \                     ??ZDSecMgrAddrClear_0:
   \   000041   EE           MOV     A,R6
   \   000042   F9           MOV     R1,A
   \   000043   740F         MOV     A,#0xf
   \   000045   02....       LJMP    ??Subroutine67_0 & 0xFFFF
    388          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine63_0:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine70_0
   \   000006                ; // Fall through to label ??Subroutine70_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine70_0:
   \   000000   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_178:
   \   000003   22           RET
    389          
    390          /******************************************************************************
    391           * @fn          ZDSecMgrEntryInit
    392           *
    393           * @brief       Initialize entry sub module
    394           *
    395           * @param       state - device initialization state
    396           *
    397           * @return      none
    398           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    399          void ZDSecMgrEntryInit(uint8 state)
   \                     ZDSecMgrEntryInit:
    400          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    401            if (ZDSecMgrEntries == NULL)
   \   000007   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00000A   12....       LCALL   ??Subroutine69_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_152:
   \   00000D   702D         JNZ     ??ZDSecMgrEntryInit_0
    402            {
    403              uint16 index;
    404          
    405              if ((ZDSecMgrEntries = osal_mem_alloc(sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)) == NULL)
   \   00000F                ; Setup parameters for call to function osal_mem_alloc
   \   00000F   7A0F         MOV     R2,#0xf
   \   000011   7B00         MOV     R3,#0x0
   \   000013   12....       LCALL   ??osal_mem_alloc?relay
   \   000016   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000019   EA           MOV     A,R2
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   A3           INC     DPTR
   \   00001C   EB           MOV     A,R3
   \   00001D   12....       LCALL   ??Subroutine55_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   000020   6020         JZ      ??ZDSecMgrEntryInit_1
    406              {
    407                return;
    408              }
    409          
    410              for (index = 0; index < ZDSECMGR_ENTRY_MAX; index++)
   \   000022   7800         MOV     R0,#0x0
   \   000024   7900         MOV     R1,#0x0
    411              {
    412                ZDSecMgrEntries[index].ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryInit_2:
   \   000026   12....       LCALL   ?Subroutine27 & 0xFFFF
    413          
    414                ZDSecMgrEntries[index].keyNvId = SEC_NO_KEY_NV_ID;
    415              }
   \                     ??CrossCallReturnLabel_20:
   \   000029   74FE         MOV     A,#-0x2
   \   00002B   F0           MOVX    @DPTR,A
   \   00002C   A3           INC     DPTR
   \   00002D   04           INC     A
   \   00002E   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   E4           CLR     A
   \   000034   F0           MOVX    @DPTR,A
   \   000035   A3           INC     DPTR
   \   000036   F0           MOVX    @DPTR,A
   \   000037   12....       LCALL   ?Subroutine32 & 0xFFFF
    416            }
   \                     ??CrossCallReturnLabel_29:
   \   00003A   40EA         JC      ??ZDSecMgrEntryInit_2
    417          
    418          #if defined NV_RESTORE
    419            if (state == ZDO_INITDEV_RESTORED_NETWORK_STATE)
   \                     ??ZDSecMgrEntryInit_0:
   \   00003C   EE           MOV     A,R6
   \   00003D   7003         JNZ     ??ZDSecMgrEntryInit_1
    420            {
    421              ZDSecMgrRestoreFromNV();
   \   00003F                ; Setup parameters for call to function ZDSecMgrRestoreFromNV
   \   00003F   12....       LCALL   ??ZDSecMgrRestoreFromNV?relay
    422            }
   \                     ??ZDSecMgrEntryInit_1:
   \   000042   02....       LJMP    ??Subroutine68_0 & 0xFFFF
    423          #else
    424            (void)state;
    425          #endif
    426          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   E8           MOV     A,R0
   \   000001   2401         ADD     A,#0x1
   \   000003   08           INC     R0
   \   000004   E9           MOV     A,R1
   \   000005   3400         ADDC    A,#0x0
   \   000007   F9           MOV     R1,A
   \   000008   C3           CLR     C
   \   000009   E8           MOV     A,R0
   \   00000A   9403         SUBB    A,#0x3
   \   00000C   E9           MOV     A,R1
   \   00000D   9400         SUBB    A,#0x0
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine55_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000004   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_165:
   \   000007   49           ORL     A,R1
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   000003   8A82         MOV     DPL,R2
   \   000005   8B83         MOV     DPH,R3
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   E8           MOV     A,R0
   \   000001   FA           MOV     R2,A
   \   000002   E9           MOV     A,R1
   \   000003   FB           MOV     R3,A
   \   000004   EA           MOV     A,R2
   \   000005   75F005       MOV     B,#0x5
   \   000008   A4           MUL     AB
   \   000009   FA           MOV     R2,A
   \   00000A   ACF0         MOV     R4,B
   \   00000C   75F005       MOV     B,#0x5
   \   00000F   EB           MOV     A,R3
   \   000010   A4           MUL     AB
   \   000011   2C           ADD     A,R4
   \   000012   FB           MOV     R3,A
   \   000013   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000016   E0           MOVX    A,@DPTR
   \   000017   2A           ADD     A,R2
   \   000018   FA           MOV     R2,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   3B           ADDC    A,R3
   \   00001C   FB           MOV     R3,A
   \   00001D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000001                ; Setup parameters for call to function AssocGetWithShort
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine69_0:
   \   000000   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_166:
   \   000003   49           ORL     A,R1
   \   000004   22           RET
    427          
    428          /******************************************************************************
    429           * @fn          ZDSecMgrEntryLookup
    430           *
    431           * @brief       Lookup entry index using specified NWK address.
    432           *
    433           * @param       nwkAddr - [in] NWK address
    434           * @param       entry   - [out] valid entry
    435           *
    436           * @return      ZStatus_t
    437           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    438          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookup:
    439          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    440            uint16         index;
    441            AddrMgrEntry_t addrMgrEntry;
    442          
    443            // initialize results
    444            *entry = NULL;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   12....       LCALL   ?Subroutine11 & 0xFFFF
    445          
    446            // verify data is available
    447            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_77:
   \   000015   6043         JZ      ??ZDSecMgrEntryLookup_0
    448            {
    449              addrMgrEntry.user    = ADDRMGR_USER_SECURITY;
   \   000017   85..82       MOV     DPL,?XSP + 0
   \   00001A   85..83       MOV     DPH,?XSP + 1
   \   00001D   7402         MOV     A,#0x2
   \   00001F   F0           MOVX    @DPTR,A
    450              addrMgrEntry.nwkAddr = nwkAddr;
   \   000020   14           DEC     A
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   12....       LCALL   ?Subroutine10 & 0xFFFF
    451          
    452              if ( AddrMgrEntryLookupNwk( &addrMgrEntry ) == TRUE )
   \                     ??CrossCallReturnLabel_138:
   \   000027   12....       LCALL   ??AddrMgrEntryLookupNwk?relay
   \   00002A   E9           MOV     A,R1
   \   00002B   6401         XRL     A,#0x1
   \   00002D   702B         JNZ     ??ZDSecMgrEntryLookup_0
    453              {
    454                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00002F   7800         MOV     R0,#0x0
   \   000031   7900         MOV     R1,#0x0
    455                {
    456                  if ( addrMgrEntry.index == ZDSecMgrEntries[index].ami )
   \                     ??ZDSecMgrEntryLookup_1:
   \   000033   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   000036   740B         MOV     A,#0xb
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   FC           MOV     R4,A
   \   00003D   A3           INC     DPTR
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   FD           MOV     R5,A
   \   000040   8A82         MOV     DPL,R2
   \   000042   8B83         MOV     DPH,R3
   \   000044   E0           MOVX    A,@DPTR
   \   000045   6C           XRL     A,R4
   \   000046   7003         JNZ     ??ZDSecMgrEntryLookup_2
   \   000048   A3           INC     DPTR
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   6D           XRL     A,R5
   \                     ??ZDSecMgrEntryLookup_2:
   \   00004B   7008         JNZ     ??ZDSecMgrEntryLookup_3
    457                  {
    458                    // return successful results
    459                    *entry = &ZDSecMgrEntries[index];
   \   00004D   EA           MOV     A,R2
   \   00004E   F8           MOV     R0,A
   \   00004F   EB           MOV     A,R3
   \   000050   12....       LCALL   ??Subroutine53_0 & 0xFFFF
    460          
    461                    // break from loop
    462                    return ZSuccess;
    463                  }
    464                }
   \                     ??CrossCallReturnLabel_73:
   \   000053   8007         SJMP    ??ZDSecMgrEntryLookup_4
   \                     ??ZDSecMgrEntryLookup_3:
   \   000055   12....       LCALL   ?Subroutine32 & 0xFFFF
    465              }
    466            }
   \                     ??CrossCallReturnLabel_30:
   \   000058   40D9         JC      ??ZDSecMgrEntryLookup_1
    467          
    468            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookup_0:
   \   00005A   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryLookup_4:
   \   00005C   02....       LJMP    ?Subroutine0 & 0xFFFF
    469          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   E4           CLR     A
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine55_0
   \   000003                ; // Fall through to label ??Subroutine55_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004                REQUIRE ??Subroutine64_0
   \   000004                ; // Fall through to label ??Subroutine64_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine64_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000001                ; Setup parameters for call to function APSME_RequestKeyReq
   \   000001                ; Setup parameters for call to function NLME_LeaveReq
   \   000001                ; Setup parameters for call to function APSME_UpdateDeviceReq
   \   000001                ; Setup parameters for call to function APSME_UpdateDeviceReq
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceNew
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   AA82         MOV     R2,DPL
   \   000009   AB83         MOV     R3,DPH
   \   00000B   22           RET
    470          
    471          /******************************************************************************
    472           * @fn          ZDSecMgrEntryLookupAMI
    473           *
    474           * @brief       Lookup entry using specified address index
    475           *
    476           * @param       ami   - [in] Address Manager index
    477           * @param       entry - [out] valid entry
    478           *
    479           * @return      ZStatus_t
    480           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    481          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupAMI:
    482          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    483            uint16 index;
    484          
    485            // initialize results
    486            *entry = NULL;
   \   000005   8C82         MOV     DPL,R4
   \   000007   8D83         MOV     DPH,R5
   \   000009   12....       LCALL   ?Subroutine11 & 0xFFFF
    487          
    488            // verify data is available
    489            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_78:
   \   00000C   602B         JZ      ??ZDSecMgrEntryLookupAMI_0
    490            {
    491              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00000E   7800         MOV     R0,#0x0
   \   000010   7900         MOV     R1,#0x0
    492              {
    493                if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupAMI_1:
   \   000012   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000015   FE           MOV     R6,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   3F           ADDC    A,R7
   \   000019   FF           MOV     R7,A
   \   00001A   8E82         MOV     DPL,R6
   \   00001C   8F83         MOV     DPH,R7
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   6A           XRL     A,R2
   \   000020   7003         JNZ     ??ZDSecMgrEntryLookupAMI_2
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   6B           XRL     A,R3
   \                     ??ZDSecMgrEntryLookupAMI_2:
   \   000025   700D         JNZ     ??ZDSecMgrEntryLookupAMI_3
    494                {
    495                  // return successful results
    496                  *entry = &ZDSecMgrEntries[index];
   \   000027   EE           MOV     A,R6
   \   000028   F8           MOV     R0,A
   \   000029   EF           MOV     A,R7
   \   00002A   F9           MOV     R1,A
   \   00002B   8C82         MOV     DPL,R4
   \   00002D   8D83         MOV     DPH,R5
   \   00002F   12....       LCALL   ??Subroutine54_0 & 0xFFFF
    497          
    498                  // break from loop
    499                  return ZSuccess;
    500                }
    501              }
   \                     ??CrossCallReturnLabel_74:
   \   000032   8007         SJMP    ??ZDSecMgrEntryLookupAMI_4
   \                     ??ZDSecMgrEntryLookupAMI_3:
   \   000034   12....       LCALL   ?Subroutine32 & 0xFFFF
    502            }
   \                     ??CrossCallReturnLabel_31:
   \   000037   40D9         JC      ??ZDSecMgrEntryLookupAMI_1
    503          
    504            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookupAMI_0:
   \   000039   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryLookupAMI_4:
   \   00003B   02....       LJMP    ??Subroutine68_0 & 0xFFFF
    505          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   E8           MOV     A,R0
   \   000001   FE           MOV     R6,A
   \   000002   E9           MOV     A,R1
   \   000003   FF           MOV     R7,A
   \   000004   EE           MOV     A,R6
   \   000005   75F005       MOV     B,#0x5
   \   000008   A4           MUL     AB
   \   000009   FE           MOV     R6,A
   \   00000A   85F0..       MOV     ?V0 + 0,B
   \   00000D   75F005       MOV     B,#0x5
   \   000010   EF           MOV     A,R7
   \   000011   A4           MUL     AB
   \   000012   25..         ADD     A,?V0 + 0
   \   000014   FF           MOV     R7,A
   \   000015   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000018   E0           MOVX    A,@DPTR
   \   000019   2E           ADD     A,R6
   \   00001A   22           RET
    506          
    507          /******************************************************************************
    508           * @fn          ZDSecMgrEntryLookupExt
    509           *
    510           * @brief       Lookup entry index using specified EXT address.
    511           *
    512           * @param       extAddr - [in] EXT address
    513           * @param       entry   - [out] valid entry
    514           *
    515           * @return      ZStatus_t
    516           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    517          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupExt:
    518          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    519            ZStatus_t status;
    520            uint16    ami;
    521          
    522            // initialize results
    523            *entry = NULL;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   E4           CLR     A
   \   000013   F0           MOVX    @DPTR,A
   \   000014   A3           INC     DPTR
   \   000015   F0           MOVX    @DPTR,A
    524            status = ZNwkUnknownDevice;
   \   000016   75..C8       MOV     ?V0 + 0,#-0x38
    525          
    526            // lookup address index
    527            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   000019                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   000019   85..82       MOV     DPL,?XSP + 0
   \   00001C   85..83       MOV     DPH,?XSP + 1
   \   00001F   AC82         MOV     R4,DPL
   \   000021   AD83         MOV     R5,DPH
   \   000023   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   000026   E9           MOV     A,R1
   \   000027   7013         JNZ     ??ZDSecMgrEntryLookupExt_0
    528            {
    529              status = ZDSecMgrEntryLookupAMI( ami, entry );
   \   000029                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000029   EE           MOV     A,R6
   \   00002A   FC           MOV     R4,A
   \   00002B   EF           MOV     A,R7
   \   00002C   FD           MOV     R5,A
   \   00002D   85..82       MOV     DPL,?XSP + 0
   \   000030   85..83       MOV     DPH,?XSP + 1
   \   000033   12....       LCALL   ??Subroutine59_0 & 0xFFFF
    530            }
   \                     ??CrossCallReturnLabel_89:
   \   000036   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   000039   E9           MOV     A,R1
   \   00003A   F5..         MOV     ?V0 + 0,A
    531          
    532            return status;
   \                     ??ZDSecMgrEntryLookupExt_0:
   \   00003C   A9..         MOV     R1,?V0 + 0
   \   00003E   02....       LJMP    ?Subroutine7 & 0xFFFF
    533          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine59_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   7402         MOV     A,#0x2
   \   000002   02....       LJMP    ??Subroutine67_0 & 0xFFFF
    534          
    535          /******************************************************************************
    536           * @fn          ZDSecMgrEntryLookupExtGetIndex
    537           *
    538           * @brief       Lookup entry index using specified EXT address.
    539           *
    540           * @param       extAddr - [in] EXT address
    541           * @param       entryIndex - [out] valid index to the entry table
    542           *
    543           * @return      ZStatus_t
    544           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    545          ZStatus_t ZDSecMgrEntryLookupExtGetIndex( uint8* extAddr, ZDSecMgrEntry_t** entry, uint16* entryIndex )
   \                     ZDSecMgrEntryLookupExtGetIndex:
    546          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   \   00000E   740C         MOV     A,#0xc
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F5..         MOV     ?V0 + 0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 1,A
    547            uint16 ami;
    548            uint16 index;
    549          
    550            // lookup address index
    551            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   00001A                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00001A   85..82       MOV     DPL,?XSP + 0
   \   00001D   85..83       MOV     DPH,?XSP + 1
   \   000020   AC82         MOV     R4,DPL
   \   000022   AD83         MOV     R5,DPH
   \   000024   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   000027   E9           MOV     A,R1
   \   000028   7036         JNZ     ??ZDSecMgrEntryLookupExtGetIndex_0
    552            {
    553              // verify data is available
    554              if ( ZDSecMgrEntries != NULL )
   \   00002A   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00002D   12....       LCALL   ??Subroutine69_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_153:
   \   000030   602E         JZ      ??ZDSecMgrEntryLookupExtGetIndex_0
    555              {
    556                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000032   7800         MOV     R0,#0x0
   \   000034   7900         MOV     R1,#0x0
    557                {
    558                  if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupExtGetIndex_1:
   \   000036   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   FC           MOV     R4,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   FD           MOV     R5,A
   \   00003E   85..82       MOV     DPL,?XSP + 0
   \   000041   85..83       MOV     DPH,?XSP + 1
   \   000044   E0           MOVX    A,@DPTR
   \   000045   6C           XRL     A,R4
   \   000046   7003         JNZ     ??ZDSecMgrEntryLookupExtGetIndex_2
   \   000048   A3           INC     DPTR
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   6D           XRL     A,R5
   \                     ??ZDSecMgrEntryLookupExtGetIndex_2:
   \   00004B   700E         JNZ     ??ZDSecMgrEntryLookupExtGetIndex_3
    559                  {
    560                    // return successful results
    561                    *entry = &ZDSecMgrEntries[index];
   \   00004D   12....       LCALL   ?Subroutine42 & 0xFFFF
    562                    *entryIndex = index;
   \                     ??CrossCallReturnLabel_115:
   \   000050   85..82       MOV     DPL,?V0 + 0
   \   000053   85..83       MOV     DPH,?V0 + 1
   \   000056   12....       LCALL   ??Subroutine54_0 & 0xFFFF
    563          
    564                    // break from loop
    565                    return ZSuccess;
    566                  }
    567                }
   \                     ??CrossCallReturnLabel_75:
   \   000059   8007         SJMP    ??ZDSecMgrEntryLookupExtGetIndex_4
   \                     ??ZDSecMgrEntryLookupExtGetIndex_3:
   \   00005B   12....       LCALL   ?Subroutine32 & 0xFFFF
    568              }
    569            }
   \                     ??CrossCallReturnLabel_32:
   \   00005E   40D6         JC      ??ZDSecMgrEntryLookupExtGetIndex_1
    570          
    571            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookupExtGetIndex_0:
   \   000060   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryLookupExtGetIndex_4:
   \   000062   02....       LJMP    ?Subroutine1 & 0xFFFF
    572          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004                REQUIRE ??Subroutine62_0
   \   000004                ; // Fall through to label ??Subroutine62_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   7402         MOV     A,#0x2
   \   000002                REQUIRE ??Subroutine72_0
   \   000002                ; // Fall through to label ??Subroutine72_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine72_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine73_0
   \   000003                ; // Fall through to label ??Subroutine73_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine73_0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    573          
    574          /******************************************************************************
    575           * @fn          ZDSecMgrEntryLookupAMIGetIndex
    576           *
    577           * @brief       Lookup entry using specified address index
    578           *
    579           * @param       ami   - [in] Address Manager index
    580           * @param       entryIndex - [out] valid index to the entry table
    581           *
    582           * @return      ZStatus_t
    583           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    584          ZStatus_t ZDSecMgrEntryLookupAMIGetIndex( uint16 ami, uint16* entryIndex )
   \                     ZDSecMgrEntryLookupAMIGetIndex:
    585          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    586            uint16 index;
    587          
    588            // verify data is available
    589            if ( ZDSecMgrEntries != NULL )
   \   000005   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000008   12....       LCALL   ??Subroutine69_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_154:
   \   00000B   6028         JZ      ??ZDSecMgrEntryLookupAMIGetIndex_0
    590            {
    591              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00000D   7800         MOV     R0,#0x0
   \   00000F   7900         MOV     R1,#0x0
    592              {
    593                if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_1:
   \   000011   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   000014   F5..         MOV     ?V0 + 0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   3F           ADDC    A,R7
   \   000019   85..82       MOV     DPL,?V0 + 0
   \   00001C   F583         MOV     DPH,A
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   6A           XRL     A,R2
   \   000020   7003         JNZ     ??ZDSecMgrEntryLookupAMIGetIndex_2
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   6B           XRL     A,R3
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_2:
   \   000025   7009         JNZ     ??ZDSecMgrEntryLookupAMIGetIndex_3
    594                {
    595                  // return successful results
    596                  *entryIndex = index;
   \   000027   8C82         MOV     DPL,R4
   \   000029   8D83         MOV     DPH,R5
   \   00002B   12....       LCALL   ??Subroutine54_0 & 0xFFFF
    597          
    598                  // break from loop
    599                  return ZSuccess;
    600                }
    601              }
   \                     ??CrossCallReturnLabel_76:
   \   00002E   8007         SJMP    ??ZDSecMgrEntryLookupAMIGetIndex_4
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_3:
   \   000030   12....       LCALL   ?Subroutine32 & 0xFFFF
    602            }
   \                     ??CrossCallReturnLabel_33:
   \   000033   40DC         JC      ??ZDSecMgrEntryLookupAMIGetIndex_1
    603          
    604            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_0:
   \   000035   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_4:
   \   000037   02....       LJMP    ??Subroutine68_0 & 0xFFFF
    605          }
    606          
    607          /******************************************************************************
    608           * @fn          ZDSecMgrEntryFree
    609           *
    610           * @brief       Free entry.
    611           *
    612           * @param       entry - [in] valid entry
    613           *
    614           * @return      ZStatus_t
    615           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    616          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrEntryFree:
    617          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    618            APSME_LinkKeyData_t   *pApsLinkKey = NULL;
    619          
    620          #if defined ( NV_RESTORE )
    621            ZStatus_t status;
    622            uint16 entryIndex;
    623          
    624            status = ZDSecMgrEntryLookupAMIGetIndex( entry->ami, &entryIndex );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupAMIGetIndex
   \   00000E   7402         MOV     A,#0x2
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   AC82         MOV     R4,DPL
   \   000015   AD83         MOV     R5,DPH
   \   000017   8E82         MOV     DPL,R6
   \   000019   8F83         MOV     DPH,R7
   \   00001B   12....       LCALL   ??Subroutine59_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   00001E   12....       LCALL   ??ZDSecMgrEntryLookupAMIGetIndex?relay
   \   000021   E9           MOV     A,R1
   \   000022   F5..         MOV     ?V0 + 4,A
    625          #endif
    626          
    627            pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000024                ; Setup parameters for call to function osal_mem_alloc
   \   000024   7A18         MOV     R2,#0x18
   \   000026   7B00         MOV     R3,#0x0
   \   000028   12....       LCALL   ??osal_mem_alloc?relay
   \   00002B   8A..         MOV     ?V0 + 2,R2
   \   00002D   8B..         MOV     ?V0 + 3,R3
    628          
    629            if (pApsLinkKey != NULL)
   \   00002F   EA           MOV     A,R2
   \   000030   45..         ORL     A,?V0 + 3
   \   000032   6041         JZ      ??ZDSecMgrEntryFree_0
    630            {
    631              osal_memset( pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   000034                ; Setup parameters for call to function osal_memset
   \   000034   7C18         MOV     R4,#0x18
   \   000036   7D00         MOV     R5,#0x0
   \   000038   7900         MOV     R1,#0x0
   \   00003A   12....       LCALL   ??osal_memset?relay
    632          
    633              // Clear the APS Link key in NV
    634              osal_nv_write( entry->keyNvId, 0,
    635                                  sizeof(APSME_LinkKeyData_t), pApsLinkKey);
   \   00003D   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   000040                ; Setup parameters for call to function osal_nv_write
   \   000040   78..         MOV     R0,#?V0 + 2
   \   000042   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000045   75..18       MOV     ?V0 + 6,#0x18
   \   000048   75..00       MOV     ?V0 + 7,#0x0
   \   00004B   78..         MOV     R0,#?V0 + 6
   \   00004D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000050   7C00         MOV     R4,#0x0
   \   000052   7D00         MOV     R5,#0x0
   \   000054   85..82       MOV     DPL,?V0 + 0
   \   000057   8983         MOV     DPH,R1
   \   000059   12....       LCALL   ??Subroutine59_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   00005C   12....       LCALL   ??osal_nv_write?relay
   \   00005F   7404         MOV     A,#0x4
   \   000061   12....       LCALL   ?DEALLOC_XSTACK8
    636          
    637              // set entry to invalid Key
    638              entry->keyNvId = SEC_NO_KEY_NV_ID;
   \   000064   85..82       MOV     DPL,?V0 + 0
   \   000067   85..83       MOV     DPH,?V0 + 1
   \   00006A   E4           CLR     A
   \   00006B   F0           MOVX    @DPTR,A
   \   00006C   A3           INC     DPTR
   \   00006D   F0           MOVX    @DPTR,A
    639          
    640              osal_mem_free(pApsLinkKey);
   \   00006E                ; Setup parameters for call to function osal_mem_free
   \   00006E   AA..         MOV     R2,?V0 + 2
   \   000070   AB..         MOV     R3,?V0 + 3
   \   000072   12....       LCALL   ??osal_mem_free?relay
    641            }
    642          
    643            // marking the entry as INVALID_NODE_ADDR
    644            entry->ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryFree_0:
   \   000075   8E82         MOV     DPL,R6
   \   000077   8F83         MOV     DPH,R7
   \   000079   74FE         MOV     A,#-0x2
   \   00007B   F0           MOVX    @DPTR,A
   \   00007C   A3           INC     DPTR
   \   00007D   04           INC     A
   \   00007E   F0           MOVX    @DPTR,A
    645          
    646            // set to default value
    647            entry->authenticateOption = ZDSecMgr_Not_Authenticated;
   \   00007F   8E82         MOV     DPL,R6
   \   000081   8F83         MOV     DPH,R7
   \   000083   A3           INC     DPTR
   \   000084   A3           INC     DPTR
   \   000085   A3           INC     DPTR
   \   000086   A3           INC     DPTR
   \   000087   E4           CLR     A
   \   000088   F0           MOVX    @DPTR,A
    648          
    649          #if defined ( NV_RESTORE )
    650            if ( status == ZSuccess )
   \   000089   E5..         MOV     A,?V0 + 4
   \   00008B   6003         JZ      $+5
   \   00008D   02....       LJMP    ??ZDSecMgrEntryFree_1 & 0xFFFF
    651            {
    652              ZDSecMgrUpdateNV(entryIndex);
   \   000090   7402         MOV     A,#0x2
   \   000092   12....       LCALL   ?XSTACK_DISP0_8
   \   000095   12....       LCALL   ??Subroutine59_0 & 0xFFFF
    653            }
   \                     ??CrossCallReturnLabel_92:
   \   000098   EA           MOV     A,R2
   \   000099   FE           MOV     R6,A
   \   00009A   EB           MOV     A,R3
   \   00009B   FF           MOV     R7,A
   \   00009C   EE           MOV     A,R6
   \   00009D   75F005       MOV     B,#0x5
   \   0000A0   A4           MUL     AB
   \   0000A1   FE           MOV     R6,A
   \   0000A2   A8F0         MOV     R0,B
   \   0000A4   75F005       MOV     B,#0x5
   \   0000A7   EF           MOV     A,R7
   \   0000A8   A4           MUL     AB
   \   0000A9   28           ADD     A,R0
   \   0000AA   FF           MOV     R7,A
   \   0000AB   90....       MOV     DPTR,#ZDSecMgrEntries
   \   0000AE   12....       LCALL   ??Subroutine69_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_155:
   \   0000B1   603B         JZ      ??ZDSecMgrEntryFree_2
   \   0000B3                ; Setup parameters for call to function osal_nv_write
   \   0000B3   90....       MOV     DPTR,#ZDSecMgrEntries
   \   0000B6   E0           MOVX    A,@DPTR
   \   0000B7   2E           ADD     A,R6
   \   0000B8   F5..         MOV     ?V0 + 0,A
   \   0000BA   A3           INC     DPTR
   \   0000BB   E0           MOVX    A,@DPTR
   \   0000BC   3F           ADDC    A,R7
   \   0000BD   F5..         MOV     ?V0 + 1,A
   \   0000BF   78..         MOV     R0,#?V0 + 0
   \   0000C1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C4   75..05       MOV     ?V0 + 0,#0x5
   \   0000C7   75..00       MOV     ?V0 + 1,#0x0
   \   0000CA   78..         MOV     R0,#?V0 + 0
   \   0000CC   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000CF   EA           MOV     A,R2
   \   0000D0   75F005       MOV     B,#0x5
   \   0000D3   A4           MUL     AB
   \   0000D4   FA           MOV     R2,A
   \   0000D5   A8F0         MOV     R0,B
   \   0000D7   75F005       MOV     B,#0x5
   \   0000DA   EB           MOV     A,R3
   \   0000DB   A4           MUL     AB
   \   0000DC   28           ADD     A,R0
   \   0000DD   FB           MOV     R3,A
   \   0000DE   EA           MOV     A,R2
   \   0000DF   2402         ADD     A,#0x2
   \   0000E1   FC           MOV     R4,A
   \   0000E2   EB           MOV     A,R3
   \   0000E3   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   0000E6   12....       LCALL   ??osal_nv_write?relay
   \   0000E9   7404         MOV     A,#0x4
   \   0000EB   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??ZDSecMgrEntryFree_2:
   \   0000EE                ; Setup parameters for call to function osal_nv_read
   \   0000EE   85..82       MOV     DPL,?XSP + 0
   \   0000F1   85..83       MOV     DPH,?XSP + 1
   \   0000F4   8582..       MOV     ?V0 + 0,DPL
   \   0000F7   8583..       MOV     ?V0 + 1,DPH
   \   0000FA   78..         MOV     R0,#?V0 + 0
   \   0000FC   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000FF   75..02       MOV     ?V0 + 0,#0x2
   \   000102   75..00       MOV     ?V0 + 1,#0x0
   \   000105   78..         MOV     R0,#?V0 + 0
   \   000107   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00010A   7C00         MOV     R4,#0x0
   \   00010C   7D00         MOV     R5,#0x0
   \   00010E   7A4C         MOV     R2,#0x4c
   \   000110   7B00         MOV     R3,#0x0
   \   000112   12....       LCALL   ??osal_nv_read?relay
   \   000115   7404         MOV     A,#0x4
   \   000117   12....       LCALL   ?DEALLOC_XSTACK8
   \   00011A   E9           MOV     A,R1
   \   00011B   7058         JNZ     ??ZDSecMgrEntryFree_1
   \   00011D   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   000120   E0           MOVX    A,@DPTR
   \   000121   64FE         XRL     A,#0xfe
   \   000123   7003         JNZ     ??ZDSecMgrEntryFree_3
   \   000125   A3           INC     DPTR
   \   000126   E0           MOVX    A,@DPTR
   \   000127   F4           CPL     A
   \                     ??ZDSecMgrEntryFree_3:
   \   000128   85..82       MOV     DPL,?XSP + 0
   \   00012B   85..83       MOV     DPH,?XSP + 1
   \   00012E   7015         JNZ     ??ZDSecMgrEntryFree_4
   \   000130   12....       LCALL   ??Subroutine69_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_156:
   \   000133   6014         JZ      ??ZDSecMgrEntryFree_5
   \   000135   85..82       MOV     DPL,?XSP + 0
   \   000138   85..83       MOV     DPH,?XSP + 1
   \   00013B   E0           MOVX    A,@DPTR
   \   00013C   24FF         ADD     A,#-0x1
   \   00013E   F0           MOVX    @DPTR,A
   \   00013F   A3           INC     DPTR
   \   000140   E0           MOVX    A,@DPTR
   \   000141   34FF         ADDC    A,#-0x1
   \   000143   8003         SJMP    ??CrossCallReturnLabel_27
   \                     ??ZDSecMgrEntryFree_4:
   \   000145   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   000148   F0           MOVX    @DPTR,A
   \                     ??ZDSecMgrEntryFree_5:
   \   000149                ; Setup parameters for call to function osal_nv_write
   \   000149   85..82       MOV     DPL,?XSP + 0
   \   00014C   85..83       MOV     DPH,?XSP + 1
   \   00014F   8582..       MOV     ?V0 + 0,DPL
   \   000152   8583..       MOV     ?V0 + 1,DPH
   \   000155   78..         MOV     R0,#?V0 + 0
   \   000157   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00015A   75..02       MOV     ?V0 + 0,#0x2
   \   00015D   75..00       MOV     ?V0 + 1,#0x0
   \   000160   78..         MOV     R0,#?V0 + 0
   \   000162   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000165   7C00         MOV     R4,#0x0
   \   000167   7D00         MOV     R5,#0x0
   \   000169   7A4C         MOV     R2,#0x4c
   \   00016B   7B00         MOV     R3,#0x0
   \   00016D   12....       LCALL   ??osal_nv_write?relay
   \   000170   7404         MOV     A,#0x4
   \   000172   12....       LCALL   ?DEALLOC_XSTACK8
    654          #endif
    655          }
   \                     ??ZDSecMgrEntryFree_1:
   \   000175   7404         MOV     A,#0x4
   \   000177                REQUIRE ?Subroutine2
   \   000177                ; // Fall through to label ?Subroutine2

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F08         MOV     R7,#0x8
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   EE           MOV     A,R6
   \   000001   2402         ADD     A,#0x2
   \   000003   F8           MOV     R0,A
   \   000004   EF           MOV     A,R7
   \   000005                REQUIRE ??Subroutine56_0
   \   000005                ; // Fall through to label ??Subroutine56_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine56_0:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F9           MOV     R1,A
   \   000003   88..         MOV     ?V0 + 0,R0
   \   000005   89..         MOV     ?V0 + 1,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2401         ADD     A,#0x1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   3400         ADDC    A,#0x0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000003   E0           MOVX    A,@DPTR
   \   000004   2E           ADD     A,R6
   \   000005   F8           MOV     R0,A
   \   000006   A3           INC     DPTR
   \   000007   E0           MOVX    A,@DPTR
   \   000008   3F           ADDC    A,R7
   \   000009   8882         MOV     DPL,R0
   \   00000B   F583         MOV     DPH,A
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   3400         ADDC    A,#0x0
   \   000002   FD           MOV     R5,A
   \   000003   7A4C         MOV     R2,#0x4c
   \   000005   7B00         MOV     R3,#0x0
   \   000007   22           RET
    656          
    657          /******************************************************************************
    658           * @fn          ZDSecMgrEntryNew
    659           *
    660           * @brief       Get a new entry.
    661           *
    662           * @param       entry - [out] valid entry
    663           *
    664           * @return      ZStatus_t
    665           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    666          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryNew:
    667          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    668            uint16 index;
    669          
    670            // initialize results
    671            *entry = NULL;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   12....       LCALL   ?Subroutine11 & 0xFFFF
    672          
    673            // verify data is available
    674            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_79:
   \   00000C   6063         JZ      ??ZDSecMgrEntryNew_0
    675            {
    676              // find available entry
    677              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00000E   7C00         MOV     R4,#0x0
   \   000010   7D00         MOV     R5,#0x0
    678              {
    679                if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   \                     ??ZDSecMgrEntryNew_1:
   \   000012   EC           MOV     A,R4
   \   000013   F8           MOV     R0,A
   \   000014   ED           MOV     A,R5
   \   000015   F9           MOV     R1,A
   \   000016   E8           MOV     A,R0
   \   000017   75F005       MOV     B,#0x5
   \   00001A   A4           MUL     AB
   \   00001B   F8           MOV     R0,A
   \   00001C   AEF0         MOV     R6,B
   \   00001E   75F005       MOV     B,#0x5
   \   000021   E9           MOV     A,R1
   \   000022   A4           MUL     AB
   \   000023   2E           ADD     A,R6
   \   000024   F9           MOV     R1,A
   \   000025   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000028   E0           MOVX    A,@DPTR
   \   000029   28           ADD     A,R0
   \   00002A   FE           MOV     R6,A
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   39           ADDC    A,R1
   \   00002E   FF           MOV     R7,A
   \   00002F   8E82         MOV     DPL,R6
   \   000031   8F83         MOV     DPH,R7
   \   000033   E0           MOVX    A,@DPTR
   \   000034   64FE         XRL     A,#0xfe
   \   000036   7003         JNZ     ??ZDSecMgrEntryNew_2
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   F4           CPL     A
   \                     ??ZDSecMgrEntryNew_2:
   \   00003B   7023         JNZ     ??ZDSecMgrEntryNew_3
    680                {
    681                  // return successful result
    682                  *entry = &ZDSecMgrEntries[index];
   \   00003D   EE           MOV     A,R6
   \   00003E   FC           MOV     R4,A
   \   00003F   EF           MOV     A,R7
   \   000040   FD           MOV     R5,A
   \   000041   8A82         MOV     DPL,R2
   \   000043   8B83         MOV     DPH,R3
   \   000045   EC           MOV     A,R4
   \   000046   F0           MOVX    @DPTR,A
   \   000047   A3           INC     DPTR
   \   000048   ED           MOV     A,R5
   \   000049   F0           MOVX    @DPTR,A
    683          
    684                  // Set the authentication option to default
    685                  ZDSecMgrEntries[index].authenticateOption = ZDSecMgr_Not_Authenticated;
   \   00004A   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   28           ADD     A,R0
   \   00004F   FA           MOV     R2,A
   \   000050   A3           INC     DPTR
   \   000051   E0           MOVX    A,@DPTR
   \   000052   39           ADDC    A,R1
   \   000053   8A82         MOV     DPL,R2
   \   000055   F583         MOV     DPH,A
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   E4           CLR     A
   \   00005C   F0           MOVX    @DPTR,A
    686          
    687                  // break from loop
    688                  return ZSuccess;
   \   00005D   F9           MOV     R1,A
   \   00005E   8013         SJMP    ??ZDSecMgrEntryNew_4
    689                }
    690              }
   \                     ??ZDSecMgrEntryNew_3:
   \   000060   EC           MOV     A,R4
   \   000061   2401         ADD     A,#0x1
   \   000063   0C           INC     R4
   \   000064   ED           MOV     A,R5
   \   000065   3400         ADDC    A,#0x0
   \   000067   FD           MOV     R5,A
   \   000068   C3           CLR     C
   \   000069   EC           MOV     A,R4
   \   00006A   9403         SUBB    A,#0x3
   \   00006C   ED           MOV     A,R5
   \   00006D   9400         SUBB    A,#0x0
   \   00006F   40A1         JC      ??ZDSecMgrEntryNew_1
    691            }
    692          
    693            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryNew_0:
   \   000071   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryNew_4:
   \   000073   02....       LJMP    ??Subroutine68_0 & 0xFFFF
    694          }
    695          
    696          /******************************************************************************
    697           * @fn          ZDSecMgrAppKeyGet
    698           *
    699           * @brief       get an APP key - option APP(MASTER or LINK) key
    700           *
    701           * @param       initNwkAddr - [in] NWK address of initiator device
    702           * @param       initExtAddr - [in] EXT address of initiator device
    703           * @param       partNwkAddr - [in] NWK address of partner device
    704           * @param       partExtAddr - [in] EXT address of partner device
    705           * @param       key         - [out] APP(MASTER or LINK) key
    706           * @param       keyType     - [out] APP(MASTER or LINK) key type
    707           *
    708           * @return      ZStatus_t
    709           */

   \                                 In  segment XDATA_I, align 1, keep-with-next
    710          uint8 ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;    // Set the default key type
   \                     ZDSecMgrAppKeyType:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for ZDSecMgrAppKeyType>`
   \   000001                REQUIRE __INIT_XDATA_I
    711                                                           // to KEY_TYPE_APP_LINK since
    712                                                           // only specific requirement
    713                                                           // right now comes from SE profile
    714          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    715          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
   \                     ZDSecMgrAppKeyGet:
    716                                       uint8*  initExtAddr,
    717                                       uint16  partNwkAddr,
    718                                       uint8*  partExtAddr,
    719                                       uint8** key,
    720                                       uint8*  keyType )
    721          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   740D         MOV     A,#0xd
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   00000D   FA           MOV     R2,A
   \   00000E   E9           MOV     A,R1
   \   00000F   FB           MOV     R3,A
   \   000010   740F         MOV     A,#0xf
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   000018   FE           MOV     R6,A
   \   000019   E9           MOV     A,R1
   \   00001A   FF           MOV     R7,A
    722            // Intentionally unreferenced parameters
    723            (void)initNwkAddr;
    724            (void)initExtAddr;
    725            (void)partNwkAddr;
    726            (void)partExtAddr;
    727          
    728            //---------------------------------------------------------------------------
    729            // note:
    730            // should use a robust mechanism to generate keys, for example
    731            // combine EXT addresses and call a hash function
    732            //---------------------------------------------------------------------------
    733            SSP_GetTrueRand( SEC_KEY_LEN, *key );
   \   00001B                ; Setup parameters for call to function SSP_GetTrueRand
   \   00001B   8A82         MOV     DPL,R2
   \   00001D   8B83         MOV     DPH,R3
   \   00001F   12....       LCALL   ??Subroutine59_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   000022   7910         MOV     R1,#0x10
   \   000024   12....       LCALL   ??SSP_GetTrueRand?relay
    734          
    735            *keyType = ZDSecMgrAppKeyType;
   \   000027   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   8E82         MOV     DPL,R6
   \   00002D   8F83         MOV     DPH,R7
   \   00002F   F0           MOVX    @DPTR,A
    736          
    737            return ZSuccess;
   \   000030   7900         MOV     R1,#0x0
   \   000032   02....       LJMP    ??Subroutine68_0 & 0xFFFF
    738          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_164:
   \   000003   22           RET
    739          
    740          /******************************************************************************
    741           * @fn          ZDSecMgrAppKeyReq
    742           *
    743           * @brief       Process request for APP key between two devices.
    744           *
    745           * @param       device - [in] ZDO_RequestKeyInd_t, request info
    746           *
    747           * @return      none
    748           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    749          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrAppKeyReq:
    750          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 39
   \   000005   74D9         MOV     A,#-0x27
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
    751            APSME_TransportKeyReq_t req;
    752            uint8                   initExtAddr[Z_EXTADDR_LEN];
    753            uint16                  partNwkAddr;
    754            uint8                   key[SEC_KEY_LEN];
    755          
    756          
    757            // validate initiator and partner
    758            if ( ( APSME_LookupNwkAddr( ind->partExtAddr, &partNwkAddr ) == TRUE ) &&
    759                 ( APSME_LookupExtAddr( ind->srcAddr, initExtAddr ) == TRUE      )   )
   \   00000E   EA           MOV     A,R2
   \   00000F   2405         ADD     A,#0x5
   \   000011   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000014   12....       LCALL   ??APSME_LookupNwkAddr?relay
   \   000017   E9           MOV     A,R1
   \   000018   6401         XRL     A,#0x1
   \   00001A   6003         JZ      $+5
   \   00001C   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   \   00001F   E5..         MOV     A,?V0 + 0
   \   000021   2402         ADD     A,#0x2
   \   000023   F8           MOV     R0,A
   \   000024   E5..         MOV     A,?V0 + 1
   \   000026   12....       LCALL   ??Subroutine56_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   000029                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000029   740F         MOV     A,#0xf
   \   00002B   12....       LCALL   ?XSTACK_DISP0_8
   \   00002E   AC82         MOV     R4,DPL
   \   000030   AD83         MOV     R5,DPH
   \   000032   8882         MOV     DPL,R0
   \   000034   8983         MOV     DPH,R1
   \   000036   12....       LCALL   ??Subroutine59_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   000039   12....       LCALL   ??APSME_LookupExtAddr?relay
   \   00003C   E9           MOV     A,R1
   \   00003D   6401         XRL     A,#0x1
   \   00003F   6003         JZ      $+5
   \   000041   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
    760            {
    761              // point the key to some memory
    762              req.key = key;
   \   000044   7417         MOV     A,#0x17
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   A882         MOV     R0,DPL
   \   00004B   A983         MOV     R1,DPH
   \   00004D   7406         MOV     A,#0x6
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   12....       LCALL   ??Subroutine63_0 & 0xFFFF
    763          
    764              // get an APP key - option APP (MASTER or LINK) key
    765              if ( ZDSecMgrAppKeyGet( ind->srcAddr,
    766                                      initExtAddr,
    767                                      partNwkAddr,
    768                                      ind->partExtAddr,
    769                                      &req.key,
    770                                      &req.keyType ) == ZSuccess )
   \                     ??CrossCallReturnLabel_120:
   \   000055                ; Setup parameters for call to function SSP_GetTrueRand
   \   000055   7417         MOV     A,#0x17
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   AA82         MOV     R2,DPL
   \   00005C   AB83         MOV     R3,DPH
   \   00005E   7910         MOV     R1,#0x10
   \   000060   12....       LCALL   ??SSP_GetTrueRand?relay
   \   000063   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   000066   E0           MOVX    A,@DPTR
   \   000067   C0E0         PUSH    A
   \   000069   7404         MOV     A,#0x4
   \   00006B   12....       LCALL   ?XSTACK_DISP0_8
   \   00006E   D0E0         POP     A
   \   000070   F0           MOVX    @DPTR,A
    771              {
    772                // always secure
    773                req.nwkSecure = TRUE;
   \   000071   740C         MOV     A,#0xc
   \   000073   12....       LCALL   ?XSTACK_DISP0_8
   \   000076   7401         MOV     A,#0x1
   \   000078   F0           MOVX    @DPTR,A
    774                req.apsSecure = TRUE;
   \   000079   740B         MOV     A,#0xb
   \   00007B   12....       LCALL   ?XSTACK_DISP0_8
   \   00007E   7401         MOV     A,#0x1
   \   000080   F0           MOVX    @DPTR,A
    775                req.tunnel    = NULL;
   \   000081   740D         MOV     A,#0xd
   \   000083   12....       LCALL   ?XSTACK_DISP0_8
   \   000086   E4           CLR     A
   \   000087   F0           MOVX    @DPTR,A
   \   000088   A3           INC     DPTR
   \   000089   12....       LCALL   ?Subroutine16 & 0xFFFF
    776          
    777                // send key to initiator device
    778                req.dstAddr   = ind->srcAddr;
   \                     ??CrossCallReturnLabel_4:
   \   00008C   12....       LCALL   ?XSTACK_DISP0_8
   \   00008F   12....       LCALL   ??Subroutine63_0 & 0xFFFF
    779                req.extAddr   = ind->partExtAddr;
   \                     ??CrossCallReturnLabel_121:
   \   000092   7408         MOV     A,#0x8
   \   000094   12....       LCALL   ?XSTACK_DISP0_8
   \   000097   EE           MOV     A,R6
   \   000098   F0           MOVX    @DPTR,A
   \   000099   A3           INC     DPTR
   \   00009A   EF           MOV     A,R7
   \   00009B   F0           MOVX    @DPTR,A
    780                req.initiator = TRUE;
   \   00009C   740A         MOV     A,#0xa
   \   00009E   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A1   7401         MOV     A,#0x1
   \   0000A3   F0           MOVX    @DPTR,A
    781                APSME_TransportKeyReq( &req );
   \   0000A4                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000A4   04           INC     A
   \   0000A5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A8   AA82         MOV     R2,DPL
   \   0000AA   AB83         MOV     R3,DPH
   \   0000AC   12....       LCALL   ??APSME_TransportKeyReq?relay
    782          
    783                // send key to partner device
    784                req.dstAddr   = partNwkAddr;
   \   0000AF   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_173:
   \   0000B2   7402         MOV     A,#0x2
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   12....       LCALL   ??Subroutine63_0 & 0xFFFF
    785                req.extAddr   = initExtAddr;
   \                     ??CrossCallReturnLabel_122:
   \   0000BA   740F         MOV     A,#0xf
   \   0000BC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BF   A882         MOV     R0,DPL
   \   0000C1   A983         MOV     R1,DPH
   \   0000C3   7408         MOV     A,#0x8
   \   0000C5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C8   12....       LCALL   ??Subroutine63_0 & 0xFFFF
    786                req.initiator = FALSE;
   \                     ??CrossCallReturnLabel_123:
   \   0000CB   740A         MOV     A,#0xa
   \   0000CD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D0   E4           CLR     A
   \   0000D1   F0           MOVX    @DPTR,A
    787          
    788                APSME_TransportKeyReq( &req );
   \   0000D2                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000D2   7402         MOV     A,#0x2
   \   0000D4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D7   AA82         MOV     R2,DPL
   \   0000D9   AB83         MOV     R3,DPH
   \   0000DB   12....       LCALL   ??APSME_TransportKeyReq?relay
    789          
    790                // clear copy of key in RAM
    791                osal_memset( key, 0x00, SEC_KEY_LEN);
   \   0000DE                ; Setup parameters for call to function osal_memset
   \   0000DE   7C10         MOV     R4,#0x10
   \   0000E0   7D00         MOV     R5,#0x0
   \   0000E2   7900         MOV     R1,#0x0
   \   0000E4   7417         MOV     A,#0x17
   \   0000E6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E9   AA82         MOV     R2,DPL
   \   0000EB   AB83         MOV     R3,DPH
   \   0000ED   12....       LCALL   ??osal_memset?relay
    792          
    793              }
    794            }
    795          }
   \                     ??ZDSecMgrAppKeyReq_0:
   \   0000F0   7427         MOV     A,#0x27
   \   0000F2   02....       LJMP    ??Subroutine72_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V0 + 0
   \   000004   85..83       MOV     DPH,?V0 + 1
   \   000007   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_175:
   \   00000A   7402         MOV     A,#0x2
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   FE           MOV     R6,A
   \   000001   EB           MOV     A,R3
   \   000002   3400         ADDC    A,#0x0
   \   000004   FF           MOV     R7,A
   \   000005                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   000005                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   000005   85..82       MOV     DPL,?XSP + 0
   \   000008   85..83       MOV     DPH,?XSP + 1
   \   00000B   AC82         MOV     R4,DPL
   \   00000D   AD83         MOV     R5,DPH
   \   00000F   EE           MOV     A,R6
   \   000010   FA           MOV     R2,A
   \   000011   EF           MOV     A,R7
   \   000012   FB           MOV     R3,A
   \   000013   22           RET
    796          
    797          /******************************************************************************
    798           * @fn          ZDSecMgrSendNwkKey
    799           *
    800           * @brief       Send NWK key to device joining network.
    801           *
    802           * @param       device - [in] ZDSecMgrDevice_t, device info
    803           *
    804           * @return      ZStatus_t
    805           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    806          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendNwkKey:
    807          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 34
   \   000005   74DE         MOV     A,#-0x22
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    808            ZStatus_t status;
    809            APSME_TransportKeyReq_t req;
    810            APSDE_FrameTunnel_t tunnel;
    811            nwkKeyDesc tmpKey;
    812          
    813            req.dstAddr   = device->nwkAddr;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   12....       LCALL   ??Subroutine70_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_167:
   \   000015   7404         MOV     A,#0x4
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ??Subroutine63_0 & 0xFFFF
    814            req.extAddr   = device->extAddr;
   \                     ??CrossCallReturnLabel_124:
   \   00001D   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   000020   8882         MOV     DPL,R0
   \   000022   F583         MOV     DPH,A
   \   000024   12....       LCALL   ??Subroutine70_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_168:
   \   000027   740A         MOV     A,#0xa
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   12....       LCALL   ??Subroutine63_0 & 0xFFFF
    815          
    816            req.keyType   = KEY_TYPE_NWK;
   \                     ??CrossCallReturnLabel_125:
   \   00002F   7406         MOV     A,#0x6
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   7401         MOV     A,#0x1
   \   000036   F0           MOVX    @DPTR,A
    817          
    818            // get the Active Key into a local variable
    819            if ( NLME_ReadNwkKeyInfo( 0, sizeof(tmpKey), &tmpKey,
    820                                     ZCD_NV_NWK_ACTIVE_KEY_INFO ) != SUCCESS )
   \   000037                ; Setup parameters for call to function NLME_ReadNwkKeyInfo
   \   000037   75..3A       MOV     ?V0 + 2,#0x3a
   \   00003A   75..00       MOV     ?V0 + 3,#0x0
   \   00003D   78..         MOV     R0,#?V0 + 2
   \   00003F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000042   7413         MOV     A,#0x13
   \   000044   12....       LCALL   ?XSTACK_DISP0_8
   \   000047   8582..       MOV     ?V0 + 2,DPL
   \   00004A   8583..       MOV     ?V0 + 3,DPH
   \   00004D   78..         MOV     R0,#?V0 + 2
   \   00004F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000052   7C11         MOV     R4,#0x11
   \   000054   7D00         MOV     R5,#0x0
   \   000056   7A00         MOV     R2,#0x0
   \   000058   7B00         MOV     R3,#0x0
   \   00005A   12....       LCALL   ??NLME_ReadNwkKeyInfo?relay
   \   00005D   7404         MOV     A,#0x4
   \   00005F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000062   E9           MOV     A,R1
   \   000063   6011         JZ      ??ZDSecMgrSendNwkKey_0
    821            {
    822              // set key data to all 0s if NV read fails
    823              osal_memset(&tmpKey, 0x00, sizeof(tmpKey));
   \   000065                ; Setup parameters for call to function osal_memset
   \   000065   7C11         MOV     R4,#0x11
   \   000067   7D00         MOV     R5,#0x0
   \   000069   7900         MOV     R1,#0x0
   \   00006B   EC           MOV     A,R4
   \   00006C   12....       LCALL   ?XSTACK_DISP0_8
   \   00006F   AA82         MOV     R2,DPL
   \   000071   AB83         MOV     R3,DPH
   \   000073   12....       LCALL   ??osal_memset?relay
    824            }
    825          
    826            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
    827            {
    828              // set values
    829              req.keySeqNum = tmpKey.keySeqNum;
   \                     ??ZDSecMgrSendNwkKey_0:
   \   000076   7411         MOV     A,#0x11
   \   000078   12....       LCALL   ?XSTACK_DISP0_8
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   C0E0         PUSH    A
   \   00007E   7407         MOV     A,#0x7
   \   000080   12....       LCALL   ?XSTACK_DISP0_8
   \   000083   D0E0         POP     A
   \   000085   F0           MOVX    @DPTR,A
    830              req.key       = tmpKey.key;
   \   000086   7412         MOV     A,#0x12
   \   000088   12....       LCALL   ?XSTACK_DISP0_8
   \   00008B   A882         MOV     R0,DPL
   \   00008D   A983         MOV     R1,DPH
   \   00008F   7408         MOV     A,#0x8
   \   000091   12....       LCALL   ?XSTACK_DISP0_8
   \   000094   12....       LCALL   ??Subroutine63_0 & 0xFFFF
    831          
    832              //devtag.pro.security.todo - make sure that if there is no link key the NWK
    833              //key isn't used to secure the frame at the APS layer -- since the receiving
    834              //device may not have a NWK key yet
    835              req.apsSecure = TRUE;
   \                     ??CrossCallReturnLabel_126:
   \   000097   740D         MOV     A,#0xd
   \   000099   12....       LCALL   ?XSTACK_DISP0_8
   \   00009C   7401         MOV     A,#0x1
   \   00009E   F0           MOVX    @DPTR,A
    836          
    837              // check if using secure hop to parent
    838              if ( device->parentAddr == NLME_GetShortAddr() )
   \   00009F                ; Setup parameters for call to function NLME_GetShortAddr
   \   00009F   12....       LCALL   ??NLME_GetShortAddr?relay
   \   0000A2   EE           MOV     A,R6
   \   0000A3   2404         ADD     A,#0x4
   \   0000A5   F8           MOV     R0,A
   \   0000A6   EF           MOV     A,R7
   \   0000A7   3400         ADDC    A,#0x0
   \   0000A9   F9           MOV     R1,A
   \   0000AA   8882         MOV     DPL,R0
   \   0000AC   8983         MOV     DPH,R1
   \   0000AE   E0           MOVX    A,@DPTR
   \   0000AF   6A           XRL     A,R2
   \   0000B0   7003         JNZ     ??ZDSecMgrSendNwkKey_1
   \   0000B2   A3           INC     DPTR
   \   0000B3   E0           MOVX    A,@DPTR
   \   0000B4   6B           XRL     A,R3
   \                     ??ZDSecMgrSendNwkKey_1:
   \   0000B5   7011         JNZ     ??ZDSecMgrSendNwkKey_2
    839              {
    840                req.nwkSecure = FALSE;
   \   0000B7   740E         MOV     A,#0xe
   \   0000B9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BC   E4           CLR     A
   \   0000BD   F0           MOVX    @DPTR,A
    841                req.tunnel    = NULL;
   \   0000BE   740F         MOV     A,#0xf
   \   0000C0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C3   E4           CLR     A
   \   0000C4   F0           MOVX    @DPTR,A
   \   0000C5   A3           INC     DPTR
   \   0000C6   8026         SJMP    ??ZDSecMgrSendNwkKey_3
    842              }
    843              else
    844              {
    845                req.nwkSecure   = TRUE;
   \                     ??ZDSecMgrSendNwkKey_2:
   \   0000C8   740E         MOV     A,#0xe
   \   0000CA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CD   7401         MOV     A,#0x1
   \   0000CF   12....       LCALL   ??Subroutine64_0 & 0xFFFF
    846                req.tunnel      = &tunnel;
    847                req.tunnel->tna = device->parentAddr;
    848                req.tunnel->dea = device->extAddr;
    849              }
    850            }
   \                     ??CrossCallReturnLabel_140:
   \   0000D2   740F         MOV     A,#0xf
   \   0000D4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D7   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   0000DA   85..82       MOV     DPL,?XSP + 0
   \   0000DD   85..83       MOV     DPH,?XSP + 1
   \   0000E0   E8           MOV     A,R0
   \   0000E1   F0           MOVX    @DPTR,A
   \   0000E2   A3           INC     DPTR
   \   0000E3   E9           MOV     A,R1
   \   0000E4   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   0000E7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EA   E8           MOV     A,R0
   \   0000EB   F0           MOVX    @DPTR,A
   \   0000EC   A3           INC     DPTR
   \   0000ED   E9           MOV     A,R1
   \                     ??ZDSecMgrSendNwkKey_3:
   \   0000EE   F0           MOVX    @DPTR,A
    851            else
    852            {
    853              // default values
    854              //devtag.0604.verify
    855              req.nwkSecure = TRUE;
    856              req.apsSecure = FALSE;
    857              req.tunnel    = NULL;
    858          
    859              if ( device->parentAddr != NLME_GetShortAddr() )
    860              {
    861                req.dstAddr = device->parentAddr;
    862              }
    863          
    864              // send the real key
    865              if ( zgPreConfigKeys == FALSE )
    866              {
    867                req.keySeqNum = tmpKey.keySeqNum;
    868                req.key       = tmpKey.key;
    869          
    870                // check if using secure hop to to parent
    871                if ( device->parentAddr == NLME_GetShortAddr() )
    872                {
    873                  req.nwkSecure = FALSE;
    874                }
    875              }
    876              else
    877              {
    878                // this is to send the all zero key when the NWK key has been preconfigured
    879                req.key       = NULL;
    880                req.keySeqNum = 0;
    881              }
    882            }
    883          
    884            status = APSME_TransportKeyReq( &req );
   \   0000EF                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000EF   7404         MOV     A,#0x4
   \   0000F1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F4   AA82         MOV     R2,DPL
   \   0000F6   AB83         MOV     R3,DPH
   \   0000F8   12....       LCALL   ??APSME_TransportKeyReq?relay
   \   0000FB   E9           MOV     A,R1
   \   0000FC   FE           MOV     R6,A
    885          
    886            // clear copy of key in RAM before return
    887            osal_memset( &tmpKey, 0x00, sizeof(nwkKeyDesc) );
   \   0000FD                ; Setup parameters for call to function osal_memset
   \   0000FD   7C11         MOV     R4,#0x11
   \   0000FF   7D00         MOV     R5,#0x0
   \   000101   7900         MOV     R1,#0x0
   \   000103   EC           MOV     A,R4
   \   000104   12....       LCALL   ?XSTACK_DISP0_8
   \   000107   AA82         MOV     R2,DPL
   \   000109   AB83         MOV     R3,DPH
   \   00010B   12....       LCALL   ??osal_memset?relay
    888          
    889            return status;
   \   00010E   EE           MOV     A,R6
   \   00010F   F9           MOV     R1,A
   \   000110   7422         MOV     A,#0x22
   \   000112   02....       LJMP    ?Subroutine3 & 0xFFFF
    890          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   12....       LCALL   ??Subroutine62_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_113:
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_176:
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F04         MOV     R7,#0x4
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA
    891          
    892          /******************************************************************************
    893           * @fn          ZDSecMgrDeviceRemoveByExtAddr
    894           *
    895           * @brief       Remove device entry by its ext address.
    896           *
    897           * @param       pAddr - pointer to the extended address
    898           *
    899           * @return      ZStatus_t
    900           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    901          ZStatus_t ZDSecMgrDeviceRemoveByExtAddr( uint8 *pAddr )
   \                     ZDSecMgrDeviceRemoveByExtAddr:
    902          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    903            ZDSecMgrEntry_t *pEntry;
    904            uint8           retValue;
    905          
    906            retValue = (uint8)ZDSecMgrEntryLookupExt( pAddr, &pEntry );
   \   00000A                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   AC82         MOV     R4,DPL
   \   000012   AD83         MOV     R5,DPH
   \   000014   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   000017   E9           MOV     A,R1
   \   000018   FE           MOV     R6,A
    907          
    908            if( retValue == ZSuccess )
   \   000019   700C         JNZ     ??ZDSecMgrDeviceRemoveByExtAddr_0
    909            {
    910              // remove device from entry data
    911              ZDSecMgrEntryFree( pEntry );
   \   00001B                ; Setup parameters for call to function ZDSecMgrEntryFree
   \   00001B   85..82       MOV     DPL,?XSP + 0
   \   00001E   85..83       MOV     DPH,?XSP + 1
   \   000021   12....       LCALL   ??Subroutine59_0 & 0xFFFF
    912            }
   \                     ??CrossCallReturnLabel_95:
   \   000024   12....       LCALL   ??ZDSecMgrEntryFree?relay
    913          
    914            return retValue;
   \                     ??ZDSecMgrDeviceRemoveByExtAddr_0:
   \   000027   EE           MOV     A,R6
   \   000028   F9           MOV     R1,A
   \   000029   02....       LJMP    ?Subroutine7 & 0xFFFF
    915          }
    916          
    917          /******************************************************************************
    918           * @fn          ZDSecMgrDeviceRemove
    919           *
    920           * @brief       Remove device from network.
    921           *
    922           * @param       device - [in] ZDSecMgrDevice_t, device info
    923           *
    924           * @return      none
    925           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    926          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceRemove:
    927          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    928            APSME_RemoveDeviceReq_t remDevReq;
    929            NLME_LeaveReq_t         leaveReq;
    930            associated_devices_t*   assoc;
    931          
    932            // check if parent, remove the device
    933            if ( device->parentAddr == NLME_GetShortAddr() )
   \   00000E                ; Setup parameters for call to function NLME_GetShortAddr
   \   00000E   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000011   8A..         MOV     ?V0 + 0,R2
   \   000013   8B..         MOV     ?V0 + 1,R3
   \   000015   8E82         MOV     DPL,R6
   \   000017   8F83         MOV     DPH,R7
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   12....       LCALL   ??Subroutine58_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_105:
   \   00001E   EE           MOV     A,R6
   \   00001F   2402         ADD     A,#0x2
   \   000021   F8           MOV     R0,A
   \   000022   EF           MOV     A,R7
   \   000023   3400         ADDC    A,#0x0
   \   000025   F9           MOV     R1,A
   \   000026   E5..         MOV     A,?V0 + 0
   \   000028   6A           XRL     A,R2
   \   000029   7003         JNZ     ??ZDSecMgrDeviceRemove_0
   \   00002B   E5..         MOV     A,?V0 + 1
   \   00002D   6B           XRL     A,R3
   \                     ??ZDSecMgrDeviceRemove_0:
   \   00002E   6003         JZ      $+5
   \   000030   02....       LJMP    ??ZDSecMgrDeviceRemove_1 & 0xFFFF
    934            {
    935              // this is the parent of the device
    936              leaveReq.extAddr        = device->extAddr;
   \   000033   8882         MOV     DPL,R0
   \   000035   8983         MOV     DPH,R1
   \   000037   12....       LCALL   ??Subroutine59_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   00003A   12....       LCALL   ?Subroutine21 & 0xFFFF
    937              leaveReq.removeChildren = FALSE;
   \                     ??CrossCallReturnLabel_86:
   \   00003D   12....       LCALL   ?XSTACK_DISP0_8
   \   000040   E4           CLR     A
   \   000041   F0           MOVX    @DPTR,A
    938              leaveReq.rejoin         = FALSE;
   \   000042   7403         MOV     A,#0x3
   \   000044   12....       LCALL   ?XSTACK_DISP0_8
   \   000047   E4           CLR     A
   \   000048   F0           MOVX    @DPTR,A
    939          
    940              // find child association
    941              assoc = AssocGetWithExt( device->extAddr );
   \   000049                ; Setup parameters for call to function AssocGetWithExt
   \   000049   8882         MOV     DPL,R0
   \   00004B   8983         MOV     DPH,R1
   \   00004D   12....       LCALL   ??Subroutine59_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   000050   12....       LCALL   ??AssocGetWithExt?relay
   \   000053   8A..         MOV     ?V0 + 0,R2
   \   000055   8B..         MOV     ?V0 + 1,R3
   \   000057   A8..         MOV     R0,?V0 + 0
   \   000059   A9..         MOV     R1,?V0 + 1
    942          
    943              if ( ( assoc != NULL                            ) &&
    944                   ( assoc->nodeRelation >= CHILD_RFD         ) &&
    945                   ( assoc->nodeRelation <= CHILD_FFD_RX_IDLE )    )
   \   00005B   E8           MOV     A,R0
   \   00005C   49           ORL     A,R1
   \   00005D   6026         JZ      ??ZDSecMgrDeviceRemove_2
   \   00005F   8882         MOV     DPL,R0
   \   000061   8983         MOV     DPH,R1
   \   000063   A3           INC     DPTR
   \   000064   A3           INC     DPTR
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   E0           MOVX    A,@DPTR
   \   000068   14           DEC     A
   \   000069   C3           CLR     C
   \   00006A   9404         SUBB    A,#0x4
   \   00006C   5017         JNC     ??ZDSecMgrDeviceRemove_2
    946              {
    947                // check if associated device is authenticated
    948                if ( assoc->devStatus & DEV_SEC_AUTH_STATUS )
   \   00006E   8882         MOV     DPL,R0
   \   000070   8983         MOV     DPH,R1
   \   000072   A3           INC     DPTR
   \   000073   A3           INC     DPTR
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   E0           MOVX    A,@DPTR
   \   000078   A2E3         MOV     C,0xE0 /* A   */.3
   \   00007A   7404         MOV     A,#0x4
   \   00007C   402B         JC      ??ZDSecMgrDeviceRemove_3
    949                {
    950                  leaveReq.silent = FALSE;
    951                }
    952                else
    953                {
    954                  leaveReq.silent = TRUE;
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   7401         MOV     A,#0x1
   \   000083   8028         SJMP    ??ZDSecMgrDeviceRemove_4
   \   000085                ; Setup parameters for call to function NLME_LeaveReq
    955                }
    956          
    957                NLME_LeaveReq( &leaveReq );
    958              }
    959              else if ( device->nwkAddr == NLME_GetShortAddr() )
   \                     ??ZDSecMgrDeviceRemove_2:
   \   000085                ; Setup parameters for call to function NLME_GetShortAddr
   \   000085   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000088   8A..         MOV     ?V0 + 0,R2
   \   00008A   8B..         MOV     ?V0 + 1,R3
   \   00008C   A8..         MOV     R0,?V0 + 0
   \   00008E   A9..         MOV     R1,?V0 + 1
   \   000090   8E82         MOV     DPL,R6
   \   000092   8F83         MOV     DPH,R7
   \   000094   E0           MOVX    A,@DPTR
   \   000095   68           XRL     A,R0
   \   000096   7003         JNZ     ??ZDSecMgrDeviceRemove_5
   \   000098   A3           INC     DPTR
   \   000099   E0           MOVX    A,@DPTR
   \   00009A   69           XRL     A,R1
   \                     ??ZDSecMgrDeviceRemove_5:
   \   00009B   7057         JNZ     ??ZDSecMgrDeviceRemove_6
    960              {
    961                // this is when ZC wants that ZR removes itself from the network
    962                leaveReq.extAddr = NULL;
   \   00009D   85..82       MOV     DPL,?XSP + 0
   \   0000A0   85..83       MOV     DPH,?XSP + 1
   \   0000A3   E4           CLR     A
   \   0000A4   F0           MOVX    @DPTR,A
   \   0000A5   A3           INC     DPTR
   \   0000A6   F0           MOVX    @DPTR,A
    963                leaveReq.silent = FALSE;
   \   0000A7   7404         MOV     A,#0x4
   \                     ??ZDSecMgrDeviceRemove_3:
   \   0000A9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AC   E4           CLR     A
    964          
    965                NLME_LeaveReq( &leaveReq );
    966              }
    967            }
   \                     ??ZDSecMgrDeviceRemove_4:
   \   0000AD   12....       LCALL   ??Subroutine64_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_141:
   \   0000B0   12....       LCALL   ??NLME_LeaveReq?relay
   \   0000B3   803F         SJMP    ??ZDSecMgrDeviceRemove_6
    968            else
    969            {
    970              // this is not the parent of the device
    971              remDevReq.parentAddr   = device->parentAddr;
   \                     ??ZDSecMgrDeviceRemove_1:
   \   0000B5   7405         MOV     A,#0x5
   \   0000B7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BA   12....       LCALL   ?Subroutine17 & 0xFFFF
    972              remDevReq.childExtAddr = device->extAddr;
   \                     ??CrossCallReturnLabel_7:
   \   0000BD   7407         MOV     A,#0x7
   \   0000BF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C2   12....       LCALL   ??Subroutine63_0 & 0xFFFF
    973          
    974          #if defined ( APP_TP2_TEST_MODE )
    975              if ( guTxApsSecON == TRUE )
    976              {
    977                remDevReq.apsSecure = TRUE;
    978              }
    979              else
    980              {
    981                remDevReq.apsSecure = FALSE;
    982              }
    983          
    984              APSME_RemoveDeviceReq( &remDevReq );
    985          
    986          #else
    987              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
    988              {
    989                // For ZG_GLOBAL_LINK_KEY the message has to be sent twice, one
    990                // APS un-encrypted and one APS encrypted, to make sure that it can interoperate
    991                // with legacy Coordinator devices which can only handle one or the other.
    992                if ( zgApsLinkKeyType == ZG_GLOBAL_LINK_KEY )
   \                     ??CrossCallReturnLabel_127:
   \   0000C5   90....       MOV     DPTR,#zgApsLinkKeyType
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   6401         XRL     A,#0x1
   \   0000CB   7013         JNZ     ??ZDSecMgrDeviceRemove_7
    993                {
    994                  remDevReq.apsSecure = FALSE;
   \   0000CD   7409         MOV     A,#0x9
   \   0000CF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D2   E4           CLR     A
   \   0000D3   F0           MOVX    @DPTR,A
    995          
    996                  APSME_RemoveDeviceReq( &remDevReq );
   \   0000D4                ; Setup parameters for call to function APSME_RemoveDeviceReq
   \   0000D4   7405         MOV     A,#0x5
   \   0000D6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D9   AA82         MOV     R2,DPL
   \   0000DB   AB83         MOV     R3,DPH
   \   0000DD   12....       LCALL   ??APSME_RemoveDeviceReq?relay
    997                }
    998          
    999                remDevReq.apsSecure = TRUE;
   \                     ??ZDSecMgrDeviceRemove_7:
   \   0000E0   7409         MOV     A,#0x9
   \   0000E2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E5   7401         MOV     A,#0x1
   \   0000E7   F0           MOVX    @DPTR,A
   1000          
   1001                APSME_RemoveDeviceReq( &remDevReq );
   \   0000E8                ; Setup parameters for call to function APSME_RemoveDeviceReq
   \   0000E8   7405         MOV     A,#0x5
   \   0000EA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000ED   AA82         MOV     R2,DPL
   \   0000EF   AB83         MOV     R3,DPH
   \   0000F1   12....       LCALL   ??APSME_RemoveDeviceReq?relay
   1002              }
   1003              else
   1004              {
   1005                remDevReq.apsSecure = FALSE;
   1006          
   1007                APSME_RemoveDeviceReq( &remDevReq );
   1008              }
   1009          #endif
   1010            }
   1011          }
   \                     ??ZDSecMgrDeviceRemove_6:
   \   0000F4   740A         MOV     A,#0xa
   \   0000F6   02....       LJMP    ??Subroutine72_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine57_0
   \   000006                ; // Fall through to label ??Subroutine57_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine57_0:
   \   000000   12....       LCALL   ??Subroutine62_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   000003   7402         MOV     A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine58_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine59_0
   \   000002                ; // Fall through to label ??Subroutine59_0
   1012          
   1013          /******************************************************************************
   1014           * @fn          ZDSecMgrDeviceValidateRM (RESIDENTIAL MODE)
   1015           *
   1016           * @brief       Decide whether device is allowed.
   1017           *
   1018           * @param       device - [in] ZDSecMgrDevice_t, device info
   1019           *
   1020           * @return      ZStatus_t
   1021           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1022          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateRM:
   1023          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1024            ZStatus_t status;
   1025          
   1026            status = ZSuccess;
   \   000004   7900         MOV     R1,#0x0
   1027          
   1028            (void)device;  // Intentionally unreferenced parameter
   1029          
   1030            // For test purpose, turning off the zgSecurePermitJoin flag will force
   1031            // the trust center to reject any newly joining devices by sending
   1032            // Remove-device to the parents.
   1033            if ( zgSecurePermitJoin == FALSE )
   \   000006   90....       MOV     DPTR,#zgSecurePermitJoin
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   7002         JNZ     ??ZDSecMgrDeviceValidateRM_0
   1034            {
   1035              status = ZNwkUnknownDevice;
   \   00000C   79C8         MOV     R1,#-0x38
   1036            }
   1037          
   1038          
   1039          
   1040          #if 0  // Taken out because the following functionality is only used for test
   1041                 // purpose. A more efficient (above) way is used. It can be put
   1042                 // back in if customers request for a white/black list feature.
   1043                 // ZDSecMgrStoredDeviceList[] is defined in ZDSecMgr.c
   1044          
   1045            // The following code processes the device black list (stored device list)
   1046            // If the joining device is not part of the forbidden device list
   1047            // Return ZSuccess. Otherwise, return ZNwkUnknownDevice. The trust center
   1048            // will send Remove-device and ban the device from joining.
   1049          
   1050            uint8     index;
   1051            uint8*    restricted;
   1052          
   1053            // Look through the stored device list - used for restricted devices
   1054            for ( index = 0; index < ZDSECMGR_STORED_DEVICES; index++ )
   1055            {
   1056              restricted = ZDSecMgrStoredDeviceList[index];
   1057          
   1058              if ( AddrMgrExtAddrEqual( restricted, device->extAddr )  == TRUE )
   1059              {
   1060                // return as unknown device in regards to validation
   1061                status = ZNwkUnknownDevice;
   1062          
   1063                // break from loop
   1064                index = ZDSECMGR_STORED_DEVICES;
   1065              }
   1066            }
   1067          
   1068          #endif
   1069          
   1070            return status;
   \                     ??ZDSecMgrDeviceValidateRM_0:
   \   00000E   02....       LJMP    ??Subroutine61_0 & 0xFFFF
   1071          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine61_0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
   1072          
   1073          /******************************************************************************
   1074           * @fn          ZDSecMgrDeviceValidate
   1075           *
   1076           * @brief       Decide whether device is allowed.
   1077           *
   1078           * @param       device - [in] ZDSecMgrDevice_t, device info
   1079           *
   1080           * @return      ZStatus_t
   1081           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1082          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidate:
   1083          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1084            ZStatus_t status;
   1085          
   1086            if ( ZDSecMgrPermitJoiningEnabled == TRUE )
   \   000004   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   7005         JNZ     ??ZDSecMgrDeviceValidate_0
   1087            {
   1088              status = ZDSecMgrDeviceValidateRM( device );
   \   00000C                ; Setup parameters for call to function ZDSecMgrDeviceValidateRM
   \   00000C   12....       LCALL   ??ZDSecMgrDeviceValidateRM?relay
   \   00000F   8002         SJMP    ??ZDSecMgrDeviceValidate_1
   1089            }
   1090            else
   1091            {
   1092              status = ZNwkUnknownDevice;
   \                     ??ZDSecMgrDeviceValidate_0:
   \   000011   79C8         MOV     R1,#-0x38
   1093            }
   1094          
   1095            return status;
   \                     ??ZDSecMgrDeviceValidate_1:
   \   000013   02....       LJMP    ??Subroutine61_0 & 0xFFFF
   1096          }
   1097          
   1098          /******************************************************************************
   1099           * @fn          ZDSecMgrDeviceJoin
   1100           *
   1101           * @brief       Try to join this device.
   1102           *
   1103           * @param       device - [in] ZDSecMgrDevice_t, device info
   1104           *
   1105           * @return      ZStatus_t
   1106           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1107          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoin:
   1108          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1109            ZStatus_t status;
   1110            uint16    ami;
   1111          
   1112            // attempt to validate device
   1113            status = ZDSecMgrDeviceValidate( device );
   \   00000E                ; Setup parameters for call to function ZDSecMgrDeviceValidate
   \   00000E   12....       LCALL   ??ZDSecMgrDeviceValidate?relay
   \   000011   E9           MOV     A,R1
   \   000012   F5..         MOV     ?V0 + 4,A
   1114          
   1115            if ( status == ZSuccess )
   \   000014   7062         JNZ     ??ZDSecMgrDeviceJoin_0
   1116            {
   1117              // Add the device to the address manager
   1118              ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   000016   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   000019                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000019   85..82       MOV     DPL,?XSP + 0
   \   00001C   85..83       MOV     DPH,?XSP + 1
   \   00001F   8582..       MOV     ?V0 + 2,DPL
   \   000022   8583..       MOV     ?V0 + 3,DPH
   \   000025   78..         MOV     R0,#?V0 + 2
   \   000027   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002A   85..82       MOV     DPL,?V0 + 0
   \   00002D   8983         MOV     DPH,R1
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   FC           MOV     R4,A
   \   000031   A3           INC     DPTR
   \   000032   E0           MOVX    A,@DPTR
   \   000033   FD           MOV     R5,A
   \   000034   8E82         MOV     DPL,R6
   \   000036   8F83         MOV     DPH,R7
   \   000038   12....       LCALL   ??Subroutine59_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   00003B   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   00003E   7402         MOV     A,#0x2
   \   000040   12....       LCALL   ?DEALLOC_XSTACK8
   1119          
   1120              // Only send the key to devices that have not been authenticated
   1121              if ( ( device->devStatus & DEV_SEC_INIT_STATUS ) &&
   1122                   ( device->secure == FALSE ) )
   \   000043   8E82         MOV     DPL,R6
   \   000045   8F83         MOV     DPH,R7
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   A2E2         MOV     C,0xE0 /* A   */.2
   \   000051   502C         JNC     ??ZDSecMgrDeviceJoin_1
   \   000053   8E82         MOV     DPL,R6
   \   000055   8F83         MOV     DPH,R7
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   701F         JNZ     ??ZDSecMgrDeviceJoin_1
   1123              {
   1124                //send the nwk key data to the joining device
   1125                status = ZDSecMgrSendNwkKey( device );
   \   000060                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   000060   EE           MOV     A,R6
   \   000061   FA           MOV     R2,A
   \   000062   EF           MOV     A,R7
   \   000063   FB           MOV     R3,A
   \   000064   12....       LCALL   ??ZDSecMgrSendNwkKey?relay
   \   000067   E9           MOV     A,R1
   \   000068   F5..         MOV     ?V0 + 4,A
   1126              }
   1127          
   1128              if ( status != ZSuccess )
   \   00006A   6013         JZ      ??ZDSecMgrDeviceJoin_1
   1129              {
   1130                ZDSecMgrAddrClear( device->extAddr );
   \   00006C                ; Setup parameters for call to function ZDSecMgrAddrClear
   \   00006C   85..82       MOV     DPL,?V0 + 0
   \   00006F   85..83       MOV     DPH,?V0 + 1
   \   000072   12....       LCALL   ??Subroutine59_0 & 0xFFFF
   1131              }
   1132            }
   \                     ??CrossCallReturnLabel_99:
   \   000075   12....       LCALL   ??ZDSecMgrAddrClear?relay
   1133          
   1134            if ( status != ZSuccess )
   1135            {
   1136              // not allowed or transport key failed, remove the device
   1137              ZDSecMgrDeviceRemove( device );
   \                     ??ZDSecMgrDeviceJoin_0:
   \   000078                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000078   EE           MOV     A,R6
   \   000079   FA           MOV     R2,A
   \   00007A   EF           MOV     A,R7
   \   00007B   FB           MOV     R3,A
   \   00007C   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   1138            }
   1139          
   1140            return status;
   \                     ??ZDSecMgrDeviceJoin_1:
   \   00007F   A9..         MOV     R1,?V0 + 4
   \   000081   7402         MOV     A,#0x2
   \   000083   12....       LCALL   ?DEALLOC_XSTACK8
   \   000086   7F05         MOV     R7,#0x5
   \   000088   02....       LJMP    ?BANKED_LEAVE_XDATA
   1141          }
   1142          
   1143          /******************************************************************************
   1144           * @fn          ZDSecMgrDeviceJoinDirect
   1145           *
   1146           * @brief       Try to join this device as a direct child.
   1147           *
   1148           * @param       device - [in] ZDSecMgrDevice_t, device info
   1149           *
   1150           * @return      ZStatus_t
   1151           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1152          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinDirect:
   1153          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1154            ZStatus_t status;
   1155          
   1156            status = ZDSecMgrDeviceJoin( device );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000009   12....       LCALL   ??ZDSecMgrDeviceJoin?relay
   \   00000C   E9           MOV     A,R1
   \   00000D   F5..         MOV     ?V0 + 0,A
   1157          
   1158            if ( status == ZSuccess )
   \   00000F   700D         JNZ     ??ZDSecMgrDeviceJoinDirect_0
   1159            {
   1160              // set association status to authenticated
   1161              ZDSecMgrAssocDeviceAuth( AssocGetWithShort( device->nwkAddr ) );
   \   000011                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000011                ; Setup parameters for call to function AssocGetWithShort
   \   000011   8E82         MOV     DPL,R6
   \   000013   8F83         MOV     DPH,R7
   \   000015   12....       LCALL   ??Subroutine59_0 & 0xFFFF
   1162            }
   \                     ??CrossCallReturnLabel_100:
   \   000018   12....       LCALL   ??AssocGetWithShort?relay
   \   00001B   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   1163          
   1164            return status;
   \                     ??ZDSecMgrDeviceJoinDirect_0:
   \   00001E   A9..         MOV     R1,?V0 + 0
   \   000020   02....       LJMP    ??Subroutine68_0 & 0xFFFF
   1165          }
   1166          
   1167          /******************************************************************************
   1168           * @fn          ZDSecMgrDeviceJoinFwd
   1169           *
   1170           * @brief       Forward join to Trust Center.
   1171           *
   1172           * @param       device - [in] ZDSecMgrDevice_t, device info
   1173           *
   1174           * @return      ZStatus_t
   1175           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1176          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinFwd:
   1177          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 8
   \   000004   74F8         MOV     A,#-0x8
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1178            ZStatus_t               status;
   1179            APSME_UpdateDeviceReq_t req;
   1180          
   1181            // forward any joining device to the Trust Center -- the Trust Center will
   1182            // decide if the device is allowed to join
   1183            status = ZSuccess;
   1184          
   1185            // forward authorization to the Trust Center
   1186            req.dstAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   E4           CLR     A
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   12....       LCALL   ?Subroutine43 & 0xFFFF
   1187            req.devAddr    = device->nwkAddr;
   \                     ??CrossCallReturnLabel_52:
   \   000015   12....       LCALL   ??Subroutine70_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_169:
   \   000018   7402         MOV     A,#0x2
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   12....       LCALL   ?Subroutine14 & 0xFFFF
   1188            req.devExtAddr = device->extAddr;
   \                     ??CrossCallReturnLabel_0:
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   12....       LCALL   ??Subroutine63_0 & 0xFFFF
   1189          
   1190            // set security status, option for router to reject if policy set
   1191            if ( (device->devStatus & DEV_HIGH_SEC_STATUS) )
   \                     ??CrossCallReturnLabel_128:
   \   000026   EA           MOV     A,R2
   \   000027   2407         ADD     A,#0x7
   \   000029   F582         MOV     DPL,A
   \   00002B   EB           MOV     A,R3
   \   00002C   12....       LCALL   ??Subroutine71_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_179:
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   A2E7         MOV     C,0xE0 /* A   */.7
   \   000032   502E         JNC     ??ZDSecMgrDeviceJoinFwd_0
   1192            {
   1193              if ( device->devStatus & DEV_REJOIN_STATUS )
   \   000034   A2E6         MOV     C,0xE0 /* A   */.6
   \   000036   5021         JNC     ??ZDSecMgrDeviceJoinFwd_1
   1194              {
   1195                if ( device->secure == TRUE )
   \   000038   8A82         MOV     DPL,R2
   \   00003A   8B83         MOV     DPH,R3
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \   000043   6401         XRL     A,#0x1
   \   000045   7009         JNZ     ??ZDSecMgrDeviceJoinFwd_2
   1196                {
   1197                  req.status = APSME_UD_HIGH_SECURED_REJOIN;
   \   000047   7406         MOV     A,#0x6
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   7404         MOV     A,#0x4
   \   00004E   803D         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   1198                }
   1199                else
   1200                {
   1201                  req.status = APSME_UD_HIGH_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_2:
   \   000050   7406         MOV     A,#0x6
   \   000052   12....       LCALL   ?XSTACK_DISP0_8
   \   000055   7407         MOV     A,#0x7
   \   000057   8034         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   1202                }
   1203              }
   1204              else
   1205              {
   1206                req.status = APSME_UD_HIGH_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_1:
   \   000059   7406         MOV     A,#0x6
   \   00005B   12....       LCALL   ?XSTACK_DISP0_8
   \   00005E   7405         MOV     A,#0x5
   \   000060   802B         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   1207              }
   1208            }
   1209            else
   1210            {
   1211              if ( device->devStatus & DEV_REJOIN_STATUS )
   \                     ??ZDSecMgrDeviceJoinFwd_0:
   \   000062   A2E6         MOV     C,0xE0 /* A   */.6
   \   000064   5020         JNC     ??ZDSecMgrDeviceJoinFwd_4
   1212              {
   1213                if ( device->secure == TRUE )
   \   000066   8A82         MOV     DPL,R2
   \   000068   8B83         MOV     DPH,R3
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   6401         XRL     A,#0x1
   \   000073   7008         JNZ     ??ZDSecMgrDeviceJoinFwd_5
   1214                {
   1215                  req.status = APSME_UD_STANDARD_SECURED_REJOIN;
   \   000075   7406         MOV     A,#0x6
   \   000077   12....       LCALL   ?XSTACK_DISP0_8
   \   00007A   E4           CLR     A
   \   00007B   8010         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   1216                }
   1217                else
   1218                {
   1219                  req.status = APSME_UD_STANDARD_TRUST_CENTER_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_5:
   \   00007D   7406         MOV     A,#0x6
   \   00007F   12....       LCALL   ?XSTACK_DISP0_8
   \   000082   7403         MOV     A,#0x3
   \   000084   8007         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   1220                }
   1221              }
   1222              else
   1223              {
   1224                req.status = APSME_UD_STANDARD_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_4:
   \   000086   7406         MOV     A,#0x6
   \   000088   12....       LCALL   ?XSTACK_DISP0_8
   \   00008B   7401         MOV     A,#0x1
   1225              }
   1226            }
   \                     ??ZDSecMgrDeviceJoinFwd_3:
   \   00008D   12....       LCALL   ?Subroutine43 & 0xFFFF
   1227          
   1228            // set association status to authenticated
   1229            ZDSecMgrAssocDeviceAuth( AssocGetWithShort( device->nwkAddr ) );
   \                     ??CrossCallReturnLabel_53:
   \   000090   12....       LCALL   ??Subroutine59_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   000093   12....       LCALL   ??AssocGetWithShort?relay
   \   000096   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   1230          
   1231          #if defined ( APP_TP2_TEST_MODE )
   1232            if ( guTxApsSecON == TRUE )
   1233            {
   1234              req.apsSecure = TRUE;
   1235            }
   1236            else
   1237            {
   1238              req.apsSecure = FALSE;
   1239            }
   1240          
   1241            // send and APSME_UPDATE_DEVICE request to the trust center
   1242            status = APSME_UpdateDeviceReq( &req );
   1243          
   1244          #else
   1245            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   1246            {
   1247              // For ZG_GLOBAL_LINK_KEY the message has to be sent twice one
   1248              // un-encrypted and one APS encrypted, to make sure that it can interoperate
   1249              // with legacy Coordinator devices which can only handle one or the other.
   1250              if ( zgApsLinkKeyType == ZG_GLOBAL_LINK_KEY )
   \   000099   90....       MOV     DPTR,#zgApsLinkKeyType
   \   00009C   E0           MOVX    A,@DPTR
   \   00009D   6401         XRL     A,#0x1
   \   00009F   700C         JNZ     ??ZDSecMgrDeviceJoinFwd_6
   1251              {
   1252                req.apsSecure = FALSE;
   \   0000A1   7407         MOV     A,#0x7
   \   0000A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A6   E4           CLR     A
   \   0000A7   12....       LCALL   ??Subroutine64_0 & 0xFFFF
   1253          
   1254                // send and APSME_UPDATE_DEVICE request to the trust center
   1255                status = APSME_UpdateDeviceReq( &req );
   1256              }
   \                     ??CrossCallReturnLabel_142:
   \   0000AA   12....       LCALL   ??APSME_UpdateDeviceReq?relay
   1257          
   1258              // send the message APS encrypted
   1259              req.apsSecure = TRUE;
   \                     ??ZDSecMgrDeviceJoinFwd_6:
   \   0000AD   7407         MOV     A,#0x7
   \   0000AF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B2   7401         MOV     A,#0x1
   \   0000B4   12....       LCALL   ??Subroutine64_0 & 0xFFFF
   1260          
   1261              // send and APSME_UPDATE_DEVICE request to the trust center
   1262              status = APSME_UpdateDeviceReq( &req );
   1263            }
   1264            else
   1265            {
   1266              req.apsSecure = FALSE;
   1267          
   1268              // send and APSME_UPDATE_DEVICE request to the trust center
   1269              status = APSME_UpdateDeviceReq( &req );
   1270            }
   1271          #endif
   1272          
   1273            return status;
   \                     ??CrossCallReturnLabel_143:
   \   0000B7   12....       LCALL   ??APSME_UpdateDeviceReq?relay
   \   0000BA   80..         SJMP    ?Subroutine4
   1274          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   7408         MOV     A,#0x8
   \   000002                REQUIRE ??Subroutine60_0
   \   000002                ; // Fall through to label ??Subroutine60_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine60_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine61_0
   \   000003                ; // Fall through to label ??Subroutine61_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_174:
   \   00000C   7404         MOV     A,#0x4
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine71_0:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F583         MOV     DPH,A
   \   000004   22           RET
   1275          
   1276          /******************************************************************************
   1277           * @fn          ZDSecMgrDeviceNew
   1278           *
   1279           * @brief       Process a new device.
   1280           *
   1281           * @param       device - [in] ZDSecMgrDevice_t, device info
   1282           *
   1283           * @return      ZStatus_t
   1284           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1285          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* joiner )
   \                     ZDSecMgrDeviceNew:
   1286          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1287            ZStatus_t status;
   1288          
   1289            if ( ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1290                || ( ( ZG_BUILD_RTR_TYPE ) && APSME_IsDistributedSecurity() ) )
   \   000009                ; Setup parameters for call to function APSME_IsDistributedSecurity
   \   000009   12....       LCALL   ??APSME_IsDistributedSecurity?relay
   \   00000C   E9           MOV     A,R1
   \   00000D   6009         JZ      ??ZDSecMgrDeviceNew_0
   1291            {
   1292              // try to join this device
   1293              status = ZDSecMgrDeviceJoinDirect( joiner );
   \   00000F                ; Setup parameters for call to function ZDSecMgrDeviceJoinDirect
   \   00000F   EE           MOV     A,R6
   \   000010   FA           MOV     R2,A
   \   000011   EF           MOV     A,R7
   \   000012   FB           MOV     R3,A
   \   000013   12....       LCALL   ??ZDSecMgrDeviceJoinDirect?relay
   \   000016   8007         SJMP    ??ZDSecMgrDeviceNew_1
   1294            }
   1295            else
   1296            {
   1297              status = ZDSecMgrDeviceJoinFwd( joiner );
   \                     ??ZDSecMgrDeviceNew_0:
   \   000018                ; Setup parameters for call to function ZDSecMgrDeviceJoinFwd
   \   000018   EE           MOV     A,R6
   \   000019   FA           MOV     R2,A
   \   00001A   EF           MOV     A,R7
   \   00001B   FB           MOV     R3,A
   \   00001C   12....       LCALL   ??ZDSecMgrDeviceJoinFwd?relay
   1298            }
   1299          
   1300            return status;
   \                     ??ZDSecMgrDeviceNew_1:
   \   00001F   02....       LJMP    ??Subroutine68_0 & 0xFFFF
   1301          }
   1302          
   1303          /******************************************************************************
   1304           * @fn          ZDSecMgrAssocDeviceAuth
   1305           *
   1306           * @brief       Set associated device status to authenticated
   1307           *
   1308           * @param       assoc - [in, out] associated_devices_t
   1309           *
   1310           * @return      none
   1311           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1312          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc )
   \                     ZDSecMgrAssocDeviceAuth:
   1313          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1314            if ( assoc != NULL )
   \   000004   EA           MOV     A,R2
   \   000005   4B           ORL     A,R3
   \   000006   600D         JZ      ??ZDSecMgrAssocDeviceAuth_0
   1315            {
   1316              assoc->devStatus |= DEV_SEC_AUTH_STATUS;
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   D2E3         SETB    0xE0 /* A   */.3
   \   000014   F0           MOVX    @DPTR,A
   1317            }
   1318          }
   \                     ??ZDSecMgrAssocDeviceAuth_0:
   \   000015   80..         SJMP    ??Subroutine61_0
   1319          
   1320          /******************************************************************************
   1321           * @fn          ZDSecMgrAuthNwkKey
   1322           *
   1323           * @brief       Handle next step in authentication process
   1324           *
   1325           * @param       none
   1326           *
   1327           * @return      none
   1328           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1329          void ZDSecMgrAuthNwkKey()
   \                     ZDSecMgrAuthNwkKey:
   1330          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1331            if ( devState == DEV_END_DEVICE_UNAUTH )
   \   000004   90....       MOV     DPTR,#devState
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6405         XRL     A,#0x5
   \   00000A   700C         JNZ     ??ZDSecMgrAuthNwkKey_0
   1332            {
   1333              // inform ZDO that device has been authenticated
   1334              osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   00000C                ; Setup parameters for call to function osal_set_event
   \   00000C   7A80         MOV     R2,#-0x80
   \   00000E   7B00         MOV     R3,#0x0
   \   000010   90....       MOV     DPTR,#ZDAppTaskID
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F9           MOV     R1,A
   \   000015   12....       LCALL   ??osal_set_event?relay
   1335            }
   1336          }
   \                     ??ZDSecMgrAuthNwkKey_0:
   \   000018   80..         SJMP    ??Subroutine61_0
   1337          
   1338          /******************************************************************************
   1339           * PUBLIC FUNCTIONS
   1340           */
   1341          /******************************************************************************
   1342           * @fn          ZDSecMgrInit
   1343           *
   1344           * @brief       Initialize ZigBee Device Security Manager.
   1345           *
   1346           * @param       state - device initialization state
   1347           *
   1348           * @return      none
   1349           */
   1350          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   1351          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
   1352          void ZDSecMgrAddrMgrCB( uint8           update,
   1353                                  AddrMgrEntry_t* newEntry,
   1354                                  AddrMgrEntry_t* oldEntry )
   1355          {
   1356            (void)update;
   1357            (void)newEntry;
   1358            (void)oldEntry;
   1359          }
   1360          #endif // ( ADDRMGR_CALLBACK_ENABLED == 1 )
   1361          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1362          void ZDSecMgrInit(uint8 state)
   \                     ZDSecMgrInit:
   1363          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1364            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   1365            {
   1366              // initialize sub modules
   1367              ZDSecMgrEntryInit(state);
   \   000005                ; Setup parameters for call to function ZDSecMgrEntryInit
   \   000005   12....       LCALL   ??ZDSecMgrEntryInit?relay
   1368          
   1369              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1370              {
   1371                APSME_SetRequest( apsTrustCenterAddress, 0, NLME_GetExtAddr() );
   1372              }
   1373          
   1374              // register with Address Manager
   1375          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   1376              AddrMgrRegister( ADDRMGR_REG_SECURITY, ZDSecMgrAddrMgrCB );
   1377          #endif
   1378            }
   1379          
   1380            if ( ZG_SECURE_ENABLED )
   1381            {
   1382              if ( ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1383                   || ( ( ZG_BUILD_RTR_TYPE ) && APSME_IsDistributedSecurity() ) )
   \   000008                ; Setup parameters for call to function APSME_IsDistributedSecurity
   \   000008   12....       LCALL   ??APSME_IsDistributedSecurity?relay
   \   00000B   E9           MOV     A,R1
   \   00000C   600B         JZ      ??ZDSecMgrInit_0
   1384              {
   1385                // setup joining permissions
   1386                ZDSecMgrPermitJoiningEnabled = TRUE;
   \   00000E   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000011   7401         MOV     A,#0x1
   \   000013   F0           MOVX    @DPTR,A
   1387                ZDSecMgrPermitJoiningTimed   = FALSE;
   \   000014   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000017   E4           CLR     A
   \   000018   F0           MOVX    @DPTR,A
   1388              }
   1389            }
   1390          
   1391            // configure security based on security mode and type of device
   1392            ZDSecMgrConfig();
   \                     ??ZDSecMgrInit_0:
   \   000019                ; Setup parameters for call to function SSP_Init
   \   000019   12....       LCALL   ??SSP_Init?relay
   \   00001C                ; Setup parameters for call to function APSME_SecurityCM_RD
   \   00001C   12....       LCALL   ??APSME_SecurityCM_RD?relay
   1393          }
   \   00001F   02....       LJMP    ??Subroutine68_0 & 0xFFFF
   1394          
   1395          /******************************************************************************
   1396           * @fn          ZDSecMgrConfig
   1397           *
   1398           * @brief       Configure ZigBee Device Security Manager.
   1399           *
   1400           * @param       none
   1401           *
   1402           * @return      none
   1403           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1404          void ZDSecMgrConfig( void )
   \                     ZDSecMgrConfig:
   1405          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1406            if ( ZG_SECURE_ENABLED )
   1407            {
   1408              SSP_Init();
   \   000004                ; Setup parameters for call to function SSP_Init
   \   000004   12....       LCALL   ??SSP_Init?relay
   1409          
   1410              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   1411              {
   1412                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1413                {
   1414                  // COMMERCIAL MODE - COORDINATOR DEVICE
   1415                  APSME_SecurityCM_CD();
   1416                }
   1417                else if ( ZSTACK_ROUTER_BUILD )
   1418                {
   1419                  // COMMERCIAL MODE - ROUTER DEVICE
   1420                  APSME_SecurityCM_RD();
   \   000007                ; Setup parameters for call to function APSME_SecurityCM_RD
   \   000007   12....       LCALL   ??APSME_SecurityCM_RD?relay
   1421                }
   1422                else
   1423                {
   1424                  // COMMERCIAL MODE - END DEVICE
   1425                  APSME_SecurityCM_ED();
   1426                }
   1427              }
   1428              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   1429              {
   1430                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1431                {
   1432                  // RESIDENTIAL MODE - COORDINATOR DEVICE
   1433                  APSME_SecurityRM_CD();
   1434                }
   1435                else if ( ZSTACK_ROUTER_BUILD )
   1436                {
   1437                  // RESIDENTIAL MODE - ROUTER DEVICE
   1438                  APSME_SecurityRM_RD();
   1439                }
   1440                else
   1441                {
   1442                  // RESIDENTIAL MODE - END DEVICE
   1443                  APSME_SecurityRM_ED();
   1444                }
   1445              }
   1446            }
   1447            else
   1448            {
   1449              // NO SECURITY
   1450              APSME_SecurityNM();
   1451            }
   1452          }
   \   00000A   80..         SJMP    ??Subroutine61_0
   1453          
   1454          /******************************************************************************
   1455           * @fn          ZDSecMgrPermitJoining
   1456           *
   1457           * @brief       Process request to change joining permissions.
   1458           *
   1459           * @param       duration - [in] timed duration for join in seconds
   1460           *                         - 0x00 not allowed
   1461           *                         - 0xFF allowed without timeout
   1462           *
   1463           * @return      uint8 - success(TRUE:FALSE)
   1464           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1465          uint8 ZDSecMgrPermitJoining( uint8 duration )
   \                     ZDSecMgrPermitJoining:
   1466          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
   1467            uint8 accept;
   1468          
   1469            ZDSecMgrPermitJoiningTimed = FALSE;
   \   000006   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000009   E4           CLR     A
   \   00000A   F0           MOVX    @DPTR,A
   1470          
   1471            if ( duration > 0 )
   \   00000B   E8           MOV     A,R0
   \   00000C   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   600F         JZ      ??ZDSecMgrPermitJoining_0
   1472            {
   1473              ZDSecMgrPermitJoiningEnabled = TRUE;
   \   000011   7401         MOV     A,#0x1
   \   000013   F0           MOVX    @DPTR,A
   1474          
   1475              if ( duration != 0xFF )
   \   000014   74FF         MOV     A,#-0x1
   \   000016   68           XRL     A,R0
   \   000017   6009         JZ      ??ZDSecMgrPermitJoining_1
   1476              {
   1477                ZDSecMgrPermitJoiningTimed = TRUE;
   \   000019   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   00001C   7401         MOV     A,#0x1
   \   00001E   8001         SJMP    ??ZDSecMgrPermitJoining_2
   1478              }
   1479            }
   1480            else
   1481            {
   1482              ZDSecMgrPermitJoiningEnabled = FALSE;
   \                     ??ZDSecMgrPermitJoining_0:
   \   000020   E4           CLR     A
   \                     ??ZDSecMgrPermitJoining_2:
   \   000021   F0           MOVX    @DPTR,A
   1483            }
   1484          
   1485            accept = TRUE;
   1486          
   1487            return accept;
   \                     ??ZDSecMgrPermitJoining_1:
   \   000022   7901         MOV     R1,#0x1
   \   000024   80..         SJMP    ??Subroutine61_0
   1488          }
   1489          
   1490          /******************************************************************************
   1491           * @fn          ZDSecMgrPermitJoiningTimeout
   1492           *
   1493           * @brief       Process permit joining timeout
   1494           *
   1495           * @param       none
   1496           *
   1497           * @return      none
   1498           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1499          void ZDSecMgrPermitJoiningTimeout( void )
   \                     ZDSecMgrPermitJoiningTimeout:
   1500          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1501            if ( ZDSecMgrPermitJoiningTimed == TRUE )
   \   000004   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   7009         JNZ     ??ZDSecMgrPermitJoiningTimeout_0
   1502            {
   1503              ZDSecMgrPermitJoiningEnabled = FALSE;
   \   00000C   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   E4           CLR     A
   \   000010   F0           MOVX    @DPTR,A
   1504              ZDSecMgrPermitJoiningTimed   = FALSE;
   \   000011   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000014   F0           MOVX    @DPTR,A
   1505            }
   1506          }
   \                     ??ZDSecMgrPermitJoiningTimeout_0:
   \   000015   80..         SJMP    ??Subroutine61_0
   1507          
   1508          /******************************************************************************
   1509           * @fn          ZDSecMgrNewDeviceEvent
   1510           *
   1511           * @brief       Process a the new device event, if found reset new device
   1512           *              event/timer.
   1513           *
   1514           * @param       ShortAddr - of New Device to process
   1515           *
   1516           * @return      uint8 - found(TRUE:FALSE)
   1517           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1518          uint8 ZDSecMgrNewDeviceEvent( uint16 ShortAddr )
   \                     ZDSecMgrNewDeviceEvent:
   1519          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 21
   \   000005   74EB         MOV     A,#-0x15
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1520            uint8                 found;
   1521            ZDSecMgrDevice_t      device;
   1522            AddrMgrEntry_t        addrEntry;
   1523            associated_devices_t* assoc;
   1524            ZStatus_t             status;
   1525          
   1526            // initialize return results
   1527            found = FALSE;
   \   00000A   75..00       MOV     ?V0 + 0,#0x0
   1528          
   1529            assoc = AssocGetWithShort( ShortAddr );
   \   00000D                ; Setup parameters for call to function AssocGetWithShort
   \   00000D   12....       LCALL   ??AssocGetWithShort?relay
   \   000010   8A..         MOV     ?V0 + 2,R2
   \   000012   8B..         MOV     ?V0 + 3,R3
   \   000014   AE..         MOV     R6,?V0 + 2
   \   000016   AF..         MOV     R7,?V0 + 3
   1530          
   1531            if ( assoc != NULL )
   \   000018   EE           MOV     A,R6
   \   000019   4F           ORL     A,R7
   \   00001A   7003         JNZ     $+5
   \   00001C   02....       LJMP    ??ZDSecMgrNewDeviceEvent_0 & 0xFFFF
   1532            {
   1533              // device found
   1534              found = TRUE;
   \   00001F   75..01       MOV     ?V0 + 0,#0x1
   1535          
   1536              // check for preconfigured security
   1537              if ( zgPreConfigKeys == TRUE )
   \   000022   90....       MOV     DPTR,#zgPreConfigKeys
   \   000025   E0           MOVX    A,@DPTR
   \   000026   6401         XRL     A,#0x1
   \   000028   7003         JNZ     ??ZDSecMgrNewDeviceEvent_1
   1538              {
   1539                // set association status to authenticated
   1540                ZDSecMgrAssocDeviceAuth( assoc );
   \   00002A                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00002A   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   1541              }
   1542          
   1543              // set up device info
   1544              addrEntry.user  = ADDRMGR_USER_DEFAULT;
   \                     ??ZDSecMgrNewDeviceEvent_1:
   \   00002D   7408         MOV     A,#0x8
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   E4           CLR     A
   \   000033   F0           MOVX    @DPTR,A
   1545              addrEntry.index = assoc->addrIdx;
   \   000034   8E82         MOV     DPL,R6
   \   000036   8F83         MOV     DPH,R7
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   12....       LCALL   ??Subroutine70_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_170:
   \   00003D   7413         MOV     A,#0x13
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   12....       LCALL   ??Subroutine63_0 & 0xFFFF
   1546              AddrMgrEntryGet( &addrEntry );
   \                     ??CrossCallReturnLabel_129:
   \   000045                ; Setup parameters for call to function AddrMgrEntryGet
   \   000045   7408         MOV     A,#0x8
   \   000047   12....       LCALL   ?XSTACK_DISP0_8
   \   00004A   AA82         MOV     R2,DPL
   \   00004C   AB83         MOV     R3,DPH
   \   00004E   12....       LCALL   ??AddrMgrEntryGet?relay
   1547          
   1548              device.nwkAddr    = assoc->shortAddr;
   \   000051   8E82         MOV     DPL,R6
   \   000053   8F83         MOV     DPH,R7
   \   000055   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   000058   12....       LCALL   ??Subroutine63_0 & 0xFFFF
   1549              device.extAddr    = addrEntry.extAddr;
   \                     ??CrossCallReturnLabel_130:
   \   00005B   740B         MOV     A,#0xb
   \   00005D   12....       LCALL   ?XSTACK_DISP0_8
   \   000060   A882         MOV     R0,DPL
   \   000062   A983         MOV     R1,DPH
   \   000064   7402         MOV     A,#0x2
   \   000066   12....       LCALL   ?XSTACK_DISP0_8
   \   000069   12....       LCALL   ??Subroutine63_0 & 0xFFFF
   1550              device.parentAddr = NLME_GetShortAddr();
   \                     ??CrossCallReturnLabel_131:
   \   00006C                ; Setup parameters for call to function NLME_GetShortAddr
   \   00006C   12....       LCALL   ??NLME_GetShortAddr?relay
   \   00006F   7404         MOV     A,#0x4
   \   000071   12....       LCALL   ?XSTACK_DISP0_8
   \   000074   12....       LCALL   ??Subroutine62_0 & 0xFFFF
   1551          
   1552              // the new device performed Secured Rejoin
   1553              if ( ( assoc->devStatus & DEV_SECURED_JOIN ) &&
   1554                   ( assoc->devStatus & DEV_REJOIN_STATUS ) )
   \                     ??CrossCallReturnLabel_111:
   \   000077   EE           MOV     A,R6
   \   000078   2405         ADD     A,#0x5
   \   00007A   F8           MOV     R0,A
   \   00007B   EF           MOV     A,R7
   \   00007C   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   00007F   5460         ANL     A,#0x60
   \   000081   6460         XRL     A,#0x60
   \   000083   7009         JNZ     ??ZDSecMgrNewDeviceEvent_2
   1555              {
   1556                device.secure     = TRUE;
   \   000085   7406         MOV     A,#0x6
   \   000087   12....       LCALL   ?XSTACK_DISP0_8
   \   00008A   7401         MOV     A,#0x1
   \   00008C   8006         SJMP    ??ZDSecMgrNewDeviceEvent_3
   1557              }
   1558              else
   1559              {
   1560                device.secure     = FALSE;
   \                     ??ZDSecMgrNewDeviceEvent_2:
   \   00008E   7406         MOV     A,#0x6
   \   000090   12....       LCALL   ?XSTACK_DISP0_8
   \   000093   E4           CLR     A
   \                     ??ZDSecMgrNewDeviceEvent_3:
   \   000094   F0           MOVX    @DPTR,A
   1561              }
   1562              device.devStatus  = assoc->devStatus;
   \   000095   8E82         MOV     DPL,R6
   \   000097   8F83         MOV     DPH,R7
   \   000099   E0           MOVX    A,@DPTR
   \   00009A   C0E0         PUSH    A
   \   00009C   7407         MOV     A,#0x7
   \   00009E   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A1   D0E0         POP     A
   \   0000A3   12....       LCALL   ??Subroutine64_0 & 0xFFFF
   1563          
   1564              // process new device
   1565              status = ZDSecMgrDeviceNew( &device );
   1566          
   1567              if ( status == ZSuccess )
   \                     ??CrossCallReturnLabel_144:
   \   0000A6   12....       LCALL   ??ZDSecMgrDeviceNew?relay
   \   0000A9   E9           MOV     A,R1
   \   0000AA   700A         JNZ     ??ZDSecMgrNewDeviceEvent_4
   1568              {
   1569                assoc->devStatus &= ~DEV_SEC_INIT_STATUS;
   \   0000AC   8E82         MOV     DPL,R6
   \   0000AE   8F83         MOV     DPH,R7
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   C2E2         CLR     0xE0 /* A   */.2
   \   0000B3   F0           MOVX    @DPTR,A
   \   0000B4   8018         SJMP    ??ZDSecMgrNewDeviceEvent_0
   1570              }
   1571              else
   1572              {
   1573                // Clear SECURITY bit from Address Manager
   1574                ZDSecMgrAddrClear( addrEntry.extAddr );
   \                     ??ZDSecMgrNewDeviceEvent_4:
   \   0000B6                ; Setup parameters for call to function ZDSecMgrAddrClear
   \   0000B6   740B         MOV     A,#0xb
   \   0000B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BB   AA82         MOV     R2,DPL
   \   0000BD   AB83         MOV     R3,DPH
   \   0000BF   12....       LCALL   ??ZDSecMgrAddrClear?relay
   1575          
   1576                // Remove the Association completely
   1577                AssocRemove( addrEntry.extAddr );
   \   0000C2                ; Setup parameters for call to function AssocRemove
   \   0000C2   740B         MOV     A,#0xb
   \   0000C4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C7   AA82         MOV     R2,DPL
   \   0000C9   AB83         MOV     R3,DPH
   \   0000CB   12....       LCALL   ??AssocRemove?relay
   1578              }
   1579            }
   1580          
   1581            return found;
   \                     ??ZDSecMgrNewDeviceEvent_0:
   \   0000CE   A9..         MOV     R1,?V0 + 0
   \   0000D0   7415         MOV     A,#0x15
   \   0000D2   02....       LJMP    ?Subroutine3 & 0xFFFF
   1582          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F9           MOV     R1,A
   \   000003   E8           MOV     A,R0
   \   000004   FE           MOV     R6,A
   \   000005   E9           MOV     A,R1
   \   000006   FF           MOV     R7,A
   \   000007                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000007   8E82         MOV     DPL,R6
   \   000009   8F83         MOV     DPH,R7
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   85..82       MOV     DPL,?XSP + 0
   \   000008   85..83       MOV     DPH,?XSP + 1
   \   00000B   22           RET
   1583          
   1584          /******************************************************************************
   1585           * @fn          ZDSecMgrTCExtAddrCheck
   1586           *
   1587           * @brief       Verifies if received ext. address matches TC ext. address.
   1588           *
   1589           * @param       extAddr - Extended address to be verified.
   1590           *
   1591           * @return      TRUE - extended address matches
   1592           *              FALSE - otherwise
   1593           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1594          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr )
   \                     ZDSecMgrTCExtAddrCheck:
   1595          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1596            uint8  lookup[Z_EXTADDR_LEN];
   1597            APSME_GetRequest( apsTrustCenterAddress, 0, lookup );
   \   00000E                ; Setup parameters for call to function APSME_GetRequest
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   7A00         MOV     R2,#0x0
   \   00001A   7B00         MOV     R3,#0x0
   \   00001C   79AB         MOV     R1,#-0x55
   \   00001E   12....       LCALL   ??APSME_GetRequest?relay
   1598            return osal_ExtAddrEqual( extAddr, lookup );
   \   000021                ; Setup parameters for call to function sAddrExtCmp
   \   000021   85..82       MOV     DPL,?XSP + 0
   \   000024   85..83       MOV     DPH,?XSP + 1
   \   000027   AC82         MOV     R4,DPL
   \   000029   AD83         MOV     R5,DPH
   \   00002B   EE           MOV     A,R6
   \   00002C   FA           MOV     R2,A
   \   00002D   EF           MOV     A,R7
   \   00002E   FB           MOV     R3,A
   \   00002F   12....       LCALL   ??sAddrExtCmp?relay
   \   000032                REQUIRE ?Subroutine8
   \   000032                ; // Fall through to label ?Subroutine8
   1599          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   7408         MOV     A,#0x8
   \   000002   02....       LJMP    ??Subroutine67_0 & 0xFFFF
   1600          
   1601          /******************************************************************************
   1602           * @fn          ZDSecMgrTCDataLoad
   1603           *
   1604           * @brief       Stores the address of TC into address manager.
   1605           *
   1606           * @param       extAddr - Extended address to be verified.
   1607           *
   1608           * @return      none
   1609           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1610          void ZDSecMgrTCDataLoad( uint8* extAddr )
   \                     ZDSecMgrTCDataLoad:
   1611          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 15
   \   000005   74F1         MOV     A,#-0xf
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1612            uint16 ami;
   1613            AddrMgrEntry_t entry;
   1614          
   1615            // lookup using TC short address
   1616            entry.user    = ADDRMGR_USER_DEFAULT;
   \   00000E   7402         MOV     A,#0x2
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   E4           CLR     A
   \   000014   F0           MOVX    @DPTR,A
   1617            osal_cpyExtAddr( entry.extAddr, extAddr );
   \   000015                ; Setup parameters for call to function sAddrExtCpy
   \   000015   EE           MOV     A,R6
   \   000016   FC           MOV     R4,A
   \   000017   EF           MOV     A,R7
   \   000018   FD           MOV     R5,A
   \   000019   7405         MOV     A,#0x5
   \   00001B   12....       LCALL   ?XSTACK_DISP0_8
   \   00001E   AA82         MOV     R2,DPL
   \   000020   AB83         MOV     R3,DPH
   \   000022   12....       LCALL   ??sAddrExtCpy?relay
   1618          
   1619            // Verify if TC address has been added to Address Manager
   1620            if ( !APSME_IsDistributedSecurity() && ( AddrMgrEntryLookupExt( &entry ) != TRUE ) )
   \   000025                ; Setup parameters for call to function APSME_IsDistributedSecurity
   \   000025   12....       LCALL   ??APSME_IsDistributedSecurity?relay
   \   000028   E9           MOV     A,R1
   \   000029   7032         JNZ     ??ZDSecMgrTCDataLoad_0
   \   00002B                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   00002B   7402         MOV     A,#0x2
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   AA82         MOV     R2,DPL
   \   000032   AB83         MOV     R3,DPH
   \   000034   12....       LCALL   ??AddrMgrEntryLookupExt?relay
   \   000037   E9           MOV     A,R1
   \   000038   6401         XRL     A,#0x1
   \   00003A   6021         JZ      ??ZDSecMgrTCDataLoad_0
   1621            {
   1622              ZDSecMgrAddrStore( APSME_TRUSTCENTER_NWKADDR, extAddr, &ami );
   \   00003C                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00003C   85..82       MOV     DPL,?XSP + 0
   \   00003F   85..83       MOV     DPH,?XSP + 1
   \   000042   8582..       MOV     ?V0 + 0,DPL
   \   000045   8583..       MOV     ?V0 + 1,DPH
   \   000048   78..         MOV     R0,#?V0 + 0
   \   00004A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004D   EE           MOV     A,R6
   \   00004E   FC           MOV     R4,A
   \   00004F   EF           MOV     A,R7
   \   000050   FD           MOV     R5,A
   \   000051   7A00         MOV     R2,#0x0
   \   000053   7B00         MOV     R3,#0x0
   \   000055   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   000058   7402         MOV     A,#0x2
   \   00005A   12....       LCALL   ?DEALLOC_XSTACK8
   1623            }
   1624          }
   \                     ??ZDSecMgrTCDataLoad_0:
   \   00005D   740F         MOV     A,#0xf
   \   00005F   02....       LJMP    ??Subroutine72_0 & 0xFFFF
   1625          
   1626          /******************************************************************************
   1627           * @fn          ZDSecMgrTransportKeyInd
   1628           *
   1629           * @brief       Process the ZDO_TransportKeyInd_t message.
   1630           *
   1631           * @param       ind - [in] ZDO_TransportKeyInd_t indication
   1632           *
   1633           * @return      none
   1634           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   000003   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   000006                REQUIRE ??Subroutine63_0
   \   000006                ; // Fall through to label ??Subroutine63_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1635          void ZDSecMgrTransportKeyInd( ZDO_TransportKeyInd_t* ind )
   \                     ZDSecMgrTransportKeyInd:
   1636          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV     A,#-0x14
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   1637            uint8 index;
   1638            uint8 zgPreConfigKey[SEC_KEY_LEN];
   1639          
   1640            ZDSecMgrUpdateTCAddress( ind->srcExtAddr );
   \   00000E   EA           MOV     A,R2
   \   00000F   2416         ADD     A,#0x16
   \   000011   FE           MOV     R6,A
   \   000012   EB           MOV     A,R3
   \   000013   3400         ADDC    A,#0x0
   \   000015   FF           MOV     R7,A
   \   000016                ; Setup parameters for call to function ZDSecMgrUpdateTCAddress
   \   000016   EE           MOV     A,R6
   \   000017   FA           MOV     R2,A
   \   000018   EF           MOV     A,R7
   \   000019   FB           MOV     R3,A
   \   00001A   12....       LCALL   ??ZDSecMgrUpdateTCAddress?relay
   1641            // check for distributed security
   1642            if ( ( ZG_BUILD_RTR_TYPE ) && osal_isbufset( ind->srcExtAddr, 0xFF, Z_EXTADDR_LEN ) )
   \   00001D                ; Setup parameters for call to function osal_isbufset
   \   00001D   7C08         MOV     R4,#0x8
   \   00001F   79FF         MOV     R1,#-0x1
   \   000021   EE           MOV     A,R6
   \   000022   FA           MOV     R2,A
   \   000023   EF           MOV     A,R7
   \   000024   FB           MOV     R3,A
   \   000025   12....       LCALL   ??osal_isbufset?relay
   \   000028   E9           MOV     A,R1
   \   000029   6006         JZ      ??ZDSecMgrTransportKeyInd_0
   1643            {
   1644              ZDSecMgrPermitJoiningEnabled = TRUE;
   \   00002B   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00002E   7401         MOV     A,#0x1
   \   000030   F0           MOVX    @DPTR,A
   1645            }
   1646          
   1647            // load Trust Center data if needed
   1648            ZDSecMgrTCDataLoad( ind->srcExtAddr );
   \                     ??ZDSecMgrTransportKeyInd_0:
   \   000031                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   000031   EE           MOV     A,R6
   \   000032   FA           MOV     R2,A
   \   000033   EF           MOV     A,R7
   \   000034   FB           MOV     R3,A
   \   000035   12....       LCALL   ??ZDSecMgrTCDataLoad?relay
   1649          
   1650            if ( ( ind->keyType == KEY_TYPE_NWK ) ||
   1651                 ( ind->keyType == 6            ) )
   \   000038   85..82       MOV     DPL,?V0 + 2
   \   00003B   85..83       MOV     DPH,?V0 + 3
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \   000043   F8           MOV     R0,A
   \   000044   E5..         MOV     A,?V0 + 2
   \   000046   2406         ADD     A,#0x6
   \   000048   F5..         MOV     ?V0 + 0,A
   \   00004A   E5..         MOV     A,?V0 + 3
   \   00004C   3400         ADDC    A,#0x0
   \   00004E   F5..         MOV     ?V0 + 1,A
   \   000050   7401         MOV     A,#0x1
   \   000052   68           XRL     A,R0
   \   000053   6008         JZ      ??ZDSecMgrTransportKeyInd_1
   \   000055   7406         MOV     A,#0x6
   \   000057   68           XRL     A,R0
   \   000058   6003         JZ      $+5
   \   00005A   02....       LJMP    ??ZDSecMgrTransportKeyInd_2 & 0xFFFF
   1652            {
   1653              // check for dummy NWK key (all zeros)
   1654              for ( index = 0;
   \                     ??ZDSecMgrTransportKeyInd_1:
   \   00005D   7800         MOV     R0,#0x0
   \                     ??ZDSecMgrTransportKeyInd_3:
   \   00005F   88..         MOV     ?V0 + 4,R0
   \   000061   E5..         MOV     A,?V0 + 2
   \   000063   25..         ADD     A,?V0 + 4
   \   000065   F582         MOV     DPL,A
   \   000067   E5..         MOV     A,?V0 + 3
   \   000069   12....       LCALL   ??Subroutine71_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_180:
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   A3           INC     DPTR
   \   000071   A3           INC     DPTR
   \   000072   E0           MOVX    A,@DPTR
   \   000073   7007         JNZ     ??ZDSecMgrTransportKeyInd_4
   1655                    ( (index < SEC_KEY_LEN) && (ind->key[index] == 0) );
   1656                    index++ );
   \   000075   08           INC     R0
   \   000076   E8           MOV     A,R0
   \   000077   C3           CLR     C
   \   000078   9410         SUBB    A,#0x10
   \   00007A   40E3         JC      ??ZDSecMgrTransportKeyInd_3
   1657          
   1658              if ( index == SEC_KEY_LEN )
   \                     ??ZDSecMgrTransportKeyInd_4:
   \   00007C   7410         MOV     A,#0x10
   \   00007E   68           XRL     A,R0
   \   00007F   703D         JNZ     ??ZDSecMgrTransportKeyInd_5
   1659              {
   1660                // load preconfigured key - once!!
   1661                if ( !_NIB.nwkKeyLoaded )
   \   000081   90....       MOV     DPTR,#_NIB + 61
   \   000084   E0           MOVX    A,@DPTR
   \   000085   7058         JNZ     ??ZDSecMgrTransportKeyInd_6
   1662                {
   1663                  ZDSecMgrReadKeyFromNv(ZCD_NV_PRECFGKEY, zgPreConfigKey);
   \   000087                ; Setup parameters for call to function ZDSecMgrReadKeyFromNv
   \   000087   7404         MOV     A,#0x4
   \   000089   12....       LCALL   ?XSTACK_DISP0_8
   \   00008C   AC82         MOV     R4,DPL
   \   00008E   AD83         MOV     R5,DPH
   \   000090   7A62         MOV     R2,#0x62
   \   000092   7B00         MOV     R3,#0x0
   \   000094   12....       LCALL   ??ZDSecMgrReadKeyFromNv?relay
   1664                  SSP_UpdateNwkKey( zgPreConfigKey, 0 );
   \   000097                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000097   7900         MOV     R1,#0x0
   \   000099   7404         MOV     A,#0x4
   \   00009B   12....       LCALL   ?XSTACK_DISP0_8
   \   00009E   AA82         MOV     R2,DPL
   \   0000A0   AB83         MOV     R3,DPH
   \   0000A2   12....       LCALL   ??SSP_UpdateNwkKey?relay
   1665                  SSP_SwitchNwkKey( 0 );
   \   0000A5                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   0000A5   7900         MOV     R1,#0x0
   \   0000A7   12....       LCALL   ??SSP_SwitchNwkKey?relay
   1666          
   1667                  // clear local copy of key
   1668                  osal_memset(zgPreConfigKey, 0x00, SEC_KEY_LEN);
   \   0000AA                ; Setup parameters for call to function osal_memset
   \   0000AA   7C10         MOV     R4,#0x10
   \   0000AC   7D00         MOV     R5,#0x0
   \   0000AE   7900         MOV     R1,#0x0
   \   0000B0   7404         MOV     A,#0x4
   \   0000B2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B5   AA82         MOV     R2,DPL
   \   0000B7   AB83         MOV     R3,DPH
   \   0000B9   12....       LCALL   ??osal_memset?relay
   \   0000BC   8021         SJMP    ??ZDSecMgrTransportKeyInd_6
   1669                }
   1670              }
   1671              else
   1672              {
   1673                SSP_UpdateNwkKey( ind->key, ind->keySeqNum );
   \                     ??ZDSecMgrTransportKeyInd_5:
   \   0000BE   E5..         MOV     A,?V0 + 2
   \   0000C0   2405         ADD     A,#0x5
   \   0000C2   F8           MOV     R0,A
   \   0000C3   E5..         MOV     A,?V0 + 3
   \   0000C5   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   0000C8   F9           MOV     R1,A
   \   0000C9   AA..         MOV     R2,?V0 + 0
   \   0000CB   AB..         MOV     R3,?V0 + 1
   \   0000CD   12....       LCALL   ??SSP_UpdateNwkKey?relay
   1674                if ( !_NIB.nwkKeyLoaded )
   \   0000D0   90....       MOV     DPTR,#_NIB + 61
   \   0000D3   E0           MOVX    A,@DPTR
   \   0000D4   7009         JNZ     ??ZDSecMgrTransportKeyInd_6
   1675                {
   1676                  SSP_SwitchNwkKey( ind->keySeqNum );
   \   0000D6                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   0000D6   8E82         MOV     DPL,R6
   \   0000D8   8F83         MOV     DPH,R7
   \   0000DA   E0           MOVX    A,@DPTR
   \   0000DB   F9           MOV     R1,A
   \   0000DC   12....       LCALL   ??SSP_SwitchNwkKey?relay
   1677                }
   1678              }
   1679          
   1680              // handle next step in authentication process
   1681              ZDSecMgrAuthNwkKey();
   \                     ??ZDSecMgrTransportKeyInd_6:
   \   0000DF                ; Setup parameters for call to function ZDSecMgrAuthNwkKey
   \   0000DF   12....       LCALL   ??ZDSecMgrAuthNwkKey?relay
   \   0000E2   02....       LJMP    ??ZDSecMgrTransportKeyInd_7 & 0xFFFF
   1682            }
   1683            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   \                     ??ZDSecMgrTransportKeyInd_2:
   \   0000E5   7404         MOV     A,#0x4
   \   0000E7   68           XRL     A,R0
   \   0000E8   7003         JNZ     $+5
   \   0000EA   02....       LJMP    ??ZDSecMgrTransportKeyInd_7 & 0xFFFF
   1684            {
   1685              // This should not happen because TCLK should not be Tx
   1686            }
   1687            else if ( ind->keyType == KEY_TYPE_APP_LINK )
   \   0000ED   7403         MOV     A,#0x3
   \   0000EF   68           XRL     A,R0
   \   0000F0   6003         JZ      $+5
   \   0000F2   02....       LJMP    ??ZDSecMgrTransportKeyInd_7 & 0xFFFF
   1688            {
   1689              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   1690              {
   1691                uint16           ami;
   1692                ZDSecMgrEntry_t* entry;
   1693          
   1694                // get the address index
   1695                if ( ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami ) != ZSuccess )
   \   0000F5                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   0000F5   7402         MOV     A,#0x2
   \   0000F7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FA   AC82         MOV     R4,DPL
   \   0000FC   AD83         MOV     R5,DPH
   \   0000FE   EE           MOV     A,R6
   \   0000FF   FA           MOV     R2,A
   \   000100   EF           MOV     A,R7
   \   000101   FB           MOV     R3,A
   \   000102   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   000105   E9           MOV     A,R1
   \   000106   602D         JZ      ??ZDSecMgrTransportKeyInd_8
   1696                {
   1697                  // store new EXT address
   1698                  ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   \   000108                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000108   7402         MOV     A,#0x2
   \   00010A   12....       LCALL   ?XSTACK_DISP0_8
   \   00010D   8582..       MOV     ?V0 + 2,DPL
   \   000110   8583..       MOV     ?V0 + 3,DPH
   \   000113   78..         MOV     R0,#?V0 + 2
   \   000115   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000118   EE           MOV     A,R6
   \   000119   FC           MOV     R4,A
   \   00011A   EF           MOV     A,R7
   \   00011B   FD           MOV     R5,A
   \   00011C   7AFE         MOV     R2,#-0x2
   \   00011E   7BFF         MOV     R3,#-0x1
   \   000120   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   000123   7402         MOV     A,#0x2
   \   000125   12....       LCALL   ?DEALLOC_XSTACK8
   1699                  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   000128                ; Setup parameters for call to function ZDP_NwkAddrReq
   \   000128   7D00         MOV     R5,#0x0
   \   00012A   7C00         MOV     R4,#0x0
   \   00012C   7900         MOV     R1,#0x0
   \   00012E   EE           MOV     A,R6
   \   00012F   FA           MOV     R2,A
   \   000130   EF           MOV     A,R7
   \   000131   FB           MOV     R3,A
   \   000132   12....       LCALL   ??ZDP_NwkAddrReq?relay
   1700                }
   1701          
   1702                ZDSecMgrEntryLookupAMI( ami, &entry );
   \                     ??ZDSecMgrTransportKeyInd_8:
   \   000135                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000135   85..82       MOV     DPL,?XSP + 0
   \   000138   85..83       MOV     DPH,?XSP + 1
   \   00013B   AC82         MOV     R4,DPL
   \   00013D   AD83         MOV     R5,DPH
   \   00013F   7402         MOV     A,#0x2
   \   000141   12....       LCALL   ?XSTACK_DISP0_8
   \   000144   12....       LCALL   ??Subroutine59_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   000147   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   1703          
   1704                if ( entry == NULL )
   \   00014A   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_159:
   \   00014D   7018         JNZ     ??CrossCallReturnLabel_136
   1705                {
   1706                  // get new entry
   1707                  if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   00014F                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   00014F   85..82       MOV     DPL,?XSP + 0
   \   000152   85..83       MOV     DPH,?XSP + 1
   \   000155   AA82         MOV     R2,DPL
   \   000157   AB83         MOV     R3,DPH
   \   000159   12....       LCALL   ??ZDSecMgrEntryNew?relay
   \   00015C   E9           MOV     A,R1
   \   00015D   7008         JNZ     ??CrossCallReturnLabel_136
   1708                  {
   1709                    // finish setting up entry
   1710                    entry->ami = ami;
   \   00015F   7402         MOV     A,#0x2
   \   000161   12....       LCALL   ?XSTACK_DISP0_8
   \   000164   12....       LCALL   ?Subroutine20 & 0xFFFF
   1711                  }
   1712                }
   1713          
   1714                ZDSecMgrLinkKeySet( ind->srcExtAddr, ind->key );
   \                     ??CrossCallReturnLabel_136:
   \   000167                ; Setup parameters for call to function APSME_LinkKeySet
   \   000167   AC..         MOV     R4,?V0 + 0
   \   000169   AD..         MOV     R5,?V0 + 1
   \   00016B   EE           MOV     A,R6
   \   00016C   FA           MOV     R2,A
   \   00016D   EF           MOV     A,R7
   \   00016E   FB           MOV     R3,A
   \   00016F   12....       LCALL   ??APSME_LinkKeySet?relay
   1715          
   1716          #if defined NV_RESTORE
   1717                ZDSecMgrWriteNV();  // Write the control record for the new established link key to NV.
   \   000172                ; Setup parameters for call to function ZDSecMgrWriteNV
   \   000172   12....       LCALL   ??ZDSecMgrWriteNV?relay
   1718          #endif
   1719              }
   1720            }
   1721          }
   \                     ??ZDSecMgrTransportKeyInd_7:
   \   000175   7414         MOV     A,#0x14
   \   000177   12....       LCALL   ?DEALLOC_XSTACK8
   \   00017A   7F06         MOV     R7,#0x6
   \   00017C   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8A82         MOV     DPL,R2
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine69_0
   \   000006                ; // Fall through to label ??Subroutine69_0
   1722          
   1723          /******************************************************************************
   1724           * @fn          ZDSecMgrUpdateDeviceInd
   1725           *
   1726           * @brief       Process the ZDO_UpdateDeviceInd_t message.
   1727           *
   1728           * @param       ind - [in] ZDO_UpdateDeviceInd_t indication
   1729           *
   1730           * @return      none
   1731           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1732          void ZDSecMgrUpdateDeviceInd( ZDO_UpdateDeviceInd_t* ind )
   \                     ZDSecMgrUpdateDeviceInd:
   1733          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 8
   \   000004   74F8         MOV     A,#-0x8
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1734            ZDSecMgrDevice_t device;
   1735          
   1736            device.nwkAddr    = ind->devAddr;
   \   000009   EA           MOV     A,R2
   \   00000A   240C         ADD     A,#0xc
   \   00000C   F582         MOV     DPL,A
   \   00000E   EB           MOV     A,R3
   \   00000F   12....       LCALL   ??Subroutine71_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_181:
   \   000012   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   000015   12....       LCALL   ??Subroutine63_0 & 0xFFFF
   1737            device.extAddr    = ind->devExtAddr;
   \                     ??CrossCallReturnLabel_132:
   \   000018   EA           MOV     A,R2
   \   000019   2404         ADD     A,#0x4
   \   00001B   F8           MOV     R0,A
   \   00001C   EB           MOV     A,R3
   \   00001D   3400         ADDC    A,#0x0
   \   00001F   F9           MOV     R1,A
   \   000020   7402         MOV     A,#0x2
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   12....       LCALL   ?Subroutine14 & 0xFFFF
   1738            device.parentAddr = ind->srcAddr;
   \                     ??CrossCallReturnLabel_1:
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   12....       LCALL   ??Subroutine63_0 & 0xFFFF
   1739            device.devStatus  = DEV_SEC_INIT_STATUS;
   \                     ??CrossCallReturnLabel_133:
   \   00002E   7407         MOV     A,#0x7
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   7404         MOV     A,#0x4
   \   000035   F0           MOVX    @DPTR,A
   1740            device.secure     = FALSE;
   \   000036   7406         MOV     A,#0x6
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   E4           CLR     A
   \   00003C   F0           MOVX    @DPTR,A
   1741          
   1742            // Trust Center should identify the type of JOIN/REJOIN and
   1743            // Transport the NWK key accordingly, it will only be transported for:
   1744            //              APSME_UD_STANDARD_UNSECURED_JOIN
   1745            //   OR         APSME_UD_STANDARD_TRUST_CENTER_REJOIN
   1746            if ( ind->status != APSME_UD_DEVICE_LEFT )
   \   00003D   EA           MOV     A,R2
   \   00003E   240E         ADD     A,#0xe
   \   000040   F582         MOV     DPL,A
   \   000042   EB           MOV     A,R3
   \   000043   12....       LCALL   ??Subroutine71_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_182:
   \   000046   E0           MOVX    A,@DPTR
   \   000047   F8           MOV     R0,A
   \   000048   7402         MOV     A,#0x2
   \   00004A   68           XRL     A,R0
   \   00004B   6020         JZ      ??ZDSecMgrUpdateDeviceInd_0
   1747            {
   1748              if ( ind->status == APSME_UD_STANDARD_SECURED_REJOIN )
   \   00004D   E8           MOV     A,R0
   \   00004E   7010         JNZ     ??ZDSecMgrUpdateDeviceInd_1
   1749              {
   1750                device.devStatus &= ~DEV_SEC_INIT_STATUS;
   1751                device.devStatus |=  DEV_SEC_AUTH_STATUS;
   \   000050   7407         MOV     A,#0x7
   \   000052   12....       LCALL   ?XSTACK_DISP0_8
   \   000055   7408         MOV     A,#0x8
   \   000057   F0           MOVX    @DPTR,A
   1752                device.secure = TRUE;
   \   000058   7406         MOV     A,#0x6
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   7401         MOV     A,#0x1
   \   00005F   F0           MOVX    @DPTR,A
   1753              }
   1754          
   1755              ZDSecMgrDeviceJoin( &device );
   \                     ??ZDSecMgrUpdateDeviceInd_1:
   \   000060                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000060   85..82       MOV     DPL,?XSP + 0
   \   000063   85..83       MOV     DPH,?XSP + 1
   \   000066   AA82         MOV     R2,DPL
   \   000068   AB83         MOV     R3,DPH
   \   00006A   12....       LCALL   ??ZDSecMgrDeviceJoin?relay
   1756            }
   1757          }
   \                     ??ZDSecMgrUpdateDeviceInd_0:
   \   00006D   02....       LJMP    ?Subroutine4 & 0xFFFF
   1758          
   1759          /******************************************************************************
   1760           * @fn          ZDSecMgrRemoveDeviceInd
   1761           *
   1762           * @brief       Process the ZDO_RemoveDeviceInd_t message.
   1763           *
   1764           * @param       ind - [in] ZDO_RemoveDeviceInd_t indication
   1765           *
   1766           * @return      none
   1767           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1768          void ZDSecMgrRemoveDeviceInd( ZDO_RemoveDeviceInd_t* ind )
   \                     ZDSecMgrRemoveDeviceInd:
   1769          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1770            ZDSecMgrDevice_t device;
   1771          
   1772            // only accept from Trust Center
   1773            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   00000A   8A82         MOV     DPL,R2
   \   00000C   8B83         MOV     DPH,R3
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   12....       LCALL   ??Subroutine69_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_157:
   \   000013   7026         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   1774            {
   1775              // look up NWK address
   1776              if ( APSME_LookupNwkAddr( ind->childExtAddr, &device.nwkAddr ) == TRUE )
   \   000015   EA           MOV     A,R2
   \   000016   2404         ADD     A,#0x4
   \   000018   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   00001B   12....       LCALL   ??APSME_LookupNwkAddr?relay
   \   00001E   E9           MOV     A,R1
   \   00001F   6401         XRL     A,#0x1
   \   000021   7018         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   1777              {
   1778                device.parentAddr = NLME_GetShortAddr();
   \   000023                ; Setup parameters for call to function NLME_GetShortAddr
   \   000023   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000026   7404         MOV     A,#0x4
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   12....       LCALL   ??Subroutine57_0 & 0xFFFF
   1779                device.extAddr    = ind->childExtAddr;
   1780          
   1781                // remove device
   1782                ZDSecMgrDeviceRemove( &device );
   1783              }
   1784            }
   \                     ??CrossCallReturnLabel_88:
   \   00002E   12....       LCALL   ?XSTACK_DISP0_8
   \   000031   EE           MOV     A,R6
   \   000032   F0           MOVX    @DPTR,A
   \   000033   A3           INC     DPTR
   \   000034   EF           MOV     A,R7
   \   000035   12....       LCALL   ??Subroutine64_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_145:
   \   000038   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   1785          }
   \                     ??ZDSecMgrRemoveDeviceInd_0:
   \   00003B   02....       LJMP    ?Subroutine8 & 0xFFFF
   1786          
   1787          /******************************************************************************
   1788           * @fn          ZDSecMgrRequestKeyInd
   1789           *
   1790           * @brief       Process the ZDO_RequestKeyInd_t message.
   1791           *
   1792           * @param       ind - [in] ZDO_RequestKeyInd_t indication
   1793           *
   1794           * @return      none
   1795           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1796          void ZDSecMgrRequestKeyInd( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrRequestKeyInd:
   1797          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1798            if ( ind->keyType == KEY_TYPE_NWK )
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F8           MOV     R0,A
   \   00000E   7401         MOV     A,#0x1
   \   000010   68           XRL     A,R0
   \   000011   6008         JZ      ??ZDSecMgrRequestKeyInd_0
   1799            {
   1800            }
   1801            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   \   000013   7402         MOV     A,#0x2
   \   000015   68           XRL     A,R0
   \   000016   7003         JNZ     ??ZDSecMgrRequestKeyInd_0
   1802            {
   1803              ZDSecMgrAppKeyReq( ind );
   \   000018                ; Setup parameters for call to function ZDSecMgrAppKeyReq
   \   000018   12....       LCALL   ??ZDSecMgrAppKeyReq?relay
   1804            }
   1805            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   1806            {
   1807            }
   1808            //else ignore
   1809          }
   \                     ??ZDSecMgrRequestKeyInd_0:
   \   00001B   02....       LJMP    ??Subroutine61_0 & 0xFFFF
   1810          
   1811          /******************************************************************************
   1812           * @fn          ZDSecMgrSwitchKeyInd
   1813           *
   1814           * @brief       Process the ZDO_SwitchKeyInd_t message.
   1815           *
   1816           * @param       ind - [in] ZDO_SwitchKeyInd_t indication
   1817           *
   1818           * @return      none
   1819           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1820          void ZDSecMgrSwitchKeyInd( ZDO_SwitchKeyInd_t* ind )
   \                     ZDSecMgrSwitchKeyInd:
   1821          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1822            SSP_SwitchNwkKey( ind->keySeqNum );
   \   000004                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F9           MOV     R1,A
   \   00000E   12....       LCALL   ??SSP_SwitchNwkKey?relay
   1823          
   1824            // Save if nv
   1825            ZDApp_NVUpdate();
   \   000011                ; Setup parameters for call to function ZDApp_NVUpdate
   \   000011   12....       LCALL   ??ZDApp_NVUpdate?relay
   1826          }
   \   000014   02....       LJMP    ??Subroutine61_0 & 0xFFFF
   1827          
   1828          #if ( ZG_BUILD_COORDINATOR_TYPE )
   1829          /******************************************************************************
   1830           * @fn          ZDSecMgrUpdateNwkKey
   1831           *
   1832           * @brief       Load a new NWK key and trigger a network update to the dstAddr.
   1833           *
   1834           * @param       key       - [in] new NWK key
   1835           * @param       keySeqNum - [in] new NWK key sequence number
   1836           *
   1837           * @return      ZStatus_t
   1838           */
   1839          ZStatus_t ZDSecMgrUpdateNwkKey( uint8* key, uint8 keySeqNum, uint16 dstAddr )
   1840          {
   1841            ZStatus_t               status;
   1842            APSME_TransportKeyReq_t req;
   1843          
   1844            // initialize common elements of local variables
   1845            req.keyType   = KEY_TYPE_NWK;
   1846          
   1847            req.dstAddr   = dstAddr;
   1848            req.keySeqNum = keySeqNum;
   1849            req.key       = key;
   1850            req.extAddr   = NULL;
   1851            req.nwkSecure = TRUE;
   1852            req.tunnel    = NULL;
   1853          
   1854            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   1855            {
   1856              // Broadcast transport NWK key
   1857              if (( dstAddr == NWK_BROADCAST_SHORTADDR_DEVALL ) ||
   1858                  ( dstAddr == NWK_BROADCAST_SHORTADDR_DEVZCZR) ||
   1859                  ( dstAddr == NWK_BROADCAST_SHORTADDR_DEVRXON))
   1860              {
   1861                req.apsSecure = FALSE;
   1862                status = APSME_TransportKeyReq( &req );
   1863              }
   1864              else
   1865              {
   1866                AddrMgrEntry_t          addrEntry;
   1867          
   1868                addrEntry.user = ADDRMGR_USER_SECURITY;
   1869                addrEntry.nwkAddr = dstAddr;
   1870          
   1871                status = ZFailure;
   1872          
   1873                if ( AddrMgrEntryLookupNwk( &addrEntry ) == TRUE )
   1874                {
   1875                  req.extAddr = addrEntry.extAddr;
   1876                  req.apsSecure = TRUE;
   1877                  status = APSME_TransportKeyReq( &req );
   1878                }
   1879              }
   1880            }
   1881            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   1882            {
   1883              req.apsSecure = FALSE;
   1884              status = APSME_TransportKeyReq( &req );
   1885            }
   1886          
   1887            SSP_UpdateNwkKey( key, keySeqNum );
   1888          
   1889            // Save if nv
   1890            ZDApp_NVUpdate();
   1891          
   1892            return status;
   1893          }
   1894          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   1895          
   1896          #if ( ZG_BUILD_COORDINATOR_TYPE )
   1897          /******************************************************************************
   1898           * @fn          ZDSecMgrSwitchNwkKey
   1899           *
   1900           * @brief       Causes the NWK key to switch via a network command to the dstAddr.
   1901           *
   1902           * @param       keySeqNum - [in] new NWK key sequence number
   1903           *
   1904           * @return      ZStatus_t
   1905           */
   1906          ZStatus_t ZDSecMgrSwitchNwkKey( uint8 keySeqNum, uint16 dstAddr )
   1907          {
   1908            ZStatus_t            status;
   1909            APSME_SwitchKeyReq_t req;
   1910          
   1911            // initialize common elements of local variables
   1912            req.dstAddr = dstAddr;
   1913            req.keySeqNum = keySeqNum;
   1914          
   1915            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   1916            {
   1917              // Broadcast switch NWK key
   1918              if (( dstAddr == NWK_BROADCAST_SHORTADDR_DEVALL ) ||
   1919                  ( dstAddr == NWK_BROADCAST_SHORTADDR_DEVZCZR) ||
   1920                  ( dstAddr == NWK_BROADCAST_SHORTADDR_DEVRXON))
   1921              {
   1922                req.apsSecure = FALSE;
   1923                status = APSME_SwitchKeyReq( &req );
   1924              }
   1925              else
   1926              {
   1927                AddrMgrEntry_t          addrEntry;
   1928          
   1929                addrEntry.user = ADDRMGR_USER_SECURITY;
   1930                addrEntry.nwkAddr = dstAddr;
   1931          
   1932                status = ZFailure;
   1933          
   1934                if ( AddrMgrEntryLookupNwk( &addrEntry ) == TRUE )
   1935                {
   1936                  req.dstAddr = addrEntry.nwkAddr;
   1937                  req.apsSecure = TRUE;
   1938                  status = APSME_SwitchKeyReq( &req );
   1939                }
   1940              }
   1941            }
   1942            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   1943            {
   1944              req.apsSecure = FALSE;
   1945              status = APSME_SwitchKeyReq( &req );
   1946            }
   1947          
   1948            SSP_SwitchNwkKey( keySeqNum );
   1949          
   1950            // Save if nv
   1951            ZDApp_NVUpdate();
   1952          
   1953            return status;
   1954          }
   1955          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   1956          
   1957          /******************************************************************************
   1958           * @fn          ZDSecMgrRequestAppKey
   1959           *
   1960           * @brief       Request an application key with partner.
   1961           *
   1962           * @param       partExtAddr - [in] partner extended address
   1963           *
   1964           * @return      ZStatus_t
   1965           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1966          ZStatus_t ZDSecMgrRequestAppKey( uint8 *partExtAddr )
   \                     ZDSecMgrRequestAppKey:
   1967          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 4
   \   000004   74FC         MOV     A,#-0x4
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1968            ZStatus_t status;
   1969            APSME_RequestKeyReq_t req;
   1970          
   1971            req.dstAddr = 0;
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   E4           CLR     A
   \   000010   F0           MOVX    @DPTR,A
   1972            req.keyType = KEY_TYPE_APP_MASTER;
   \   000011   04           INC     A
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   7402         MOV     A,#0x2
   \   000017   F0           MOVX    @DPTR,A
   1973          
   1974            req.partExtAddr = partExtAddr;
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   12....       LCALL   ?Subroutine10 & 0xFFFF
   1975            status = APSME_RequestKeyReq( &req );
   1976          
   1977            return status;
   \                     ??CrossCallReturnLabel_139:
   \   00001E   12....       LCALL   ??APSME_RequestKeyReq?relay
   \   000021   7404         MOV     A,#0x4
   \   000023   02....       LJMP    ??Subroutine60_0 & 0xFFFF
   1978          }
   1979          
   1980          #if ( ZG_BUILD_JOINING_TYPE )
   1981          /******************************************************************************
   1982           * @fn          ZDSecMgrSetupPartner
   1983           *
   1984           * @brief       Setup for application key partner.
   1985           *
   1986           * @param       partNwkAddr - [in] partner network address
   1987           *
   1988           * @return      ZStatus_t
   1989           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1990          ZStatus_t ZDSecMgrSetupPartner( uint16 partNwkAddr, uint8* partExtAddr )
   \                     ZDSecMgrSetupPartner:
   1991          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1992            AddrMgrEntry_t entry;
   1993            ZStatus_t      status;
   1994          
   1995            status = ZFailure;
   \   000012   75..01       MOV     ?V0 + 2,#0x1
   1996          
   1997            // update the address manager
   1998            entry.user    = ADDRMGR_USER_SECURITY;
   \   000015   85..82       MOV     DPL,?XSP + 0
   \   000018   85..83       MOV     DPH,?XSP + 1
   \   00001B   7402         MOV     A,#0x2
   \   00001D   F0           MOVX    @DPTR,A
   1999            entry.nwkAddr = partNwkAddr;
   \   00001E   14           DEC     A
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   12....       LCALL   ?Subroutine18 & 0xFFFF
   2000            AddrMgrExtAddrSet( entry.extAddr, partExtAddr );
   \                     ??CrossCallReturnLabel_10:
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   AA82         MOV     R2,DPL
   \   00002A   AB83         MOV     R3,DPH
   \   00002C   12....       LCALL   ??AddrMgrExtAddrSet?relay
   2001          
   2002            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   00002F                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   00002F   85..82       MOV     DPL,?XSP + 0
   \   000032   85..83       MOV     DPH,?XSP + 1
   \   000035   AA82         MOV     R2,DPL
   \   000037   AB83         MOV     R3,DPH
   \   000039   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   00003C   E9           MOV     A,R1
   \   00003D   6401         XRL     A,#0x1
   \   00003F   7038         JNZ     ??ZDSecMgrSetupPartner_0
   2003            {
   2004              status = ZSuccess;
   \   000041   75..00       MOV     ?V0 + 2,#0x0
   2005          
   2006              // check for address discovery
   2007              if ( partNwkAddr == INVALID_NODE_ADDR )
   \   000044   74FE         MOV     A,#-0x2
   \   000046   65..         XRL     A,?V0 + 0
   \   000048   7004         JNZ     ??ZDSecMgrSetupPartner_1
   \   00004A   74FF         MOV     A,#-0x1
   \   00004C   65..         XRL     A,?V0 + 1
   \                     ??ZDSecMgrSetupPartner_1:
   \   00004E   700F         JNZ     ??ZDSecMgrSetupPartner_2
   2008              {
   2009                status = ZDP_NwkAddrReq( partExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   000050                ; Setup parameters for call to function ZDP_NwkAddrReq
   \   000050   7D00         MOV     R5,#0x0
   \   000052   7C00         MOV     R4,#0x0
   \   000054   7900         MOV     R1,#0x0
   \   000056   EE           MOV     A,R6
   \   000057   FA           MOV     R2,A
   \   000058   EF           MOV     A,R7
   \   000059   FB           MOV     R3,A
   \   00005A   12....       LCALL   ??ZDP_NwkAddrReq?relay
   \   00005D   8017         SJMP    ??ZDSecMgrSetupPartner_3
   2010              }
   2011              else if ( !AddrMgrExtAddrValid( partExtAddr ) )
   \                     ??ZDSecMgrSetupPartner_2:
   \   00005F                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   00005F   EE           MOV     A,R6
   \   000060   FA           MOV     R2,A
   \   000061   EF           MOV     A,R7
   \   000062   FB           MOV     R3,A
   \   000063   12....       LCALL   ??AddrMgrExtAddrValid?relay
   \   000066   E9           MOV     A,R1
   \   000067   7010         JNZ     ??ZDSecMgrSetupPartner_0
   2012              {
   2013                status = ZDP_IEEEAddrReq( partNwkAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   000069                ; Setup parameters for call to function ZDP_IEEEAddrReq
   \   000069   7D00         MOV     R5,#0x0
   \   00006B   7C00         MOV     R4,#0x0
   \   00006D   7900         MOV     R1,#0x0
   \   00006F   AA..         MOV     R2,?V0 + 0
   \   000071   AB..         MOV     R3,?V0 + 1
   \   000073   12....       LCALL   ??ZDP_IEEEAddrReq?relay
   \                     ??ZDSecMgrSetupPartner_3:
   \   000076   E9           MOV     A,R1
   \   000077   F5..         MOV     ?V0 + 2,A
   2014              }
   2015            }
   2016          
   2017            return status;
   \                     ??ZDSecMgrSetupPartner_0:
   \   000079   A9..         MOV     R1,?V0 + 2
   \   00007B   740D         MOV     A,#0xd
   \   00007D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000080   7F03         MOV     R7,#0x3
   \   000082   02....       LJMP    ?BANKED_LEAVE_XDATA
   2018          }
   2019          #endif // ( ZG_BUILD_JOINING_TYPE )
   2020          
   2021          #if ( ZG_BUILD_COORDINATOR_TYPE )
   2022          /******************************************************************************
   2023           * @fn          ZDSecMgrAppKeyTypeSet
   2024           *
   2025           * @brief       Set application key type.
   2026           *
   2027           * @param       keyType - [in] application key type (KEY_TYPE_APP_MASTER@2 or
   2028           *                                                   KEY_TYPE_APP_LINK@3
   2029           *
   2030           * @return      ZStatus_t
   2031           */
   2032          ZStatus_t ZDSecMgrAppKeyTypeSet( uint8 keyType )
   2033          {
   2034            if ( keyType == KEY_TYPE_APP_LINK )
   2035            {
   2036              ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;
   2037            }
   2038            else
   2039            {
   2040              ZDSecMgrAppKeyType = KEY_TYPE_APP_MASTER;
   2041            }
   2042          
   2043            return ZSuccess;
   2044          }
   2045          #endif
   2046          
   2047          /******************************************************************************
   2048           * ZigBee Device Security Manager - Stub Implementations
   2049           */
   2050          
   2051          
   2052          /******************************************************************************
   2053           * @fn          ZDSecMgrLinkKeySet (stubs APSME_LinkKeySet)
   2054           *
   2055           * @brief       Set <APSME_LinkKeyData_t> for specified NWK address.
   2056           *
   2057           * @param       extAddr - [in] EXT address
   2058           * @param       data    - [in] APSME_LinkKeyData_t
   2059           *
   2060           * @return      ZStatus_t
   2061           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   000003                REQUIRE ??Subroutine58_0
   \   000003                ; // Fall through to label ??Subroutine58_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2062          ZStatus_t ZDSecMgrLinkKeySet( uint8* extAddr, uint8* key )
   \                     APSME_LinkKeySet:
   2063          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   2064            ZStatus_t status;
   2065            ZDSecMgrEntry_t* entry;
   2066            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   2067            uint16 Index;
   2068          
   2069            // lookup entry index for specified EXT address
   2070            status = ZDSecMgrEntryLookupExtGetIndex( extAddr, &entry, &Index );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExtGetIndex
   \   00000E   7402         MOV     A,#0x2
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   8582..       MOV     ?V0 + 0,DPL
   \   000016   8583..       MOV     ?V0 + 1,DPH
   \   000019   78..         MOV     R0,#?V0 + 0
   \   00001B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001E   7402         MOV     A,#0x2
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   AC82         MOV     R4,DPL
   \   000025   AD83         MOV     R5,DPH
   \   000027   12....       LCALL   ??ZDSecMgrEntryLookupExtGetIndex?relay
   \   00002A   7402         MOV     A,#0x2
   \   00002C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00002F   E9           MOV     A,R1
   \   000030   F5..         MOV     ?V0 + 0,A
   2071          
   2072            if ( status == ZSuccess )
   \   000032   6003         JZ      $+5
   \   000034   02....       LJMP    ??CrossCallReturnLabel_149 & 0xFFFF
   2073            {
   2074              // point to NV item
   2075              entry->keyNvId = ZCD_NV_APS_LINK_KEY_DATA_START + Index;
   \   000037   7402         MOV     A,#0x2
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   2401         ADD     A,#0x1
   \   00003F   F8           MOV     R0,A
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   3402         ADDC    A,#0x2
   \   000044   F9           MOV     R1,A
   \   000045   85..82       MOV     DPL,?XSP + 0
   \   000048   85..83       MOV     DPH,?XSP + 1
   \   00004B   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   12....       LCALL   ??Subroutine63_0 & 0xFFFF
   2076          
   2077              pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \                     ??CrossCallReturnLabel_134:
   \   000053                ; Setup parameters for call to function osal_mem_alloc
   \   000053   7A18         MOV     R2,#0x18
   \   000055   7B00         MOV     R3,#0x0
   \   000057   12....       LCALL   ??osal_mem_alloc?relay
   \   00005A   8A..         MOV     ?V0 + 2,R2
   \   00005C   8B..         MOV     ?V0 + 3,R3
   2078          
   2079              if (pApsLinkKey != NULL)
   \   00005E   EA           MOV     A,R2
   \   00005F   45..         ORL     A,?V0 + 3
   \   000061   7003         JNZ     $+5
   \   000063   02....       LJMP    ??CrossCallReturnLabel_149 & 0xFFFF
   2080              {
   2081                // read the key form NV, keyNvId must be ZCD_NV_APS_LINK_KEY_DATA_START based
   2082                osal_nv_read( entry->keyNvId, 0,
   2083                             sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \   000066                ; Setup parameters for call to function osal_nv_read
   \   000066   78..         MOV     R0,#?V0 + 2
   \   000068   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006B   75..18       MOV     ?V0 + 4,#0x18
   \   00006E   75..00       MOV     ?V0 + 5,#0x0
   \   000071   78..         MOV     R0,#?V0 + 4
   \   000073   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000076   7C00         MOV     R4,#0x0
   \   000078   7D00         MOV     R5,#0x0
   \   00007A   7404         MOV     A,#0x4
   \   00007C   12....       LCALL   ?XSTACK_DISP0_8
   \   00007F   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_108:
   \   000082   12....       LCALL   ??osal_nv_read?relay
   \   000085   7404         MOV     A,#0x4
   \   000087   12....       LCALL   ?DEALLOC_XSTACK8
   2084          
   2085                // set new values of the key
   2086                osal_memcpy( pApsLinkKey->key, key, SEC_KEY_LEN );
   \   00008A                ; Setup parameters for call to function osal_memcpy
   \   00008A   8E..         MOV     ?V0 + 4,R6
   \   00008C   8F..         MOV     ?V0 + 5,R7
   \   00008E   75..00       MOV     ?V0 + 6,#0x0
   \   000091   78..         MOV     R0,#?V0 + 4
   \   000093   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000096   7C10         MOV     R4,#0x10
   \   000098   7D00         MOV     R5,#0x0
   \   00009A   AA..         MOV     R2,?V0 + 2
   \   00009C   AB..         MOV     R3,?V0 + 3
   \   00009E   12....       LCALL   ??osal_memcpy?relay
   \   0000A1   7403         MOV     A,#0x3
   \   0000A3   12....       LCALL   ?DEALLOC_XSTACK8
   2087                pApsLinkKey->rxFrmCntr = 0;
   \   0000A6   E5..         MOV     A,?V0 + 2
   \   0000A8   2414         ADD     A,#0x14
   \   0000AA   12....       LCALL   ?Subroutine13 & 0xFFFF
   2088                pApsLinkKey->txFrmCntr = 0;
   \                     ??CrossCallReturnLabel_150:
   \   0000AD   E5..         MOV     A,?V0 + 2
   \   0000AF   2410         ADD     A,#0x10
   \   0000B1   12....       LCALL   ?Subroutine13 & 0xFFFF
   2089          
   2090                osal_nv_write( entry->keyNvId, 0,
   2091                              sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \                     ??CrossCallReturnLabel_151:
   \   0000B4                ; Setup parameters for call to function osal_nv_write
   \   0000B4   78..         MOV     R0,#?V0 + 2
   \   0000B6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B9   75..18       MOV     ?V0 + 4,#0x18
   \   0000BC   75..00       MOV     ?V0 + 5,#0x0
   \   0000BF   78..         MOV     R0,#?V0 + 4
   \   0000C1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C4   7C00         MOV     R4,#0x0
   \   0000C6   7D00         MOV     R5,#0x0
   \   0000C8   7404         MOV     A,#0x4
   \   0000CA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CD   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_109:
   \   0000D0   12....       LCALL   ??osal_nv_write?relay
   \   0000D3   7404         MOV     A,#0x4
   \   0000D5   12....       LCALL   ?DEALLOC_XSTACK8
   2092          
   2093                // clear copy of key in RAM
   2094                osal_memset(pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t));
   \   0000D8                ; Setup parameters for call to function osal_memset
   \   0000D8   7C18         MOV     R4,#0x18
   \   0000DA   7D00         MOV     R5,#0x0
   \   0000DC   7900         MOV     R1,#0x0
   \   0000DE   AA..         MOV     R2,?V0 + 2
   \   0000E0   AB..         MOV     R3,?V0 + 3
   \   0000E2   12....       LCALL   ??osal_memset?relay
   2095          
   2096                osal_mem_free(pApsLinkKey);
   \   0000E5                ; Setup parameters for call to function osal_mem_free
   \   0000E5   AA..         MOV     R2,?V0 + 2
   \   0000E7   AB..         MOV     R3,?V0 + 3
   \   0000E9   12....       LCALL   ??osal_mem_free?relay
   \   0000EC   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   0000EF   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   0000F2   75F009       MOV     B,#0x9
   \   0000F5   A4           MUL     AB
   \   0000F6   F8           MOV     R0,A
   \   0000F7   AAF0         MOV     R2,B
   \   0000F9   75F009       MOV     B,#0x9
   \   0000FC   E9           MOV     A,R1
   \   0000FD   A4           MUL     AB
   \   0000FE   2A           ADD     A,R2
   \   0000FF   F9           MOV     R1,A
   \   000100   74..         MOV     A,#ApsLinkKeyFrmCntr & 0xff
   \   000102   28           ADD     A,R0
   \   000103   FA           MOV     R2,A
   \   000104   74..         MOV     A,#(ApsLinkKeyFrmCntr >> 8) & 0xff
   \   000106   39           ADDC    A,R1
   \   000107   FB           MOV     R3,A
   \   000108   EA           MOV     A,R2
   \   000109   24F7         ADD     A,#-0x9
   \   00010B   F582         MOV     DPL,A
   \   00010D   EB           MOV     A,R3
   \   00010E   34ED         ADDC    A,#-0x13
   \   000110   12....       LCALL   ??Subroutine65_0 & 0xFFFF
   2097          
   2098                // set initial values for counters in RAM
   2099                ApsLinkKeyFrmCntr[entry->keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr = 0;
   2100                ApsLinkKeyFrmCntr[entry->keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr = 0;
   \                     ??CrossCallReturnLabel_148:
   \   000113   EA           MOV     A,R2
   \   000114   24FB         ADD     A,#-0x5
   \   000116   F582         MOV     DPL,A
   \   000118   EB           MOV     A,R3
   \   000119   34ED         ADDC    A,#-0x13
   \   00011B   12....       LCALL   ??Subroutine65_0 & 0xFFFF
   2101              }
   2102            }
   2103          
   2104            return status;
   \                     ??CrossCallReturnLabel_149:
   \   00011E   A9..         MOV     R1,?V0 + 0
   \   000120   7404         MOV     A,#0x4
   \   000122                REQUIRE ?Subroutine5
   \   000122                ; // Fall through to label ?Subroutine5
   2105          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F07         MOV     R7,#0x7
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   F582         MOV     DPL,A
   \   000002   E5..         MOV     A,?V0 + 3
   \   000004   3400         ADDC    A,#0x0
   \   000006                REQUIRE ??Subroutine65_0
   \   000006                ; // Fall through to label ??Subroutine65_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine65_0:
   \   000000   F583         MOV     DPH,A
   \   000002                REQUIRE ??Subroutine66_0
   \   000002                ; // Fall through to label ??Subroutine66_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine66_0:
   \   000000   E4           CLR     A
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   F0           MOVX    @DPTR,A
   \   000004   A3           INC     DPTR
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   F0           MOVX    @DPTR,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET
   2106          
   2107          /******************************************************************************
   2108           * @fn          ZDSecMgrAuthenticationSet
   2109           *
   2110           * @brief       Mark the specific device as authenticated or not
   2111           *
   2112           * @param       extAddr - [in] EXT address
   2113           * @param       option  - [in] authenticated or not
   2114           *
   2115           * @return      ZStatus_t
   2116           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2117          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option )
   \                     ZDSecMgrAuthenticationSet:
   2118          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   2119            ZStatus_t        status;
   2120            ZDSecMgrEntry_t* entry;
   2121          
   2122          
   2123            // lookup entry index for specified EXT address
   2124            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   85..82       MOV     DPL,?XSP + 0
   \   00000F   85..83       MOV     DPH,?XSP + 1
   \   000012   AC82         MOV     R4,DPL
   \   000014   AD83         MOV     R5,DPH
   \   000016   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   000019   E9           MOV     A,R1
   2125          
   2126            if ( status == ZSuccess )
   \   00001A   7005         JNZ     ??ZDSecMgrAuthenticationSet_0
   2127            {
   2128              entry->authenticateOption = option;
   \   00001C   12....       LCALL   ?Subroutine25 & 0xFFFF
   2129            }
   \                     ??CrossCallReturnLabel_16:
   \   00001F   EE           MOV     A,R6
   \   000020   F0           MOVX    @DPTR,A
   2130          
   2131            return status;
   \                     ??ZDSecMgrAuthenticationSet_0:
   \   000021                REQUIRE ?Subroutine7
   \   000021                ; // Fall through to label ?Subroutine7
   2132          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET
   2133          
   2134          /******************************************************************************
   2135           * @fn          ZDSecMgrAuthenticationCheck
   2136           *
   2137           * @brief       Check if the specific device has been authenticated or not
   2138           *              For non-trust center device, always return TRUE
   2139           *
   2140           * @param       shortAddr - [in] short address
   2141           *
   2142           * @return      TRUE @ authenticated with CBKE
   2143           *              FALSE @ not authenticated
   2144           */
   2145          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2146          uint8 ZDSecMgrAuthenticationCheck( uint16 shortAddr )
   \                     ZDSecMgrAuthenticationCheck:
   2147          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV     A,#-0xc
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2148          #if defined (TC_LINKKEY_JOIN)
   2149          
   2150            ZDSecMgrEntry_t* entry;
   2151            uint8 extAddr[Z_EXTADDR_LEN];
   2152          
   2153            // If the local device is not the trust center, always return TRUE
   2154            APSME_GetRequest( apsTrustCenterAddress, 0, extAddr );
   \   00000E                ; Setup parameters for call to function APSME_GetRequest
   \   00000E   7404         MOV     A,#0x4
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   AC82         MOV     R4,DPL
   \   000015   AD83         MOV     R5,DPH
   \   000017   7A00         MOV     R2,#0x0
   \   000019   7B00         MOV     R3,#0x0
   \   00001B   79AB         MOV     R1,#-0x55
   \   00001D   12....       LCALL   ??APSME_GetRequest?relay
   2155            if ( ! osal_ExtAddrEqual( extAddr , NLME_GetExtAddr() ) )
   \   000020                ; Setup parameters for call to function sAddrExtCmp
   \   000020                ; Setup parameters for call to function NLME_GetExtAddr
   \   000020   12....       LCALL   ??NLME_GetExtAddr?relay
   \   000023   EA           MOV     A,R2
   \   000024   FC           MOV     R4,A
   \   000025   EB           MOV     A,R3
   \   000026   FD           MOV     R5,A
   \   000027   7404         MOV     A,#0x4
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   AA82         MOV     R2,DPL
   \   00002E   AB83         MOV     R3,DPH
   \   000030   12....       LCALL   ??sAddrExtCmp?relay
   \   000033   E9           MOV     A,R1
   \   000034   6050         JZ      ??ZDSecMgrAuthenticationCheck_0
   2156            {
   2157              return TRUE;
   2158            }
   2159            // Otherwise, check the authentication option
   2160            else if ( AddrMgrExtAddrLookup( shortAddr, extAddr ) )
   \   000036                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   000036   7404         MOV     A,#0x4
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   AC82         MOV     R4,DPL
   \   00003D   AD83         MOV     R5,DPH
   \   00003F   EE           MOV     A,R6
   \   000040   FA           MOV     R2,A
   \   000041   EF           MOV     A,R7
   \   000042   FB           MOV     R3,A
   \   000043   12....       LCALL   ??AddrMgrExtAddrLookup?relay
   \   000046   E9           MOV     A,R1
   \   000047   601F         JZ      ??ZDSecMgrAuthenticationCheck_1
   2161            {
   2162              // lookup entry index for specified EXT address
   2163              if ( ZDSecMgrEntryLookupExt( extAddr, &entry ) == ZSuccess )
   \   000049                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   000049   85..82       MOV     DPL,?XSP + 0
   \   00004C   85..83       MOV     DPH,?XSP + 1
   \   00004F   AC82         MOV     R4,DPL
   \   000051   AD83         MOV     R5,DPH
   \   000053   7404         MOV     A,#0x4
   \   000055   12....       LCALL   ?XSTACK_DISP0_8
   \   000058   AA82         MOV     R2,DPL
   \   00005A   AB83         MOV     R3,DPH
   \   00005C   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   00005F   E9           MOV     A,R1
   \   000060   700C         JNZ     ??ZDSecMgrAuthenticationCheck_2
   2164              {
   2165                if ( entry->authenticateOption != ZDSecMgr_Not_Authenticated )
   \   000062   12....       LCALL   ?Subroutine25 & 0xFFFF
   2166                {
   2167                  return TRUE;
   2168                }
   2169                else
   2170                {
   2171                  return FALSE;
   2172                }
   2173              }
   \                     ??CrossCallReturnLabel_17:
   \   000065   E0           MOVX    A,@DPTR
   \   000066   701E         JNZ     ??ZDSecMgrAuthenticationCheck_0
   2174              else
   2175              {
   2176                // it may have been secured with TCLK only
   2177                uint16    ami;
   2178          
   2179                // lookup address index in address manager
   2180                if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   2181                {
   2182                  return TRUE;
   2183                }
   2184              }
   2185            }
   2186            return FALSE;
   \                     ??ZDSecMgrAuthenticationCheck_1:
   \   000068   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAuthenticationCheck_3:
   \   00006A   740C         MOV     A,#0xc
   \   00006C   80..         SJMP    ??Subroutine67_0
   \                     ??ZDSecMgrAuthenticationCheck_2:
   \   00006E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00006E   7402         MOV     A,#0x2
   \   000070   12....       LCALL   ?XSTACK_DISP0_8
   \   000073   AC82         MOV     R4,DPL
   \   000075   AD83         MOV     R5,DPH
   \   000077   7404         MOV     A,#0x4
   \   000079   12....       LCALL   ?XSTACK_DISP0_8
   \   00007C   AA82         MOV     R2,DPL
   \   00007E   AB83         MOV     R3,DPH
   \   000080   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   000083   E9           MOV     A,R1
   \   000084   70E2         JNZ     ??ZDSecMgrAuthenticationCheck_1
   \                     ??ZDSecMgrAuthenticationCheck_0:
   \   000086   7901         MOV     R1,#0x1
   \   000088   80E0         SJMP    ??ZDSecMgrAuthenticationCheck_3
   2187          
   2188          #else
   2189            (void)shortAddr;  // Intentionally unreferenced parameter
   2190          
   2191            // For non AMI/SE Profile, perform no check and always return TRUE.
   2192            return TRUE;
   2193          
   2194          #endif // TC_LINKKEY_JOIN
   2195          }
   2196          
   2197          /******************************************************************************
   2198           * @fn          ZDSecMgrLinkKeyNVIdGet (stubs APSME_LinkKeyNVIdGet)
   2199           *
   2200           * @brief       Get Key NV ID for specified NWK address.
   2201           *
   2202           * @param       extAddr - [in] EXT address
   2203           * @param       keyNvId - [out] NV ID
   2204           *
   2205           * @return      ZStatus_t
   2206           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2207          ZStatus_t ZDSecMgrLinkKeyNVIdGet(uint8* extAddr, uint16 *pKeyNvId)
   \                     APSME_LinkKeyNVIdGet:
   2208          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   2209            ZStatus_t status;
   2210            ZDSecMgrEntry_t* entry;
   2211          
   2212            // lookup entry index for specified NWK address
   2213            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   00001B   E9           MOV     A,R1
   2214          
   2215            if ( status == ZSuccess )
   \   00001C   7013         JNZ     ??APSME_LinkKeyNVIdGet_0
   2216            {
   2217              // return the index to the NV table
   2218              *pKeyNvId = entry->keyNvId;
   \   00001E   85..82       MOV     DPL,?XSP + 0
   \   000021   85..83       MOV     DPH,?XSP + 1
   \   000024   12....       LCALL   ?Subroutine22 & 0xFFFF
   2219            }
   \                     ??CrossCallReturnLabel_110:
   \   000027   8E82         MOV     DPL,R6
   \   000029   8F83         MOV     DPH,R7
   \   00002B   EA           MOV     A,R2
   \   00002C   F0           MOVX    @DPTR,A
   \   00002D   A3           INC     DPTR
   \   00002E   EB           MOV     A,R3
   \   00002F   8007         SJMP    ??APSME_LinkKeyNVIdGet_1
   2220            else
   2221            {
   2222              *pKeyNvId = SEC_NO_KEY_NV_ID;
   \                     ??APSME_LinkKeyNVIdGet_0:
   \   000031   8E82         MOV     DPL,R6
   \   000033   8F83         MOV     DPH,R7
   \   000035   E4           CLR     A
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \                     ??APSME_LinkKeyNVIdGet_1:
   \   000038   F0           MOVX    @DPTR,A
   2223            }
   2224          
   2225            return status;
   \   000039   02....       LJMP    ?Subroutine7 & 0xFFFF
   2226          }
   2227          
   2228          /******************************************************************************
   2229           * @fn          ZDSecMgrIsLinkKeyValid (stubs APSME_IsLinkKeyValid)
   2230           *
   2231           * @brief       Verifies if Link Key in NV has been set.
   2232           *
   2233           * @param       extAddr - [in] EXT address
   2234           *
   2235           * @return      TRUE - Link Key has been established
   2236           *              FALSE - Link Key in NV has default value.
   2237           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2238          uint8 ZDSecMgrIsLinkKeyValid(uint8* extAddr)
   \                     APSME_IsLinkKeyValid:
   2239          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2240            APSME_LinkKeyData_t *pKeyData;
   2241            uint16 apsLinkKeyNvId;
   2242            uint8 nullKey[SEC_KEY_LEN];
   2243            uint8 status = FALSE;
   \   00000E   75..00       MOV     ?V0 + 0,#0x0
   2244          
   2245            // initialize default vealue to compare to
   2246            osal_memset(nullKey, 0x00, SEC_KEY_LEN);
   \   000011                ; Setup parameters for call to function osal_memset
   \   000011   7C10         MOV     R4,#0x10
   \   000013   7D00         MOV     R5,#0x0
   \   000015   7900         MOV     R1,#0x0
   \   000017   7402         MOV     A,#0x2
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   AA82         MOV     R2,DPL
   \   00001E   AB83         MOV     R3,DPH
   \   000020   12....       LCALL   ??osal_memset?relay
   2247          
   2248            // check for APS link NV ID
   2249            APSME_LinkKeyNVIdGet( extAddr, &apsLinkKeyNvId );
   \   000023                ; Setup parameters for call to function APSME_LinkKeyNVIdGet
   \   000023   85..82       MOV     DPL,?XSP + 0
   \   000026   85..83       MOV     DPH,?XSP + 1
   \   000029   AC82         MOV     R4,DPL
   \   00002B   AD83         MOV     R5,DPH
   \   00002D   EE           MOV     A,R6
   \   00002E   FA           MOV     R2,A
   \   00002F   EF           MOV     A,R7
   \   000030   FB           MOV     R3,A
   \   000031   12....       LCALL   ??APSME_LinkKeyNVIdGet?relay
   2250          
   2251            if (apsLinkKeyNvId != SEC_NO_KEY_NV_ID )
   \   000034   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_160:
   \   000037   607E         JZ      ??APSME_IsLinkKeyValid_0
   2252            {
   2253              pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000039                ; Setup parameters for call to function osal_mem_alloc
   \   000039   7A18         MOV     R2,#0x18
   \   00003B   7B00         MOV     R3,#0x0
   \   00003D   12....       LCALL   ??osal_mem_alloc?relay
   \   000040   8A..         MOV     ?V0 + 2,R2
   \   000042   8B..         MOV     ?V0 + 3,R3
   2254          
   2255              if (pKeyData != NULL)
   \   000044   EA           MOV     A,R2
   \   000045   45..         ORL     A,?V0 + 3
   \   000047   606E         JZ      ??APSME_IsLinkKeyValid_0
   2256              {
   2257                // retrieve key from NV
   2258                if ( osal_nv_read( apsLinkKeyNvId, 0,
   2259                                  sizeof(APSME_LinkKeyData_t), pKeyData) == ZSUCCESS)
   \   000049                ; Setup parameters for call to function osal_nv_read
   \   000049   78..         MOV     R0,#?V0 + 2
   \   00004B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004E   75..18       MOV     ?V0 + 4,#0x18
   \   000051   75..00       MOV     ?V0 + 5,#0x0
   \   000054   78..         MOV     R0,#?V0 + 4
   \   000056   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000059   7C00         MOV     R4,#0x0
   \   00005B   7D00         MOV     R5,#0x0
   \   00005D   7404         MOV     A,#0x4
   \   00005F   12....       LCALL   ?XSTACK_DISP0_8
   \   000062   12....       LCALL   ??Subroutine59_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   000065   12....       LCALL   ??osal_nv_read?relay
   \   000068   7404         MOV     A,#0x4
   \   00006A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00006D   E9           MOV     A,R1
   \   00006E   7033         JNZ     ??APSME_IsLinkKeyValid_1
   2260                {
   2261                  // if stored key is different than default value, then a key has been established
   2262                  if (!osal_memcmp(pKeyData, nullKey, SEC_KEY_LEN))
   \   000070                ; Setup parameters for call to function osal_memcmp
   \   000070   7402         MOV     A,#0x2
   \   000072   12....       LCALL   ?XSTACK_DISP0_8
   \   000075   A982         MOV     R1,DPL
   \   000077   AA83         MOV     R2,DPH
   \   000079   89..         MOV     ?V0 + 4,R1
   \   00007B   8A..         MOV     ?V0 + 5,R2
   \   00007D   75..00       MOV     ?V0 + 6,#0x0
   \   000080   78..         MOV     R0,#?V0 + 4
   \   000082   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000085   7C10         MOV     R4,#0x10
   \   000087   7D00         MOV     R5,#0x0
   \   000089   85..82       MOV     DPL,?V0 + 2
   \   00008C   85..83       MOV     DPH,?V0 + 3
   \   00008F   A982         MOV     R1,DPL
   \   000091   AA83         MOV     R2,DPH
   \   000093   7B00         MOV     R3,#0x0
   \   000095   12....       LCALL   ??osal_memcmp?relay
   \   000098   7403         MOV     A,#0x3
   \   00009A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00009D   E9           MOV     A,R1
   \   00009E   7003         JNZ     ??APSME_IsLinkKeyValid_1
   2263                  {
   2264                    status = TRUE;
   \   0000A0   75..01       MOV     ?V0 + 0,#0x1
   2265                  }
   2266                }
   2267          
   2268                // clear copy of key in RAM
   2269                osal_memset(pKeyData, 0x00, sizeof(APSME_LinkKeyData_t));
   \                     ??APSME_IsLinkKeyValid_1:
   \   0000A3                ; Setup parameters for call to function osal_memset
   \   0000A3   7C18         MOV     R4,#0x18
   \   0000A5   7D00         MOV     R5,#0x0
   \   0000A7   7900         MOV     R1,#0x0
   \   0000A9   AA..         MOV     R2,?V0 + 2
   \   0000AB   AB..         MOV     R3,?V0 + 3
   \   0000AD   12....       LCALL   ??osal_memset?relay
   2270          
   2271                osal_mem_free(pKeyData);
   \   0000B0                ; Setup parameters for call to function osal_mem_free
   \   0000B0   AA..         MOV     R2,?V0 + 2
   \   0000B2   AB..         MOV     R3,?V0 + 3
   \   0000B4   12....       LCALL   ??osal_mem_free?relay
   2272              }
   2273            }
   2274          
   2275            return status;
   \                     ??APSME_IsLinkKeyValid_0:
   \   0000B7   A9..         MOV     R1,?V0 + 0
   \   0000B9   7412         MOV     A,#0x12
   \   0000BB   02....       LJMP    ?Subroutine5 & 0xFFFF
   2276          }
   2277          
   2278          /******************************************************************************
   2279           * @fn          ZDSecMgrKeyFwdToChild (stubs APSME_KeyFwdToChild)
   2280           *
   2281           * @brief       Verify and process key transportation to child.
   2282           *
   2283           * @param       ind - [in] APSME_TransportKeyInd_t
   2284           *
   2285           * @return      uint8 - success(TRUE:FALSE)
   2286           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2287          uint8 ZDSecMgrKeyFwdToChild( APSME_TransportKeyInd_t* ind )
   \                     APSME_KeyFwdToChild:
   2288          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2289            // verify from Trust Center
   2290            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   12....       LCALL   ??Subroutine69_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_158:
   \   00000B   7027         JNZ     ??APSME_KeyFwdToChild_0
   2291            {
   2292              // check for initial NWK key
   2293              if ( ( ind->keyType == KEY_TYPE_NWK ) ||
   2294                   ( ind->keyType == 6            ) )
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F8           MOV     R0,A
   \   000015   7401         MOV     A,#0x1
   \   000017   68           XRL     A,R0
   \   000018   6005         JZ      ??APSME_KeyFwdToChild_1
   \   00001A   7406         MOV     A,#0x6
   \   00001C   68           XRL     A,R0
   \   00001D   7011         JNZ     ??APSME_KeyFwdToChild_2
   2295              {
   2296                // set association status to authenticated
   2297                ZDSecMgrAssocDeviceAuth( AssocGetWithExt( ind->dstExtAddr ) );
   \                     ??APSME_KeyFwdToChild_1:
   \   00001F                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00001F                ; Setup parameters for call to function AssocGetWithExt
   \   00001F   8A82         MOV     DPL,R2
   \   000021   8B83         MOV     DPH,R3
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   12....       LCALL   ??Subroutine58_0 & 0xFFFF
   2298              }
   \                     ??CrossCallReturnLabel_106:
   \   00002A   12....       LCALL   ??AssocGetWithExt?relay
   \   00002D   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   2299          
   2300              return TRUE;
   \                     ??APSME_KeyFwdToChild_2:
   \   000030   7901         MOV     R1,#0x1
   \   000032   8002         SJMP    ??APSME_KeyFwdToChild_3
   2301            }
   2302          
   2303            return FALSE;
   \                     ??APSME_KeyFwdToChild_0:
   \   000034   7900         MOV     R1,#0x0
   \                     ??APSME_KeyFwdToChild_3:
   \   000036   02....       LJMP    ??Subroutine61_0 & 0xFFFF
   2304          }
   2305          
   2306          /******************************************************************************
   2307           * @fn          ZDSecMgrAddLinkKey
   2308           *
   2309           * @brief       Add the application link key to ZDSecMgr. Also mark the device
   2310           *              as authenticated in the authenticateOption. Note that this function
   2311           *              is hardwared to CBKE right now.
   2312           *
   2313           * @param       shortAddr - short address of the partner device
   2314           * @param       extAddr - extended address of the partner device
   2315           * @param       key - link key
   2316           *
   2317           * @return      ZStatus_t
   2318           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2319          ZStatus_t ZDSecMgrAddLinkKey( uint16 shortAddr, uint8 *extAddr, uint8 *key)
   \                     ZDSecMgrAddLinkKey:
   2320          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   \   00000E   7410         MOV     A,#0x10
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F5..         MOV     ?V0 + 0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 1,A
   2321            uint16           ami;
   2322            ZDSecMgrEntry_t* entry;
   2323          
   2324            /* Store the device address in the addr manager */
   2325            if( ZDSecMgrAddrStore( shortAddr, extAddr, &ami ) != ZSuccess )
   \   00001A                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00001A   7402         MOV     A,#0x2
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   8582..       MOV     ?V0 + 2,DPL
   \   000022   8583..       MOV     ?V0 + 3,DPH
   \   000025   78..         MOV     R0,#?V0 + 2
   \   000027   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002A   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   00002D   7402         MOV     A,#0x2
   \   00002F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000032   E9           MOV     A,R1
   \   000033   6004         JZ      ??ZDSecMgrAddLinkKey_0
   2326            {
   2327              /* Adding to Addr Manager fails */
   2328              return ZFailure;
   \   000035   7901         MOV     R1,#0x1
   \   000037   804B         SJMP    ??ZDSecMgrAddLinkKey_1
   2329            }
   2330          
   2331            /* Lookup entry using specified address index */
   2332            ZDSecMgrEntryLookupAMI( ami, &entry );
   \                     ??ZDSecMgrAddLinkKey_0:
   \   000039                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000039   85..82       MOV     DPL,?XSP + 0
   \   00003C   85..83       MOV     DPH,?XSP + 1
   \   00003F   AC82         MOV     R4,DPL
   \   000041   AD83         MOV     R5,DPH
   \   000043   7402         MOV     A,#0x2
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   12....       LCALL   ??Subroutine59_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   00004B   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   2333          
   2334            // If no existing entry, create one
   2335            if ( entry == NULL )
   \   00004E   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_161:
   \   000051   7018         JNZ     ??CrossCallReturnLabel_137
   2336            {
   2337              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   000053                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   000053   85..82       MOV     DPL,?XSP + 0
   \   000056   85..83       MOV     DPH,?XSP + 1
   \   000059   AA82         MOV     R2,DPL
   \   00005B   AB83         MOV     R3,DPH
   \   00005D   12....       LCALL   ??ZDSecMgrEntryNew?relay
   \   000060   E9           MOV     A,R1
   \   000061   7026         JNZ     ??ZDSecMgrAddLinkKey_2
   2338              {
   2339                entry->ami = ami;
   \   000063   7402         MOV     A,#0x2
   \   000065   12....       LCALL   ?XSTACK_DISP0_8
   \   000068   12....       LCALL   ?Subroutine20 & 0xFFFF
   2340              }
   2341              else
   2342              {
   2343                /* Security Manager full */
   2344                return ZBufferFull;
   2345              }
   2346            }
   2347            // Write the link key
   2348            APSME_LinkKeySet( extAddr, key );
   \                     ??CrossCallReturnLabel_137:
   \   00006B                ; Setup parameters for call to function APSME_LinkKeySet
   \   00006B   AC..         MOV     R4,?V0 + 0
   \   00006D   AD..         MOV     R5,?V0 + 1
   \   00006F   EE           MOV     A,R6
   \   000070   FA           MOV     R2,A
   \   000071   EF           MOV     A,R7
   \   000072   FB           MOV     R3,A
   \   000073   12....       LCALL   ??APSME_LinkKeySet?relay
   2349          
   2350          #if defined (TC_LINKKEY_JOIN)
   2351            // Mark the device as authenticated.
   2352            ZDSecMgrAuthenticationSet( extAddr, ZDSecMgr_Authenticated_CBCK );
   \   000076                ; Setup parameters for call to function ZDSecMgrAuthenticationSet
   \   000076   7901         MOV     R1,#0x1
   \   000078   EE           MOV     A,R6
   \   000079   FA           MOV     R2,A
   \   00007A   EF           MOV     A,R7
   \   00007B   FB           MOV     R3,A
   \   00007C   12....       LCALL   ??ZDSecMgrAuthenticationSet?relay
   2353          #endif
   2354          
   2355          #if defined NV_RESTORE
   2356            ZDSecMgrWriteNV();  // Write the new established link key to NV.
   \   00007F                ; Setup parameters for call to function ZDSecMgrWriteNV
   \   00007F   12....       LCALL   ??ZDSecMgrWriteNV?relay
   2357          #endif
   2358          
   2359            return ZSuccess;
   \   000082   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAddLinkKey_1:
   \   000084   7404         MOV     A,#0x4
   \   000086   02....       LJMP    ?Subroutine3 & 0xFFFF
   \                     ??ZDSecMgrAddLinkKey_2:
   \   000089   7911         MOV     R1,#0x11
   \   00008B   80F7         SJMP    ??ZDSecMgrAddLinkKey_1
   2360          }
   2361          
   2362          /******************************************************************************
   2363           * @fn          ZDSecMgrInitNV
   2364           *
   2365           * @brief       Initialize the SecMgr entry data in NV with all values set to 0
   2366           *
   2367           * @param       none
   2368           *
   2369           * @return      uint8 - <osal_nv_item_init> return codes
   2370           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2371          uint8 ZDSecMgrInitNV(void)
   \                     ZDSecMgrInitNV:
   2372          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2373          
   2374            uint8 rtrn = osal_nv_item_init(ZCD_NV_APS_LINK_KEY_TABLE,
   2375                          (sizeof(nvDeviceListHdr_t) + (sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)), NULL);
   \   00000A                ; Setup parameters for call to function osal_nv_item_init
   \   00000A   E4           CLR     A
   \   00000B   F5..         MOV     ?V0 + 0,A
   \   00000D   F5..         MOV     ?V0 + 1,A
   \   00000F   78..         MOV     R0,#?V0 + 0
   \   000011   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000014   7C11         MOV     R4,#0x11
   \   000016   7D00         MOV     R5,#0x0
   \   000018   7A4C         MOV     R2,#0x4c
   \   00001A   7B00         MOV     R3,#0x0
   \   00001C   12....       LCALL   ??osal_nv_item_init?relay
   \   00001F   7402         MOV     A,#0x2
   \   000021   12....       LCALL   ?DEALLOC_XSTACK8
   \   000024   E9           MOV     A,R1
   \   000025   FE           MOV     R6,A
   2376          
   2377            // If the item does not already exist, set all values to 0
   2378            if (rtrn != SUCCESS)
   \   000026   6021         JZ      ??ZDSecMgrInitNV_0
   2379            {
   2380              nvDeviceListHdr_t hdr;
   2381              hdr.numRecs = 0;
   \   000028   12....       LCALL   ?Subroutine15 & 0xFFFF
   2382              osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   2383            }
   \                     ??CrossCallReturnLabel_2:
   \   00002B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002E   75..02       MOV     ?V0 + 0,#0x2
   \   000031   75..00       MOV     ?V0 + 1,#0x0
   \   000034   78..         MOV     R0,#?V0 + 0
   \   000036   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000039   7C00         MOV     R4,#0x0
   \   00003B   7D00         MOV     R5,#0x0
   \   00003D   7A4C         MOV     R2,#0x4c
   \   00003F   7B00         MOV     R3,#0x0
   \   000041   12....       LCALL   ??osal_nv_write?relay
   \   000044   7404         MOV     A,#0x4
   \   000046   12....       LCALL   ?DEALLOC_XSTACK8
   2384          
   2385            rtrn |= osal_nv_item_init( ZCD_NV_TRUSTCENTER_ADDR, Z_EXTADDR_LEN,
   2386                                       zgApsTrustCenterAddr );
   2387          
   2388            return rtrn;
   \                     ??ZDSecMgrInitNV_0:
   \   000049                ; Setup parameters for call to function osal_nv_item_init
   \   000049   75....       MOV     ?V0 + 0,#zgApsTrustCenterAddr & 0xff
   \   00004C   75....       MOV     ?V0 + 1,#(zgApsTrustCenterAddr >> 8) & 0xff
   \   00004F   78..         MOV     R0,#?V0 + 0
   \   000051   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000054   7C08         MOV     R4,#0x8
   \   000056   7D00         MOV     R5,#0x0
   \   000058   7A71         MOV     R2,#0x71
   \   00005A   7B00         MOV     R3,#0x0
   \   00005C   12....       LCALL   ??osal_nv_item_init?relay
   \   00005F   7402         MOV     A,#0x2
   \   000061   12....       LCALL   ?DEALLOC_XSTACK8
   \   000064   E9           MOV     A,R1
   \   000065   4E           ORL     A,R6
   \   000066   F9           MOV     R1,A
   \   000067   02....       LJMP    ?Subroutine1 & 0xFFFF
   2389          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E4           CLR     A
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   F0           MOVX    @DPTR,A
   \   00000A                ; Setup parameters for call to function osal_nv_write
   \   00000A                ; Setup parameters for call to function osal_nv_write
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   8582..       MOV     ?V0 + 0,DPL
   \   000013   8583..       MOV     ?V0 + 1,DPH
   \   000016   78..         MOV     R0,#?V0 + 0
   \   000018   22           RET
   2390          
   2391          #if defined ( NV_RESTORE )
   2392          /*********************************************************************
   2393           * @fn      ZDSecMgrWriteNV()
   2394           *
   2395           * @brief   Save off the APS link key list to NV
   2396           *
   2397           * @param   none
   2398           *
   2399           * @return  none
   2400           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2401          static void ZDSecMgrWriteNV( void )
   \                     ZDSecMgrWriteNV:
   2402          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2403            uint16 i;
   2404            nvDeviceListHdr_t hdr;
   2405          
   2406            hdr.numRecs = 0;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   12....       LCALL   ?Subroutine11 & 0xFFFF
   2407          
   2408            if (ZDSecMgrEntries != NULL)
   \                     ??CrossCallReturnLabel_80:
   \   000013   606C         JZ      ??ZDSecMgrWriteNV_0
   2409            {
   2410              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   000015   7E00         MOV     R6,#0x0
   \   000017   7F00         MOV     R7,#0x0
   2411              {
   2412                // Save off the record
   2413                osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   2414                              (uint16)((sizeof(nvDeviceListHdr_t)) + (i * sizeof(ZDSecMgrEntry_t))),
   2415                              sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[i] );
   \                     ??ZDSecMgrWriteNV_1:
   \   000019   8E..         MOV     ?V0 + 0,R6
   \   00001B   8F..         MOV     ?V0 + 1,R7
   \   00001D   E5..         MOV     A,?V0 + 0
   \   00001F   75F005       MOV     B,#0x5
   \   000022   A4           MUL     AB
   \   000023   F5..         MOV     ?V0 + 0,A
   \   000025   A8F0         MOV     R0,B
   \   000027   75F005       MOV     B,#0x5
   \   00002A   E5..         MOV     A,?V0 + 1
   \   00002C   A4           MUL     AB
   \   00002D   28           ADD     A,R0
   \   00002E   F5..         MOV     ?V0 + 1,A
   \   000030                ; Setup parameters for call to function osal_nv_write
   \   000030   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000033   E0           MOVX    A,@DPTR
   \   000034   25..         ADD     A,?V0 + 0
   \   000036   F5..         MOV     ?V0 + 2,A
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   35..         ADDC    A,?V0 + 1
   \   00003C   F5..         MOV     ?V0 + 3,A
   \   00003E   78..         MOV     R0,#?V0 + 2
   \   000040   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000043   75..05       MOV     ?V0 + 2,#0x5
   \   000046   75..00       MOV     ?V0 + 3,#0x0
   \   000049   78..         MOV     R0,#?V0 + 2
   \   00004B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004E   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000051   12....       LCALL   ??osal_nv_write?relay
   \   000054   7404         MOV     A,#0x4
   \   000056   12....       LCALL   ?DEALLOC_XSTACK8
   2416          
   2417                if ( ZDSecMgrEntries[i].ami != INVALID_NODE_ADDR )
   \   000059   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   25..         ADD     A,?V0 + 0
   \   00005F   F8           MOV     R0,A
   \   000060   A3           INC     DPTR
   \   000061   E0           MOVX    A,@DPTR
   \   000062   35..         ADDC    A,?V0 + 1
   \   000064   8882         MOV     DPL,R0
   \   000066   F583         MOV     DPH,A
   \   000068   E0           MOVX    A,@DPTR
   \   000069   64FE         XRL     A,#0xfe
   \   00006B   7003         JNZ     ??ZDSecMgrWriteNV_2
   \   00006D   A3           INC     DPTR
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   F4           CPL     A
   \                     ??ZDSecMgrWriteNV_2:
   \   000070   600A         JZ      ??ZDSecMgrWriteNV_3
   2418                {
   2419                  hdr.numRecs++;
   \   000072   85..82       MOV     DPL,?XSP + 0
   \   000075   85..83       MOV     DPH,?XSP + 1
   \   000078   12....       LCALL   ?Subroutine31 & 0xFFFF
   2420                }
   2421              }
   \                     ??CrossCallReturnLabel_28:
   \   00007B   F0           MOVX    @DPTR,A
   \                     ??ZDSecMgrWriteNV_3:
   \   00007C   12....       LCALL   ?Subroutine33 & 0xFFFF
   2422            }
   \                     ??CrossCallReturnLabel_34:
   \   00007F   4098         JC      ??ZDSecMgrWriteNV_1
   2423          
   2424            // Save off the header
   2425            osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   \                     ??ZDSecMgrWriteNV_0:
   \   000081                ; Setup parameters for call to function osal_nv_write
   \   000081   85..82       MOV     DPL,?XSP + 0
   \   000084   85..83       MOV     DPH,?XSP + 1
   \   000087   8582..       MOV     ?V0 + 0,DPL
   \   00008A   8583..       MOV     ?V0 + 1,DPH
   \   00008D   78..         MOV     R0,#?V0 + 0
   \   00008F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000092   75..02       MOV     ?V0 + 0,#0x2
   \   000095   75..00       MOV     ?V0 + 1,#0x0
   \   000098   78..         MOV     R0,#?V0 + 0
   \   00009A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009D   7C00         MOV     R4,#0x0
   \   00009F   7D00         MOV     R5,#0x0
   \   0000A1   7A4C         MOV     R2,#0x4c
   \   0000A3   7B00         MOV     R3,#0x0
   \   0000A5   12....       LCALL   ??osal_nv_write?relay
   \   0000A8   7404         MOV     A,#0x4
   \   0000AA   12....       LCALL   ?DEALLOC_XSTACK8
   2426          }
   \   0000AD   7402         MOV     A,#0x2
   \   0000AF                REQUIRE ?Subroutine3
   \   0000AF                ; // Fall through to label ?Subroutine3

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   EE           MOV     A,R6
   \   000001   F8           MOV     R0,A
   \   000002   EF           MOV     A,R7
   \   000003   F9           MOV     R1,A
   \   000004   E8           MOV     A,R0
   \   000005   75F005       MOV     B,#0x5
   \   000008   A4           MUL     AB
   \   000009   F8           MOV     R0,A
   \   00000A   AAF0         MOV     R2,B
   \   00000C   75F005       MOV     B,#0x5
   \   00000F   E9           MOV     A,R1
   \   000010   A4           MUL     AB
   \   000011   2A           ADD     A,R2
   \   000012   F9           MOV     R1,A
   \   000013   E8           MOV     A,R0
   \   000014   2402         ADD     A,#0x2
   \   000016   FC           MOV     R4,A
   \   000017   E9           MOV     A,R1
   \   000018   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   00001B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   000003   9403         SUBB    A,#0x3
   \   000005   EF           MOV     A,R7
   \   000006   9400         SUBB    A,#0x0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   EE           MOV     A,R6
   \   000001   2401         ADD     A,#0x1
   \   000003   0E           INC     R6
   \   000004   EF           MOV     A,R7
   \   000005   3400         ADDC    A,#0x0
   \   000007   FF           MOV     R7,A
   \   000008   C3           CLR     C
   \   000009   EE           MOV     A,R6
   \   00000A   22           RET
   2427          #endif // NV_RESTORE
   2428          
   2429          #if defined ( NV_RESTORE )
   2430          /******************************************************************************
   2431           * @fn          ZDSecMgrRestoreFromNV
   2432           *
   2433           * @brief       Restore the APS Link Key entry data from NV. It does not restore
   2434           *              the key data itself as they remain in NV until they are used.
   2435           *              Only list data is restored.
   2436           *              Restore zgTrustCenterAdress from NV.
   2437           *
   2438           * @param       none
   2439           *
   2440           * @return      None.
   2441           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2442          static void ZDSecMgrRestoreFromNV( void )
   \                     ZDSecMgrRestoreFromNV:
   2443          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2444            nvDeviceListHdr_t hdr;
   2445            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   2446          
   2447            if ((osal_nv_read(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr) == ZSUCCESS) &&
   2448                ((hdr.numRecs > 0) && (hdr.numRecs <= ZDSECMGR_ENTRY_MAX)))
   \   00000A                ; Setup parameters for call to function osal_nv_read
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   8582..       MOV     ?V0 + 0,DPL
   \   000013   8583..       MOV     ?V0 + 1,DPH
   \   000016   78..         MOV     R0,#?V0 + 0
   \   000018   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001B   75..02       MOV     ?V0 + 0,#0x2
   \   00001E   75..00       MOV     ?V0 + 1,#0x0
   \   000021   78..         MOV     R0,#?V0 + 0
   \   000023   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000026   7C00         MOV     R4,#0x0
   \   000028   7D00         MOV     R5,#0x0
   \   00002A   7A4C         MOV     R2,#0x4c
   \   00002C   7B00         MOV     R3,#0x0
   \   00002E   12....       LCALL   ??osal_nv_read?relay
   \   000031   7404         MOV     A,#0x4
   \   000033   12....       LCALL   ?DEALLOC_XSTACK8
   \   000036   E9           MOV     A,R1
   \   000037   6003         JZ      $+5
   \   000039   02....       LJMP    ??ZDSecMgrRestoreFromNV_0 & 0xFFFF
   \   00003C   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_162:
   \   00003F   7003         JNZ     $+5
   \   000041   02....       LJMP    ??ZDSecMgrRestoreFromNV_0 & 0xFFFF
   \   000044   85..82       MOV     DPL,?XSP + 0
   \   000047   85..83       MOV     DPH,?XSP + 1
   \   00004A   C3           CLR     C
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   9404         SUBB    A,#0x4
   \   00004E   A3           INC     DPTR
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   9400         SUBB    A,#0x0
   \   000052   4003         JC      $+5
   \   000054   02....       LJMP    ??ZDSecMgrRestoreFromNV_0 & 0xFFFF
   2449            {
   2450              uint8 x;
   2451          
   2452              pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000057                ; Setup parameters for call to function osal_mem_alloc
   \   000057   7A18         MOV     R2,#0x18
   \   000059   7B00         MOV     R3,#0x0
   \   00005B   12....       LCALL   ??osal_mem_alloc?relay
   \   00005E   8A..         MOV     ?V0 + 8,R2
   \   000060   8B..         MOV     ?V0 + 9,R3
   2453          
   2454              for (x = 0; x < ZDSECMGR_ENTRY_MAX; x++)
   \   000062   75..00       MOV     ?V0 + 0,#0x0
   \   000065   EA           MOV     A,R2
   \   000066   2410         ADD     A,#0x10
   \   000068   F5..         MOV     ?V0 + 2,A
   \   00006A   EB           MOV     A,R3
   \   00006B   3400         ADDC    A,#0x0
   \   00006D   F5..         MOV     ?V0 + 3,A
   2455              {
   2456                if ( osal_nv_read( ZCD_NV_APS_LINK_KEY_TABLE,
   2457                                  (uint16)(sizeof(nvDeviceListHdr_t) + (x * sizeof(ZDSecMgrEntry_t))),
   2458                                  sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[x] ) == SUCCESS )
   \                     ??ZDSecMgrRestoreFromNV_1:
   \   00006F   E5..         MOV     A,?V0 + 0
   \   000071   75F005       MOV     B,#0x5
   \   000074   A4           MUL     AB
   \   000075   FE           MOV     R6,A
   \   000076   AFF0         MOV     R7,B
   \   000078                ; Setup parameters for call to function osal_nv_read
   \   000078   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   2E           ADD     A,R6
   \   00007D   F5..         MOV     ?V0 + 4,A
   \   00007F   A3           INC     DPTR
   \   000080   E0           MOVX    A,@DPTR
   \   000081   3F           ADDC    A,R7
   \   000082   F5..         MOV     ?V0 + 5,A
   \   000084   78..         MOV     R0,#?V0 + 4
   \   000086   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000089   75..05       MOV     ?V0 + 4,#0x5
   \   00008C   75..00       MOV     ?V0 + 5,#0x0
   \   00008F   78..         MOV     R0,#?V0 + 4
   \   000091   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000094   E5..         MOV     A,?V0 + 0
   \   000096   75F005       MOV     B,#0x5
   \   000099   A4           MUL     AB
   \   00009A   2402         ADD     A,#0x2
   \   00009C   FC           MOV     R4,A
   \   00009D   E5F0         MOV     A,B
   \   00009F   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   0000A2   12....       LCALL   ??osal_nv_read?relay
   \   0000A5   7404         MOV     A,#0x4
   \   0000A7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AA   E9           MOV     A,R1
   \   0000AB   6003         JZ      $+5
   \   0000AD   02....       LJMP    ??ZDSecMgrRestoreFromNV_2 & 0xFFFF
   2459                {
   2460                  // update data only for valid entries
   2461                  if ( ZDSecMgrEntries[x].ami != INVALID_NODE_ADDR )
   \   0000B0   90....       MOV     DPTR,#ZDSecMgrEntries
   \   0000B3   E0           MOVX    A,@DPTR
   \   0000B4   2E           ADD     A,R6
   \   0000B5   F8           MOV     R0,A
   \   0000B6   A3           INC     DPTR
   \   0000B7   E0           MOVX    A,@DPTR
   \   0000B8   3F           ADDC    A,R7
   \   0000B9   F9           MOV     R1,A
   \   0000BA   E8           MOV     A,R0
   \   0000BB   FA           MOV     R2,A
   \   0000BC   E9           MOV     A,R1
   \   0000BD   FB           MOV     R3,A
   \   0000BE   8A82         MOV     DPL,R2
   \   0000C0   8B83         MOV     DPH,R3
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   64FE         XRL     A,#0xfe
   \   0000C5   7003         JNZ     ??ZDSecMgrRestoreFromNV_3
   \   0000C7   A3           INC     DPTR
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   F4           CPL     A
   \                     ??ZDSecMgrRestoreFromNV_3:
   \   0000CA   7003         JNZ     $+5
   \   0000CC   02....       LJMP    ??ZDSecMgrRestoreFromNV_2 & 0xFFFF
   2462                  {
   2463                    if (pApsLinkKey != NULL)
   \   0000CF   E5..         MOV     A,?V0 + 8
   \   0000D1   45..         ORL     A,?V0 + 9
   \   0000D3   7003         JNZ     $+5
   \   0000D5   02....       LJMP    ??ZDSecMgrRestoreFromNV_2 & 0xFFFF
   2464                    {
   2465                      // read the key form NV, keyNvId must be ZCD_NV_APS_LINK_KEY_DATA_START based
   2466                      osal_nv_read( ZDSecMgrEntries[x].keyNvId, 0,
   2467                                   sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \   0000D8                ; Setup parameters for call to function osal_nv_read
   \   0000D8   78..         MOV     R0,#?V0 + 8
   \   0000DA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000DD   75..18       MOV     ?V0 + 4,#0x18
   \   0000E0   78..         MOV     R0,#?V0 + 4
   \   0000E2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000E5   7C00         MOV     R4,#0x0
   \   0000E7   7D00         MOV     R5,#0x0
   \   0000E9   8A82         MOV     DPL,R2
   \   0000EB   8B83         MOV     DPH,R3
   \   0000ED   12....       LCALL   ??Subroutine58_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   0000F0   12....       LCALL   ??osal_nv_read?relay
   \   0000F3   7404         MOV     A,#0x4
   \   0000F5   12....       LCALL   ?DEALLOC_XSTACK8
   2468          
   2469                      // set new values for the counter
   2470                      pApsLinkKey->txFrmCntr += ( MAX_APS_FRAMECOUNTER_CHANGES + 1 );
   \   0000F8   90....       MOV     DPTR,#__Constant_3e9
   \   0000FB   78..         MOV     R0,#?V0 + 4
   \   0000FD   12....       LCALL   ?L_MOV_X
   \   000100   85..82       MOV     DPL,?V0 + 2
   \   000103   85..83       MOV     DPH,?V0 + 3
   \   000106   78..         MOV     R0,#?V0 + 4
   \   000108   12....       LCALL   ?L_ADD_TO_X
   \   00010B   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   00010E   A3           INC     DPTR
   \   00010F   A3           INC     DPTR
   \   000110   E0           MOVX    A,@DPTR
   \   000111   FE           MOV     R6,A
   \   000112   A3           INC     DPTR
   \   000113   E0           MOVX    A,@DPTR
   \   000114   FF           MOV     R7,A
   \   000115   EE           MOV     A,R6
   \   000116   F8           MOV     R0,A
   \   000117   EF           MOV     A,R7
   \   000118   F9           MOV     R1,A
   \   000119   E8           MOV     A,R0
   \   00011A   75F009       MOV     B,#0x9
   \   00011D   A4           MUL     AB
   \   00011E   F8           MOV     R0,A
   \   00011F   AAF0         MOV     R2,B
   \   000121   75F009       MOV     B,#0x9
   \   000124   E9           MOV     A,R1
   \   000125   A4           MUL     AB
   \   000126   2A           ADD     A,R2
   \   000127   F9           MOV     R1,A
   \   000128   74..         MOV     A,#ApsLinkKeyFrmCntr & 0xff
   \   00012A   28           ADD     A,R0
   \   00012B   F8           MOV     R0,A
   \   00012C   74..         MOV     A,#(ApsLinkKeyFrmCntr >> 8) & 0xff
   \   00012E   39           ADDC    A,R1
   \   00012F   F9           MOV     R1,A
   \   000130   85..82       MOV     DPL,?V0 + 2
   \   000133   85..83       MOV     DPH,?V0 + 3
   \   000136   12....       LCALL   ?XLOAD_R2345
   \   000139   E8           MOV     A,R0
   \   00013A   24F7         ADD     A,#-0x9
   \   00013C   F582         MOV     DPL,A
   \   00013E   E9           MOV     A,R1
   \   00013F   34ED         ADDC    A,#-0x13
   \   000141   F583         MOV     DPH,A
   \   000143   12....       LCALL   ?XSTORE_R2345
   2471          
   2472                      // restore values for counters in RAM
   2473                      ApsLinkKeyFrmCntr[ZDSecMgrEntries[x].keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr =
   2474                                                      pApsLinkKey->txFrmCntr;
   2475          
   2476                      ApsLinkKeyFrmCntr[ZDSecMgrEntries[x].keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr =
   2477                                                      pApsLinkKey->rxFrmCntr;
   \   000146   E5..         MOV     A,?V0 + 8
   \   000148   2414         ADD     A,#0x14
   \   00014A   F582         MOV     DPL,A
   \   00014C   E5..         MOV     A,?V0 + 9
   \   00014E   12....       LCALL   ??Subroutine71_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_183:
   \   000151   12....       LCALL   ?XLOAD_R2345
   \   000154   E8           MOV     A,R0
   \   000155   24FB         ADD     A,#-0x5
   \   000157   F582         MOV     DPL,A
   \   000159   E9           MOV     A,R1
   \   00015A   34ED         ADDC    A,#-0x13
   \   00015C   F583         MOV     DPH,A
   \   00015E   12....       LCALL   ?XSTORE_R2345
   2478          
   2479                      osal_nv_write( ZDSecMgrEntries[x].keyNvId, 0,
   2480                                    sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \   000161                ; Setup parameters for call to function osal_nv_write
   \   000161   78..         MOV     R0,#?V0 + 8
   \   000163   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000166   75..18       MOV     ?V0 + 4,#0x18
   \   000169   75..00       MOV     ?V0 + 5,#0x0
   \   00016C   78..         MOV     R0,#?V0 + 4
   \   00016E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000171   7C00         MOV     R4,#0x0
   \   000173   7D00         MOV     R5,#0x0
   \   000175   EE           MOV     A,R6
   \   000176   FA           MOV     R2,A
   \   000177   EF           MOV     A,R7
   \   000178   FB           MOV     R3,A
   \   000179   12....       LCALL   ??osal_nv_write?relay
   \   00017C   7404         MOV     A,#0x4
   \   00017E   12....       LCALL   ?DEALLOC_XSTACK8
   2481          
   2482                      // clear copy of key in RAM
   2483                      osal_memset(pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t));
   \   000181                ; Setup parameters for call to function osal_memset
   \   000181   7C18         MOV     R4,#0x18
   \   000183   7D00         MOV     R5,#0x0
   \   000185   7900         MOV     R1,#0x0
   \   000187   AA..         MOV     R2,?V0 + 8
   \   000189   AB..         MOV     R3,?V0 + 9
   \   00018B   12....       LCALL   ??osal_memset?relay
   2484                    }
   2485                  }
   2486                }
   2487              }
   \                     ??ZDSecMgrRestoreFromNV_2:
   \   00018E   05..         INC     ?V0 + 0
   \   000190   E5..         MOV     A,?V0 + 0
   \   000192   C3           CLR     C
   \   000193   9403         SUBB    A,#0x3
   \   000195   5003         JNC     $+5
   \   000197   02....       LJMP    ??ZDSecMgrRestoreFromNV_1 & 0xFFFF
   2488          
   2489              if (pApsLinkKey != NULL)
   \   00019A   E5..         MOV     A,?V0 + 8
   \   00019C   45..         ORL     A,?V0 + 9
   \   00019E   6007         JZ      ??ZDSecMgrRestoreFromNV_0
   2490              {
   2491                osal_mem_free(pApsLinkKey);
   \   0001A0                ; Setup parameters for call to function osal_mem_free
   \   0001A0   AA..         MOV     R2,?V0 + 8
   \   0001A2   AB..         MOV     R3,?V0 + 9
   \   0001A4   12....       LCALL   ??osal_mem_free?relay
   2492              }
   2493            }
   2494          
   2495            osal_nv_read( ZCD_NV_TRUSTCENTER_ADDR, 0, Z_EXTADDR_LEN, zgApsTrustCenterAddr );
   \                     ??ZDSecMgrRestoreFromNV_0:
   \   0001A7                ; Setup parameters for call to function osal_nv_read
   \   0001A7   75....       MOV     ?V0 + 0,#zgApsTrustCenterAddr & 0xff
   \   0001AA   75....       MOV     ?V0 + 1,#(zgApsTrustCenterAddr >> 8) & 0xff
   \   0001AD   78..         MOV     R0,#?V0 + 0
   \   0001AF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001B2   75..08       MOV     ?V0 + 0,#0x8
   \   0001B5   75..00       MOV     ?V0 + 1,#0x0
   \   0001B8   78..         MOV     R0,#?V0 + 0
   \   0001BA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001BD   7C00         MOV     R4,#0x0
   \   0001BF   7D00         MOV     R5,#0x0
   \   0001C1   7A71         MOV     R2,#0x71
   \   0001C3   7B00         MOV     R3,#0x0
   \   0001C5   12....       LCALL   ??osal_nv_read?relay
   \   0001C8   7404         MOV     A,#0x4
   \   0001CA   12....       LCALL   ?DEALLOC_XSTACK8
   2496          }
   \   0001CD   7402         MOV     A,#0x2
   \   0001CF   02....       LJMP    ?Subroutine6 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine74_0
   \   000003                ; // Fall through to label ??Subroutine74_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine74_0:
   \   000000   7F0A         MOV     R7,#0xa
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   2497          #endif // NV_RESTORE
   2498          
   2499          /*********************************************************************
   2500           * @fn          ZDSecMgrSetDefaultNV
   2501           *
   2502           * @brief       Write the defaults to NV for Entry table and for APS key data table
   2503           *
   2504           * @param       none
   2505           *
   2506           * @return      none
   2507           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2508          void ZDSecMgrSetDefaultNV( void )
   \                     ZDSecMgrSetDefaultNV:
   2509          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2510            uint16 i;
   2511            nvDeviceListHdr_t hdr;
   2512            ZDSecMgrEntry_t secMgrEntry;
   2513            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   2514          
   2515            // Initialize the header
   2516            hdr.numRecs = 0;
   \   00000A   12....       LCALL   ?Subroutine15 & 0xFFFF
   2517          
   2518            // clear the header
   2519            osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   \                     ??CrossCallReturnLabel_3:
   \   00000D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000010   75..02       MOV     ?V0 + 0,#0x2
   \   000013   75..00       MOV     ?V0 + 1,#0x0
   \   000016   78..         MOV     R0,#?V0 + 0
   \   000018   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001B   7C00         MOV     R4,#0x0
   \   00001D   7D00         MOV     R5,#0x0
   \   00001F   7A4C         MOV     R2,#0x4c
   \   000021   7B00         MOV     R3,#0x0
   \   000023   12....       LCALL   ??osal_nv_write?relay
   \   000026   7404         MOV     A,#0x4
   \   000028   12....       LCALL   ?DEALLOC_XSTACK8
   2520          
   2521            osal_memset( &secMgrEntry, 0x00, sizeof(ZDSecMgrEntry_t) );
   \   00002B                ; Setup parameters for call to function osal_memset
   \   00002B   7C05         MOV     R4,#0x5
   \   00002D   7D00         MOV     R5,#0x0
   \   00002F   7900         MOV     R1,#0x0
   \   000031   7402         MOV     A,#0x2
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   AA82         MOV     R2,DPL
   \   000038   AB83         MOV     R3,DPH
   \   00003A   12....       LCALL   ??osal_memset?relay
   2522          
   2523            for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   00003D   7E00         MOV     R6,#0x0
   \   00003F   7F00         MOV     R7,#0x0
   2524            {
   2525              // Clear the record
   2526              osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   2527                          (uint16)((sizeof(nvDeviceListHdr_t)) + (i * sizeof(ZDSecMgrEntry_t))),
   2528                                  sizeof(ZDSecMgrEntry_t), &secMgrEntry );
   \                     ??ZDSecMgrSetDefaultNV_0:
   \   000041                ; Setup parameters for call to function osal_nv_write
   \   000041   7402         MOV     A,#0x2
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   8582..       MOV     ?V0 + 0,DPL
   \   000049   8583..       MOV     ?V0 + 1,DPH
   \   00004C   78..         MOV     R0,#?V0 + 0
   \   00004E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000051   75..05       MOV     ?V0 + 0,#0x5
   \   000054   75..00       MOV     ?V0 + 1,#0x0
   \   000057   78..         MOV     R0,#?V0 + 0
   \   000059   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005C   12....       LCALL   ?Subroutine34 & 0xFFFF
   2529            }
   \                     ??CrossCallReturnLabel_39:
   \   00005F   12....       LCALL   ??osal_nv_write?relay
   \   000062   7404         MOV     A,#0x4
   \   000064   12....       LCALL   ?DEALLOC_XSTACK8
   \   000067   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   00006A   40D5         JC      ??ZDSecMgrSetDefaultNV_0
   2530          
   2531            pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   00006C                ; Setup parameters for call to function osal_mem_alloc
   \   00006C   7A18         MOV     R2,#0x18
   \   00006E   7B00         MOV     R3,#0x0
   \   000070   12....       LCALL   ??osal_mem_alloc?relay
   \   000073   8A..         MOV     ?V0 + 0,R2
   \   000075   8B..         MOV     ?V0 + 1,R3
   2532          
   2533            if (pApsLinkKey != NULL)
   \   000077   EA           MOV     A,R2
   \   000078   45..         ORL     A,?V0 + 1
   \   00007A   603D         JZ      ??ZDSecMgrSetDefaultNV_1
   2534            {
   2535              osal_memset( pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   00007C                ; Setup parameters for call to function osal_memset
   \   00007C   7C18         MOV     R4,#0x18
   \   00007E   7D00         MOV     R5,#0x0
   \   000080   7900         MOV     R1,#0x0
   \   000082   12....       LCALL   ??osal_memset?relay
   2536          
   2537              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   000085   7E00         MOV     R6,#0x0
   \   000087   7F00         MOV     R7,#0x0
   2538              {
   2539                // Clear the record
   2540                osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0,
   2541                              sizeof(APSME_LinkKeyData_t), pApsLinkKey);
   \                     ??ZDSecMgrSetDefaultNV_2:
   \   000089                ; Setup parameters for call to function osal_nv_write
   \   000089   78..         MOV     R0,#?V0 + 0
   \   00008B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008E   75..18       MOV     ?V0 + 2,#0x18
   \   000091   75..00       MOV     ?V0 + 3,#0x0
   \   000094   78..         MOV     R0,#?V0 + 2
   \   000096   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000099   7C00         MOV     R4,#0x0
   \   00009B   7D00         MOV     R5,#0x0
   \   00009D   EE           MOV     A,R6
   \   00009E   2401         ADD     A,#0x1
   \   0000A0   FA           MOV     R2,A
   \   0000A1   EF           MOV     A,R7
   \   0000A2   3402         ADDC    A,#0x2
   \   0000A4   FB           MOV     R3,A
   \   0000A5   12....       LCALL   ??osal_nv_write?relay
   \   0000A8   7404         MOV     A,#0x4
   \   0000AA   12....       LCALL   ?DEALLOC_XSTACK8
   2542              }
   \   0000AD   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   0000B0   40D7         JC      ??ZDSecMgrSetDefaultNV_2
   2543          
   2544              osal_mem_free(pApsLinkKey);
   \   0000B2                ; Setup parameters for call to function osal_mem_free
   \   0000B2   AA..         MOV     R2,?V0 + 0
   \   0000B4   AB..         MOV     R3,?V0 + 1
   \   0000B6   12....       LCALL   ??osal_mem_free?relay
   2545            }
   2546          }
   \                     ??ZDSecMgrSetDefaultNV_1:
   \   0000B9   7407         MOV     A,#0x7
   \   0000BB   02....       LJMP    ?Subroutine3 & 0xFFFF
   2547          
   2548          #if defined ( NV_RESTORE )
   2549          /*********************************************************************
   2550           * @fn      ZDSecMgrUpdateNV()
   2551           *
   2552           * @brief   Updates one entry of the APS link key table to NV
   2553           *
   2554           * @param   index - to the entry in security manager table
   2555           *
   2556           * @return  none
   2557           */
   2558          static void ZDSecMgrUpdateNV( uint16 index )
   2559          {
   2560            nvDeviceListHdr_t hdr;
   2561          
   2562            if (ZDSecMgrEntries != NULL)
   2563            {
   2564              // Save off the record
   2565              osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   2566                             (uint16)((sizeof(nvDeviceListHdr_t)) + (index * sizeof(ZDSecMgrEntry_t))),
   2567                             sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[index] );
   2568            }
   2569          
   2570            if (osal_nv_read(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr) == ZSUCCESS)
   2571            {
   2572              if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   2573              {
   2574                if (hdr.numRecs > 0)
   2575                {
   2576                  hdr.numRecs--;
   2577                }
   2578              }
   2579              else
   2580              {
   2581                hdr.numRecs++;
   2582              }
   2583          
   2584              // Save off the header
   2585              osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   2586            }
   2587          }
   2588          #endif // NV_RESTORE
   2589          
   2590          /******************************************************************************
   2591           * @fn          ZDSecMgrAPSRemove
   2592           *
   2593           * @brief       Remove device from network.
   2594           *
   2595           * @param       nwkAddr - device's NWK address
   2596           * @param       extAddr - device's Extended address
   2597           * @param       parentAddr - parent's NWK address
   2598           *
   2599           * @return      ZStatus_t
   2600           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2601          ZStatus_t ZDSecMgrAPSRemove( uint16 nwkAddr, uint8 *extAddr, uint16 parentAddr )
   \                     ZDSecMgrAPSRemove:
   2602          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 8
   \   000004   74F8         MOV     A,#-0x8
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   2603            ZDSecMgrDevice_t device;
   2604          
   2605            if ( ( nwkAddr == INVALID_NODE_ADDR ) ||
   2606                 ( extAddr == NULL )              ||
   2607                 ( parentAddr == INVALID_NODE_ADDR ) )
   \   000009   74FE         MOV     A,#-0x2
   \   00000B   6A           XRL     A,R2
   \   00000C   7003         JNZ     ??ZDSecMgrAPSRemove_0
   \   00000E   74FF         MOV     A,#-0x1
   \   000010   6B           XRL     A,R3
   \                     ??ZDSecMgrAPSRemove_0:
   \   000011   6016         JZ      ??ZDSecMgrAPSRemove_1
   \   000013   EC           MOV     A,R4
   \   000014   4D           ORL     A,R5
   \   000015   6012         JZ      ??ZDSecMgrAPSRemove_1
   \   000017   7408         MOV     A,#0x8
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   12....       LCALL   ??Subroutine70_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_171:
   \   00001F   74FE         MOV     A,#-0x2
   \   000021   68           XRL     A,R0
   \   000022   7003         JNZ     ??ZDSecMgrAPSRemove_2
   \   000024   74FF         MOV     A,#-0x1
   \   000026   69           XRL     A,R1
   \                     ??ZDSecMgrAPSRemove_2:
   \   000027   7004         JNZ     ??ZDSecMgrAPSRemove_3
   2608            {
   2609              return ( ZFailure );
   \                     ??ZDSecMgrAPSRemove_1:
   \   000029   7901         MOV     R1,#0x1
   \   00002B   801C         SJMP    ??ZDSecMgrAPSRemove_4
   2610            }
   2611          
   2612            device.nwkAddr = nwkAddr;
   \                     ??ZDSecMgrAPSRemove_3:
   \   00002D   12....       LCALL   ?Subroutine21 & 0xFFFF
   2613            device.extAddr = extAddr;
   \                     ??CrossCallReturnLabel_87:
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   EC           MOV     A,R4
   \   000034   F0           MOVX    @DPTR,A
   \   000035   A3           INC     DPTR
   \   000036   ED           MOV     A,R5
   \   000037   F0           MOVX    @DPTR,A
   2614            device.parentAddr = parentAddr;
   \   000038   7404         MOV     A,#0x4
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   E8           MOV     A,R0
   \   00003E   F0           MOVX    @DPTR,A
   \   00003F   A3           INC     DPTR
   \   000040   E9           MOV     A,R1
   \   000041   12....       LCALL   ??Subroutine64_0 & 0xFFFF
   2615          
   2616            // remove device
   2617            ZDSecMgrDeviceRemove( &device );
   \                     ??CrossCallReturnLabel_146:
   \   000044   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   2618          
   2619            return ( ZSuccess );
   \   000047   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAPSRemove_4:
   \   000049   02....       LJMP    ?Subroutine4 & 0xFFFF
   2620          }
   2621          
   2622          /******************************************************************************
   2623           * @fn          APSME_TCLinkKeyInit
   2624           *
   2625           * @brief       Initialize the NV table for preconfigured TC link key
   2626           *
   2627           *              When zgUseDefaultTCL is set to TRUE, the default preconfig
   2628           *              Trust Center Link Key is written to NV. A single tclk is used
   2629           *              by all devices joining the network.
   2630           *
   2631           * @param       setDefault - TRUE to set default values
   2632           *
   2633           * @return      none
   2634           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2635          void APSME_TCLinkKeyInit(uint8 setDefault)
   \                     APSME_TCLinkKeyInit:
   2636          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V0 + 3,R1
   2637            uint8             i;
   2638            APSME_TCLinkKey_t tcLinkKey;
   2639            uint8             rtrn;
   2640          
   2641            // Initialize all NV items for preconfigured TCLK
   2642            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \   00000C   75..00       MOV     ?V0 + 2,#0x0
   2643            {
   2644              // Making sure data is cleared for every key all the time
   2645              osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeyInit_0:
   \   00000F                ; Setup parameters for call to function osal_memset
   \   00000F   7C20         MOV     R4,#0x20
   \   000011   7D00         MOV     R5,#0x0
   \   000013   7900         MOV     R1,#0x0
   \   000015   85..82       MOV     DPL,?XSP + 0
   \   000018   85..83       MOV     DPH,?XSP + 1
   \   00001B   AA82         MOV     R2,DPL
   \   00001D   AB83         MOV     R3,DPH
   \   00001F   12....       LCALL   ??osal_memset?relay
   2646          
   2647              // Initialize first element of the table with the default TCLK
   2648              if((i == 0) && ( zgUseDefaultTCLK == TRUE ))
   \   000022   E5..         MOV     A,?V0 + 2
   \   000024   703E         JNZ     ??APSME_TCLinkKeyInit_1
   \   000026   90....       MOV     DPTR,#zgUseDefaultTCLK
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   6401         XRL     A,#0x1
   \   00002C   7036         JNZ     ??APSME_TCLinkKeyInit_1
   2649              {
   2650                osal_memset( tcLinkKey.extAddr, 0xFF, Z_EXTADDR_LEN );
   \   00002E                ; Setup parameters for call to function osal_memset
   \   00002E   7C08         MOV     R4,#0x8
   \   000030   7D00         MOV     R5,#0x0
   \   000032   79FF         MOV     R1,#-0x1
   \   000034   85..82       MOV     DPL,?XSP + 0
   \   000037   85..83       MOV     DPH,?XSP + 1
   \   00003A   AA82         MOV     R2,DPL
   \   00003C   AB83         MOV     R3,DPH
   \   00003E   12....       LCALL   ??osal_memset?relay
   2651                osal_memcpy( tcLinkKey.key, defaultTCLinkKey, SEC_KEY_LEN);
   \   000041                ; Setup parameters for call to function osal_memcpy
   \   000041   75....       MOV     ?V0 + 4,#defaultTCLinkKey & 0xff
   \   000044   75....       MOV     ?V0 + 5,#(defaultTCLinkKey >> 8) & 0xff
   \   000047   75..80       MOV     ?V0 + 6,#-0x80
   \   00004A   78..         MOV     R0,#?V0 + 4
   \   00004C   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00004F   7C10         MOV     R4,#0x10
   \   000051   7D00         MOV     R5,#0x0
   \   000053   740B         MOV     A,#0xb
   \   000055   12....       LCALL   ?XSTACK_DISP0_8
   \   000058   AA82         MOV     R2,DPL
   \   00005A   AB83         MOV     R3,DPH
   \   00005C   12....       LCALL   ??osal_memcpy?relay
   \   00005F   7403         MOV     A,#0x3
   \   000061   12....       LCALL   ?DEALLOC_XSTACK8
   2652              }
   2653          
   2654              // If the item doesn't exist in NV memory, create and initialize
   2655              // it with the default value passed in, either defaultTCLK or 0
   2656              rtrn = osal_nv_item_init( (ZCD_NV_TCLK_TABLE_START + i),
   2657                                         sizeof(APSME_TCLinkKey_t), &tcLinkKey);
   2658          
   2659              if (rtrn == SUCCESS)
   \                     ??APSME_TCLinkKeyInit_1:
   \   000064   85..82       MOV     DPL,?V0 + 2
   \   000067   8582..       MOV     ?V0 + 0,DPL
   \   00006A   E5..         MOV     A,?V0 + 0
   \   00006C   2401         ADD     A,#0x1
   \   00006E   FE           MOV     R6,A
   \   00006F   E4           CLR     A
   \   000070   3401         ADDC    A,#0x1
   \   000072   FF           MOV     R7,A
   \   000073                ; Setup parameters for call to function osal_nv_item_init
   \   000073   85..82       MOV     DPL,?XSP + 0
   \   000076   85..83       MOV     DPH,?XSP + 1
   \   000079   8582..       MOV     ?V0 + 4,DPL
   \   00007C   8583..       MOV     ?V0 + 5,DPH
   \   00007F   78..         MOV     R0,#?V0 + 4
   \   000081   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000084   7C20         MOV     R4,#0x20
   \   000086   7D00         MOV     R5,#0x0
   \   000088   EE           MOV     A,R6
   \   000089   FA           MOV     R2,A
   \   00008A   EF           MOV     A,R7
   \   00008B   FB           MOV     R3,A
   \   00008C   12....       LCALL   ??osal_nv_item_init?relay
   \   00008F   7402         MOV     A,#0x2
   \   000091   12....       LCALL   ?DEALLOC_XSTACK8
   \   000094   E9           MOV     A,R1
   \   000095   6003         JZ      $+5
   \   000097   02....       LJMP    ??APSME_TCLinkKeyInit_2 & 0xFFFF
   2660              {
   2661                // set the Frame counters to 0 to existing keys in NV
   2662                osal_nv_read( ( ZCD_NV_TCLK_TABLE_START + i), 0,
   2663                               sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   00009A                ; Setup parameters for call to function osal_nv_read
   \   00009A   78..         MOV     R0,#?V0 + 4
   \   00009C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009F   75..20       MOV     ?V0 + 4,#0x20
   \   0000A2   75..00       MOV     ?V0 + 5,#0x0
   \   0000A5   78..         MOV     R0,#?V0 + 4
   \   0000A7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AA   7C00         MOV     R4,#0x0
   \   0000AC   7D00         MOV     R5,#0x0
   \   0000AE   EE           MOV     A,R6
   \   0000AF   FA           MOV     R2,A
   \   0000B0   EF           MOV     A,R7
   \   0000B1   FB           MOV     R3,A
   \   0000B2   12....       LCALL   ??osal_nv_read?relay
   \   0000B5   7404         MOV     A,#0x4
   \   0000B7   12....       LCALL   ?DEALLOC_XSTACK8
   2664          
   2665          #if defined ( NV_RESTORE )
   2666                if (setDefault == TRUE)
   \   0000BA   7401         MOV     A,#0x1
   \   0000BC   65..         XRL     A,?V0 + 3
   \   0000BE   700A         JNZ     ??APSME_TCLinkKeyInit_3
   2667                {
   2668                  // clear the value stored in NV
   2669                  tcLinkKey.txFrmCntr = 0;
   \   0000C0   7418         MOV     A,#0x18
   \   0000C2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C5   12....       LCALL   ??Subroutine66_0 & 0xFFFF
   2670                }
   \                     ??CrossCallReturnLabel_147:
   \   0000C8   8012         SJMP    ??APSME_TCLinkKeyInit_4
   2671                else
   2672                {
   2673                  // increase the value stored in NV
   2674                  tcLinkKey.txFrmCntr += ( MAX_TCLK_FRAMECOUNTER_CHANGES + 1 );
   \                     ??APSME_TCLinkKeyInit_3:
   \   0000CA   90....       MOV     DPTR,#__Constant_b
   \   0000CD   78..         MOV     R0,#?V0 + 4
   \   0000CF   12....       LCALL   ?L_MOV_X
   \   0000D2   7418         MOV     A,#0x18
   \   0000D4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D7   78..         MOV     R0,#?V0 + 4
   \   0000D9   12....       LCALL   ?L_ADD_TO_X
   2675                }
   2676          #else
   2677                // Clear the counters if NV_RESTORE is not enabled and this NV item
   2678                // already existed in the NV memory
   2679                tcLinkKey.txFrmCntr = 0;
   2680                tcLinkKey.rxFrmCntr = 0;
   2681          #endif  // NV_RESTORE
   2682          
   2683                osal_nv_write( ( ZCD_NV_TCLK_TABLE_START + i), 0,
   2684                                sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \                     ??APSME_TCLinkKeyInit_4:
   \   0000DC                ; Setup parameters for call to function osal_nv_write
   \   0000DC   85..82       MOV     DPL,?XSP + 0
   \   0000DF   85..83       MOV     DPH,?XSP + 1
   \   0000E2   8582..       MOV     ?V0 + 4,DPL
   \   0000E5   8583..       MOV     ?V0 + 5,DPH
   \   0000E8   78..         MOV     R0,#?V0 + 4
   \   0000EA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000ED   75..20       MOV     ?V0 + 4,#0x20
   \   0000F0   75..00       MOV     ?V0 + 5,#0x0
   \   0000F3   78..         MOV     R0,#?V0 + 4
   \   0000F5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F8   7C00         MOV     R4,#0x0
   \   0000FA   7D00         MOV     R5,#0x0
   \   0000FC   EE           MOV     A,R6
   \   0000FD   FA           MOV     R2,A
   \   0000FE   EF           MOV     A,R7
   \   0000FF   FB           MOV     R3,A
   \   000100   12....       LCALL   ??osal_nv_write?relay
   \   000103   7404         MOV     A,#0x4
   \   000105   12....       LCALL   ?DEALLOC_XSTACK8
   2685          
   2686                // set initial values for counters in RAM
   2687                TCLinkKeyFrmCntr[i].txFrmCntr = tcLinkKey.txFrmCntr;
   \   000108   E5..         MOV     A,?V0 + 0
   \   00010A   75F009       MOV     B,#0x9
   \   00010D   A4           MUL     AB
   \   00010E   F5..         MOV     ?V0 + 0,A
   \   000110   E5F0         MOV     A,B
   \   000112   F5..         MOV     ?V0 + 1,A
   \   000114   74..         MOV     A,#TCLinkKeyFrmCntr & 0xff
   \   000116   25..         ADD     A,?V0 + 0
   \   000118   F8           MOV     R0,A
   \   000119   74..         MOV     A,#(TCLinkKeyFrmCntr >> 8) & 0xff
   \   00011B   35..         ADDC    A,?V0 + 1
   \   00011D   F9           MOV     R1,A
   \   00011E   7418         MOV     A,#0x18
   \   000120   12....       LCALL   ?XSTACK_DISP0_8
   \   000123   12....       LCALL   ?XLOAD_R2345
   \   000126   8882         MOV     DPL,R0
   \   000128   8983         MOV     DPH,R1
   \   00012A   12....       LCALL   ?XSTORE_R2345
   2688                TCLinkKeyFrmCntr[i].rxFrmCntr = tcLinkKey.rxFrmCntr;
   \   00012D   741C         MOV     A,#0x1c
   \   00012F   12....       LCALL   ?XSTACK_DISP0_8
   \   000132   12....       LCALL   ?XLOAD_R2345
   \   000135   8882         MOV     DPL,R0
   \   000137   8983         MOV     DPH,R1
   \   000139   A3           INC     DPTR
   \   00013A   A3           INC     DPTR
   \   00013B   A3           INC     DPTR
   \   00013C   A3           INC     DPTR
   \   00013D   12....       LCALL   ?XSTORE_R2345
   2689              }
   2690            }
   \                     ??APSME_TCLinkKeyInit_2:
   \   000140   05..         INC     ?V0 + 2
   \   000142   EE           MOV     A,R6
   \   000143   C3           CLR     C
   \   000144   9402         SUBB    A,#0x2
   \   000146   5003         JNC     $+5
   \   000148   02....       LJMP    ??APSME_TCLinkKeyInit_0 & 0xFFFF
   2691          
   2692            // clear copy of key in RAM
   2693            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \   00014B                ; Setup parameters for call to function osal_memset
   \   00014B   7C20         MOV     R4,#0x20
   \   00014D   7D00         MOV     R5,#0x0
   \   00014F   7900         MOV     R1,#0x0
   \   000151   85..82       MOV     DPL,?XSP + 0
   \   000154   85..83       MOV     DPH,?XSP + 1
   \   000157   AA82         MOV     R2,DPL
   \   000159   AB83         MOV     R3,DPH
   \   00015B   12....       LCALL   ??osal_memset?relay
   2694          
   2695          }
   \   00015E   7420         MOV     A,#0x20
   \   000160   02....       LJMP    ?Subroutine2 & 0xFFFF
   2696          
   2697          /******************************************************************************
   2698           * @fn          APSME_TCLinkKeySync
   2699           *
   2700           * @brief       Sync Trust Center LINK key data.
   2701           *
   2702           * @param       srcAddr - [in] srcAddr
   2703           * @param       si      - [in, out] SSP_Info_t
   2704           *
   2705           * @return      ZStatus_t
   2706           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2707          ZStatus_t APSME_TCLinkKeySync( uint16 srcAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeySync:
   2708          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 6,R2
   \   00000C   8B..         MOV     ?V0 + 7,R3
   \   00000E   8C..         MOV     ?V0 + 4,R4
   \   000010   8D..         MOV     ?V0 + 5,R5
   2709            uint8 i, selectedId = ZDSECMGR_TC_DEVICE_MAX;
   \   000012   75..02       MOV     ?V0 + 1,#0x2
   2710            ZStatus_t status = ZSecNoKey;
   \   000015   75..A1       MOV     ?V0 + 0,#-0x5f
   2711            APSME_TCLinkKey_t tcLinkKey;
   2712            uint32 *tclkRxFrmCntr;
   2713            uint16 originatorAddr = APSME_TRUSTCENTER_NWKADDR;
   \   000018   75..00       MOV     ?V0 + 2,#0x0
   \   00001B   75..00       MOV     ?V0 + 3,#0x0
   2714          
   2715            // Look up the IEEE address of the trust center if it's available
   2716            if ( AddrMgrExtAddrValid( si->extAddr ) == FALSE )
   \   00001E   EC           MOV     A,R4
   \   00001F   2406         ADD     A,#0x6
   \   000021   FE           MOV     R6,A
   \   000022   ED           MOV     A,R5
   \   000023   3400         ADDC    A,#0x0
   \   000025   FF           MOV     R7,A
   \   000026                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   000026   EE           MOV     A,R6
   \   000027   FA           MOV     R2,A
   \   000028   EF           MOV     A,R7
   \   000029   FB           MOV     R3,A
   \   00002A   12....       LCALL   ??AddrMgrExtAddrValid?relay
   \   00002D   E9           MOV     A,R1
   \   00002E   700D         JNZ     ??APSME_TCLinkKeySync_0
   2717            {
   2718              APSME_LookupExtAddr( srcAddr, si->extAddr );
   \   000030                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000030   EE           MOV     A,R6
   \   000031   FC           MOV     R4,A
   \   000032   EF           MOV     A,R7
   \   000033   FD           MOV     R5,A
   \   000034   AA..         MOV     R2,?V0 + 6
   \   000036   AB..         MOV     R3,?V0 + 7
   \   000038   12....       LCALL   ??APSME_LookupExtAddr?relay
   \   00003B   8018         SJMP    ??APSME_TCLinkKeySync_1
   2719            }
   2720            else if ( osal_ExtAddrEqual( si->extAddr, _NIB.nwkCoordExtAddress ) )
   \                     ??APSME_TCLinkKeySync_0:
   \   00003D                ; Setup parameters for call to function sAddrExtCmp
   \   00003D   7C..         MOV     R4,#(_NIB + 25) & 0xff
   \   00003F   7D..         MOV     R5,#((_NIB + 25) >> 8) & 0xff
   \   000041   EE           MOV     A,R6
   \   000042   FA           MOV     R2,A
   \   000043   EF           MOV     A,R7
   \   000044   FB           MOV     R3,A
   \   000045   12....       LCALL   ??sAddrExtCmp?relay
   \   000048   E9           MOV     A,R1
   \   000049   600A         JZ      ??APSME_TCLinkKeySync_1
   2721            {
   2722              originatorAddr = _NIB.nwkCoordAddress;
   \   00004B   90....       MOV     DPTR,#_NIB + 23
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   F5..         MOV     ?V0 + 2,A
   \   000051   A3           INC     DPTR
   \   000052   E0           MOVX    A,@DPTR
   \   000053   F5..         MOV     ?V0 + 3,A
   2723              // in case originated not from our parent, use the default TC address
   2724            }
   2725          
   2726            // Look up the TC link key associated with the device
   2727            // or the default TC link key (extAddr is all FFs), whichever is found
   2728            for ( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \                     ??APSME_TCLinkKeySync_1:
   \   000055   75..00       MOV     ?V0 + 6,#0x0
   2729            {
   2730              // Read entry i of the TC link key table from NV
   2731              osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0,
   2732                           sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \                     ??APSME_TCLinkKeySync_2:
   \   000058                ; Setup parameters for call to function osal_nv_read
   \   000058   85..82       MOV     DPL,?XSP + 0
   \   00005B   85..83       MOV     DPH,?XSP + 1
   \   00005E   8582..       MOV     ?V0 + 8,DPL
   \   000061   8583..       MOV     ?V0 + 9,DPH
   \   000064   78..         MOV     R0,#?V0 + 8
   \   000066   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000069   75..20       MOV     ?V0 + 8,#0x20
   \   00006C   75..00       MOV     ?V0 + 9,#0x0
   \   00006F   78..         MOV     R0,#?V0 + 8
   \   000071   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000074   7C00         MOV     R4,#0x0
   \   000076   7D00         MOV     R5,#0x0
   \   000078   85....       MOV     ?V0 + 8,?V0 + 6
   \   00007B   E5..         MOV     A,?V0 + 8
   \   00007D   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   000080   12....       LCALL   ??osal_nv_read?relay
   \   000083   7404         MOV     A,#0x4
   \   000085   12....       LCALL   ?DEALLOC_XSTACK8
   2733          
   2734              // prefer exact match over default
   2735              if ( AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) )
   \   000088                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000088   85..82       MOV     DPL,?XSP + 0
   \   00008B   85..83       MOV     DPH,?XSP + 1
   \   00008E   AC82         MOV     R4,DPL
   \   000090   AD83         MOV     R5,DPH
   \   000092   EE           MOV     A,R6
   \   000093   FA           MOV     R2,A
   \   000094   EF           MOV     A,R7
   \   000095   FB           MOV     R3,A
   \   000096   12....       LCALL   ??AddrMgrExtAddrEqual?relay
   \   000099   E9           MOV     A,R1
   \   00009A   6005         JZ      ??APSME_TCLinkKeySync_3
   2736              {
   2737                selectedId = i;
   \   00009C   85....       MOV     ?V0 + 1,?V0 + 6
   2738                // break from the loop
   2739                break;
   \   00009F   8047         SJMP    ??APSME_TCLinkKeySync_4
   2740              }
   2741              else if ( APSME_IsDefaultTCLK(tcLinkKey.extAddr) )
   \                     ??APSME_TCLinkKeySync_3:
   \   0000A1                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   0000A1   85..82       MOV     DPL,?XSP + 0
   \   0000A4   85..83       MOV     DPH,?XSP + 1
   \   0000A7   AA82         MOV     R2,DPL
   \   0000A9   AB83         MOV     R3,DPH
   \   0000AB   12....       LCALL   ??APSME_IsDefaultTCLK?relay
   \   0000AE   E9           MOV     A,R1
   \   0000AF   602B         JZ      ??APSME_TCLinkKeySync_5
   2742              {
   2743                if ( ( originatorAddr != APSME_TRUSTCENTER_NWKADDR ) && ( si->keyID == SEC_KEYID_TRANSPORT )
   2744                     && (i == 0) && ( zgUseDefaultTCLK == TRUE ) )
   \   0000B1   E5..         MOV     A,?V0 + 2
   \   0000B3   45..         ORL     A,?V0 + 3
   \   0000B5   601C         JZ      ??APSME_TCLinkKeySync_6
   \   0000B7   E5..         MOV     A,?V0 + 4
   \   0000B9   240E         ADD     A,#0xe
   \   0000BB   F582         MOV     DPL,A
   \   0000BD   E5..         MOV     A,?V0 + 5
   \   0000BF   12....       LCALL   ??Subroutine71_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_184:
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   6402         XRL     A,#0x2
   \   0000C5   700C         JNZ     ??APSME_TCLinkKeySync_6
   \   0000C7   E5..         MOV     A,?V0 + 6
   \   0000C9   7008         JNZ     ??APSME_TCLinkKeySync_6
   \   0000CB   90....       MOV     DPTR,#zgUseDefaultTCLK
   \   0000CE   E0           MOVX    A,@DPTR
   \   0000CF   6401         XRL     A,#0x1
   \   0000D1   6009         JZ      ??APSME_TCLinkKeySync_5
   2745                {
   2746                  //if a Key is received directly from an unusual TC,
   2747                  // don't use the first element of the table initialized with the default TCLK
   2748                  continue;
   2749                }
   2750                if ( selectedId == ZDSECMGR_TC_DEVICE_MAX )
   \                     ??APSME_TCLinkKeySync_6:
   \   0000D3   7402         MOV     A,#0x2
   \   0000D5   65..         XRL     A,?V0 + 1
   \   0000D7   7003         JNZ     ??APSME_TCLinkKeySync_5
   2751                {
   2752                  selectedId = i;
   \   0000D9   85....       MOV     ?V0 + 1,?V0 + 6
   2753                }
   2754              }
   2755            }
   \                     ??APSME_TCLinkKeySync_5:
   \   0000DC   05..         INC     ?V0 + 6
   \   0000DE   E5..         MOV     A,?V0 + 6
   \   0000E0   C3           CLR     C
   \   0000E1   9402         SUBB    A,#0x2
   \   0000E3   5003         JNC     $+5
   \   0000E5   02....       LJMP    ??APSME_TCLinkKeySync_2 & 0xFFFF
   2756          
   2757            if ( selectedId < ZDSECMGR_TC_DEVICE_MAX )
   \                     ??APSME_TCLinkKeySync_4:
   \   0000E8   E5..         MOV     A,?V0 + 1
   \   0000EA   C3           CLR     C
   \   0000EB   9402         SUBB    A,#0x2
   \   0000ED   5065         JNC     ??APSME_TCLinkKeySync_7
   2758            {
   2759               // Only for UNIQUE keys, verify that the incoming frame counter is valid
   2760              if ( zgApsLinkKeyType == ZG_UNIQUE_LINK_KEY )
   \   0000EF   85..82       MOV     DPL,?V0 + 1
   \   0000F2   A882         MOV     R0,DPL
   \   0000F4   E8           MOV     A,R0
   \   0000F5   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   0000F8   E5..         MOV     A,?V0 + 4
   \   0000FA   240F         ADD     A,#0xf
   \   0000FC   FE           MOV     R6,A
   \   0000FD   E5..         MOV     A,?V0 + 5
   \   0000FF   3400         ADDC    A,#0x0
   \   000101   FF           MOV     R7,A
   \   000102   90....       MOV     DPTR,#zgApsLinkKeyType
   \   000105   E0           MOVX    A,@DPTR
   \   000106   7046         JNZ     ??APSME_TCLinkKeySync_8
   2761              {
   2762                tclkRxFrmCntr = &TCLinkKeyFrmCntr[selectedId].rxFrmCntr;
   \   000108   E8           MOV     A,R0
   \   000109   75F009       MOV     B,#0x9
   \   00010C   A4           MUL     AB
   \   00010D   F8           MOV     R0,A
   \   00010E   A9F0         MOV     R1,B
   \   000110   74..         MOV     A,#(TCLinkKeyFrmCntr + 4) & 0xff
   \   000112   28           ADD     A,R0
   \   000113   FC           MOV     R4,A
   \   000114   74..         MOV     A,#((TCLinkKeyFrmCntr + 4) >> 8) & 0xff
   \   000116   39           ADDC    A,R1
   \   000117   FD           MOV     R5,A
   2763          
   2764                if ( si->frmCntr >= *tclkRxFrmCntr )
   \   000118   E5..         MOV     A,?V0 + 4
   \   00011A   2412         ADD     A,#0x12
   \   00011C   F582         MOV     DPL,A
   \   00011E   E5..         MOV     A,?V0 + 5
   \   000120   12....       LCALL   ??Subroutine71_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_185:
   \   000123   78..         MOV     R0,#?V0 + 4
   \   000125   12....       LCALL   ?L_MOV_X
   \   000128   8C82         MOV     DPL,R4
   \   00012A   8D83         MOV     DPH,R5
   \   00012C   78..         MOV     R0,#?V0 + 4
   \   00012E   12....       LCALL   ?UL_GE_X
   \   000131   5016         JNC     ??APSME_TCLinkKeySync_9
   2765                {
   2766                  // set the keyNvId to use
   2767                  si->keyNvId = (ZCD_NV_TCLK_TABLE_START + selectedId);
   \   000133   12....       LCALL   ?Subroutine42 & 0xFFFF
   2768          
   2769                  // update the rx frame counter
   2770                  *tclkRxFrmCntr = si->frmCntr + 1;
   \                     ??CrossCallReturnLabel_116:
   \   000136   90....       MOV     DPTR,#__Constant_1
   \   000139   78..         MOV     R0,#?V0 + 4
   \   00013B   12....       LCALL   ?L_ADD_X
   \   00013E   8C82         MOV     DPL,R4
   \   000140   8D83         MOV     DPH,R5
   \   000142   78..         MOV     R0,#?V0 + 4
   \   000144   12....       LCALL   ?L_MOV_TO_X
   2771          
   2772                  status = ZSuccess;
   \   000147   8008         SJMP    ??CrossCallReturnLabel_117
   2773                }
   2774                else
   2775                {
   2776                  status = ZSecOldFrmCount;
   \                     ??APSME_TCLinkKeySync_9:
   \   000149   75..A2       MOV     ?V0 + 0,#-0x5e
   \   00014C   8006         SJMP    ??APSME_TCLinkKeySync_7
   2777                }
   2778              }
   2779              else
   2780              {
   2781                // set the keyNvId to use
   2782                si->keyNvId = (ZCD_NV_TCLK_TABLE_START + selectedId);
   \                     ??APSME_TCLinkKeySync_8:
   \   00014E   12....       LCALL   ?Subroutine42 & 0xFFFF
   2783          
   2784                status = ZSuccess;
   \                     ??CrossCallReturnLabel_117:
   \   000151   75..00       MOV     ?V0 + 0,#0x0
   2785              }
   2786            }
   2787          
   2788            // clear copy of key in RAM
   2789            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeySync_7:
   \   000154                ; Setup parameters for call to function osal_memset
   \   000154   7C20         MOV     R4,#0x20
   \   000156   7D00         MOV     R5,#0x0
   \   000158   7900         MOV     R1,#0x0
   \   00015A   85..82       MOV     DPL,?XSP + 0
   \   00015D   85..83       MOV     DPH,?XSP + 1
   \   000160   AA82         MOV     R2,DPL
   \   000162   AB83         MOV     R3,DPH
   \   000164   12....       LCALL   ??osal_memset?relay
   2790          
   2791            return status;
   \   000167   A9..         MOV     R1,?V0 + 0
   \   000169   7420         MOV     A,#0x20
   \   00016B   02....       LJMP    ?Subroutine6 & 0xFFFF
   2792          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   2401         ADD     A,#0x1
   \   000002   FA           MOV     R2,A
   \   000003   E4           CLR     A
   \   000004   3401         ADDC    A,#0x1
   \   000006   FB           MOV     R3,A
   \   000007   22           RET
   2793          
   2794          /******************************************************************************
   2795           * @fn          APSME_TCLinkKeyLoad
   2796           *
   2797           * @brief       Load Trust Center LINK key data.
   2798           *
   2799           * @param       dstAddr - [in] dstAddr
   2800           * @param       si      - [in, out] SSP_Info_t
   2801           *
   2802           * @return      ZStatus_t
   2803           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2804          ZStatus_t APSME_TCLinkKeyLoad( uint16 dstAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeyLoad:
   2805          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 45
   \   000005   74D3         MOV     A,#-0x2d
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8C..         MOV     ?V0 + 0,R4
   \   00000C   8D..         MOV     ?V0 + 1,R5
   2806            uint8 i;
   2807            ZStatus_t status = ZSecNoKey;
   \   00000E   7EA1         MOV     R6,#-0x5f
   2808            APSME_TCLinkKey_t tcLinkKey;
   2809            AddrMgrEntry_t addrEntry;
   2810            uint32 *tclkTxFrmCntr;
   2811            uint8 extAddrFound;
   2812            uint8 defaultTCLKIdx = ZDSECMGR_TC_DEVICE_MAX;
   \   000010   75..02       MOV     ?V0 + 8,#0x2
   2813          
   2814            // Look up the ami of the srcAddr if available
   2815            addrEntry.user    = ADDRMGR_USER_DEFAULT;
   \   000013   85..82       MOV     DPL,?XSP + 0
   \   000016   85..83       MOV     DPH,?XSP + 1
   \   000019   E4           CLR     A
   \   00001A   F0           MOVX    @DPTR,A
   2816            addrEntry.nwkAddr = dstAddr;
   \   00001B   04           INC     A
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   12....       LCALL   ??Subroutine62_0 & 0xFFFF
   2817          
   2818            extAddrFound = AddrMgrExtAddrValid( si->extAddr );
   \                     ??CrossCallReturnLabel_112:
   \   000022   EC           MOV     A,R4
   \   000023   2406         ADD     A,#0x6
   \   000025   F5..         MOV     ?V0 + 2,A
   \   000027   ED           MOV     A,R5
   \   000028   3400         ADDC    A,#0x0
   \   00002A   F5..         MOV     ?V0 + 3,A
   \   00002C                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   00002C   AA..         MOV     R2,?V0 + 2
   \   00002E   FB           MOV     R3,A
   \   00002F   12....       LCALL   ??AddrMgrExtAddrValid?relay
   \   000032   E9           MOV     A,R1
   \   000033   F5..         MOV     ?V0 + 6,A
   2819          
   2820            // Look up the TC link key associated with the device
   2821            // or the master TC link key (ami = 0xFFFF), whichever is found
   2822            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \   000035   7F00         MOV     R7,#0x0
   2823            {
   2824              // Read entry i of the TC link key table from NV
   2825              osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0,
   2826                           sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \                     ??APSME_TCLinkKeyLoad_0:
   \   000037                ; Setup parameters for call to function osal_nv_read
   \   000037   740D         MOV     A,#0xd
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   8582..       MOV     ?V0 + 4,DPL
   \   00003F   8583..       MOV     ?V0 + 5,DPH
   \   000042   78..         MOV     R0,#?V0 + 4
   \   000044   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000047   75..20       MOV     ?V0 + 4,#0x20
   \   00004A   75..00       MOV     ?V0 + 5,#0x0
   \   00004D   78..         MOV     R0,#?V0 + 4
   \   00004F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000052   7C00         MOV     R4,#0x0
   \   000054   7D00         MOV     R5,#0x0
   \   000056   8F..         MOV     ?V0 + 4,R7
   \   000058   E5..         MOV     A,?V0 + 4
   \   00005A   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   00005D   12....       LCALL   ??osal_nv_read?relay
   \   000060   7404         MOV     A,#0x4
   \   000062   12....       LCALL   ?DEALLOC_XSTACK8
   2827          
   2828              if( extAddrFound && AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) )
   \   000065   E5..         MOV     A,?V0 + 6
   \   000067   6013         JZ      ??APSME_TCLinkKeyLoad_1
   \   000069                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000069   740D         MOV     A,#0xd
   \   00006B   12....       LCALL   ?XSTACK_DISP0_8
   \   00006E   AC82         MOV     R4,DPL
   \   000070   AD83         MOV     R5,DPH
   \   000072   AA..         MOV     R2,?V0 + 2
   \   000074   AB..         MOV     R3,?V0 + 3
   \   000076   12....       LCALL   ??AddrMgrExtAddrEqual?relay
   \   000079   E9           MOV     A,R1
   \   00007A   702E         JNZ     ??APSME_TCLinkKeyLoad_2
   2829              {
   2830                status = ZSuccess;
   2831          
   2832                break; // break from the loop
   2833              }
   2834          
   2835              if ( APSME_IsDefaultTCLK(tcLinkKey.extAddr) )
   \                     ??APSME_TCLinkKeyLoad_1:
   \   00007C                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   00007C   740D         MOV     A,#0xd
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   AA82         MOV     R2,DPL
   \   000083   AB83         MOV     R3,DPH
   \   000085   12....       LCALL   ??APSME_IsDefaultTCLK?relay
   \   000088   E9           MOV     A,R1
   \   000089   600C         JZ      ??APSME_TCLinkKeyLoad_3
   2836              {
   2837                if ( !extAddrFound && ( !APSME_IsDistributedSecurity() ) )
   \   00008B   E5..         MOV     A,?V0 + 6
   \   00008D   7006         JNZ     ??APSME_TCLinkKeyLoad_4
   \   00008F                ; Setup parameters for call to function APSME_IsDistributedSecurity
   \   00008F   12....       LCALL   ??APSME_IsDistributedSecurity?relay
   \   000092   E9           MOV     A,R1
   \   000093   6015         JZ      ??APSME_TCLinkKeyLoad_2
   2838                {
   2839                  status = ZSuccess;
   2840          
   2841                  break; // break from the loop
   2842                }
   2843          
   2844                // Remember the last default TCLK index
   2845                defaultTCLKIdx = i;
   2846              }
   2847            }
   2848          
   2849            if ( (status != ZSuccess) && (defaultTCLKIdx < ZDSECMGR_TC_DEVICE_MAX) )
   2850            {
   2851              // Exact match was not found; use the last default TC Link Key
   2852              i = defaultTCLKIdx;
   2853              status = ZSuccess;
   2854            }
   2855          
   2856            if ( status == ZSuccess )
   \                     ??APSME_TCLinkKeyLoad_4:
   \   000095   8F..         MOV     ?V0 + 8,R7
   \                     ??APSME_TCLinkKeyLoad_3:
   \   000097   0F           INC     R7
   \   000098   EF           MOV     A,R7
   \   000099   C3           CLR     C
   \   00009A   9402         SUBB    A,#0x2
   \   00009C   4099         JC      ??APSME_TCLinkKeyLoad_0
   \   00009E   E5..         MOV     A,?V0 + 8
   \   0000A0   C3           CLR     C
   \   0000A1   9402         SUBB    A,#0x2
   \   0000A3   4003         JC      $+5
   \   0000A5   02....       LJMP    ??APSME_TCLinkKeyLoad_5 & 0xFFFF
   \   0000A8   AF..         MOV     R7,?V0 + 8
   \                     ??APSME_TCLinkKeyLoad_2:
   \   0000AA   7E00         MOV     R6,#0x0
   2857            {
   2858              tclkTxFrmCntr = &TCLinkKeyFrmCntr[i].txFrmCntr;
   \   0000AC   8F82         MOV     DPL,R7
   \   0000AE   A882         MOV     R0,DPL
   \   0000B0   E8           MOV     A,R0
   \   0000B1   75F009       MOV     B,#0x9
   \   0000B4   A4           MUL     AB
   \   0000B5   FA           MOV     R2,A
   \   0000B6   ABF0         MOV     R3,B
   \   0000B8   74..         MOV     A,#TCLinkKeyFrmCntr & 0xff
   \   0000BA   2A           ADD     A,R2
   \   0000BB   F5..         MOV     ?V0 + 10,A
   \   0000BD   74..         MOV     A,#(TCLinkKeyFrmCntr >> 8) & 0xff
   \   0000BF   3B           ADDC    A,R3
   \   0000C0   F5..         MOV     ?V0 + 11,A
   \   0000C2   85....       MOV     ?V0 + 4,?V0 + 10
   \   0000C5   F5..         MOV     ?V0 + 5,A
   2859          
   2860              // set the keyNvId to use
   2861              si->keyNvId = (ZCD_NV_TCLK_TABLE_START + i);
   \   0000C7   E8           MOV     A,R0
   \   0000C8   2401         ADD     A,#0x1
   \   0000CA   08           INC     R0
   \   0000CB   E4           CLR     A
   \   0000CC   3401         ADDC    A,#0x1
   \   0000CE   F9           MOV     R1,A
   \   0000CF   E5..         MOV     A,?V0 + 0
   \   0000D1   240F         ADD     A,#0xf
   \   0000D3   F582         MOV     DPL,A
   \   0000D5   E5..         MOV     A,?V0 + 1
   \   0000D7   12....       LCALL   ??Subroutine71_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_186:
   \   0000DA   12....       LCALL   ??Subroutine63_0 & 0xFFFF
   2862          
   2863              // update link key related fields
   2864              si->keyID   = SEC_KEYID_LINK;
   \                     ??CrossCallReturnLabel_135:
   \   0000DD   E5..         MOV     A,?V0 + 0
   \   0000DF   240E         ADD     A,#0xe
   \   0000E1   F582         MOV     DPL,A
   \   0000E3   E5..         MOV     A,?V0 + 1
   \   0000E5   12....       LCALL   ??Subroutine71_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_187:
   \   0000E8   E4           CLR     A
   \   0000E9   F0           MOVX    @DPTR,A
   2865              si->frmCntr = *tclkTxFrmCntr;
   \   0000EA   85..82       MOV     DPL,?V0 + 4
   \   0000ED   85..83       MOV     DPH,?V0 + 5
   \   0000F0   12....       LCALL   ?XLOAD_R2345
   \   0000F3   E5..         MOV     A,?V0 + 0
   \   0000F5   2412         ADD     A,#0x12
   \   0000F7   F582         MOV     DPL,A
   \   0000F9   E5..         MOV     A,?V0 + 1
   \   0000FB   12....       LCALL   ??Subroutine71_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_188:
   \   0000FE   12....       LCALL   ?XSTORE_R2345
   2866          
   2867              // update outgoing frame counter
   2868              (*tclkTxFrmCntr)++;
   \   000101   90....       MOV     DPTR,#__Constant_1
   \   000104   78..         MOV     R0,#?V0 + 0
   \   000106   12....       LCALL   ?L_MOV_X
   \   000109   85..82       MOV     DPL,?V0 + 4
   \   00010C   85..83       MOV     DPH,?V0 + 5
   \   00010F   78..         MOV     R0,#?V0 + 0
   \   000111   12....       LCALL   ?L_ADD_TO_X
   2869          
   2870          #if defined ( NV_RESTORE )
   2871              // write periodically to NV
   2872              if ( !(*tclkTxFrmCntr % MAX_TCLK_FRAMECOUNTER_CHANGES) )
   \   000114   85..82       MOV     DPL,?V0 + 4
   \   000117   85..83       MOV     DPH,?V0 + 5
   \   00011A   78..         MOV     R0,#?V0 + 4
   \   00011C   12....       LCALL   ?L_MOV_X
   \   00011F   90....       MOV     DPTR,#__Constant_a
   \   000122   78..         MOV     R0,#?V0 + 0
   \   000124   12....       LCALL   ?L_MOV_X
   \   000127   78..         MOV     R0,#?V0 + 4
   \   000129   79..         MOV     R1,#?V0 + 0
   \   00012B   12....       LCALL   ?UL_DIV_MOD
   \   00012E   E5..         MOV     A,?V0 + 0
   \   000130   45..         ORL     A,?V0 + 1
   \   000132   45..         ORL     A,?V0 + 2
   \   000134   45..         ORL     A,?V0 + 3
   \   000136   703E         JNZ     ??APSME_TCLinkKeyLoad_6
   2873              {
   2874                // set the flag to write key to NV
   2875                TCLinkKeyFrmCntr[i].pendingFlag = TRUE;
   \   000138   85..82       MOV     DPL,?V0 + 10
   \   00013B   85..83       MOV     DPH,?V0 + 11
   \   00013E   A3           INC     DPTR
   \   00013F   A3           INC     DPTR
   \   000140   A3           INC     DPTR
   \   000141   A3           INC     DPTR
   \   000142   A3           INC     DPTR
   \   000143   A3           INC     DPTR
   \   000144   A3           INC     DPTR
   \   000145   A3           INC     DPTR
   \   000146   7401         MOV     A,#0x1
   \   000148   F0           MOVX    @DPTR,A
   2876          
   2877                // Notify the ZDApp that the frame counter has changed.
   2878                osal_set_event( ZDAppTaskID, ZDO_TCLK_FRAMECOUNTER_CHANGE );
   \   000149                ; Setup parameters for call to function osal_set_event
   \   000149   7A00         MOV     R2,#0x0
   \   00014B   7B04         MOV     R3,#0x4
   \   00014D   90....       MOV     DPTR,#ZDAppTaskID
   \   000150   E0           MOVX    A,@DPTR
   \   000151   F9           MOV     R1,A
   \   000152   12....       LCALL   ??osal_set_event?relay
   \   000155   801F         SJMP    ??APSME_TCLinkKeyLoad_6
   \                     ??APSME_TCLinkKeyLoad_5:
   \   000157                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   2879              }
   2880          #endif
   2881            }
   \   000157   85..82       MOV     DPL,?XSP + 0
   \   00015A   85..83       MOV     DPH,?XSP + 1
   \   00015D   AA82         MOV     R2,DPL
   \   00015F   AB83         MOV     R3,DPH
   \   000161   12....       LCALL   ??AddrMgrEntryLookupNwk?relay
   \   000164   E9           MOV     A,R1
   \   000165   6401         XRL     A,#0x1
   \   000167   700D         JNZ     ??APSME_TCLinkKeyLoad_6
   2882          
   2883            // If no TC link key found, remove the device from the address manager
   2884            if ( (status != ZSuccess) && (AddrMgrEntryLookupNwk(&addrEntry) == TRUE) )
   2885            {
   2886              AddrMgrEntryRelease( &addrEntry );
   \   000169                ; Setup parameters for call to function AddrMgrEntryRelease
   \   000169   85..82       MOV     DPL,?XSP + 0
   \   00016C   85..83       MOV     DPH,?XSP + 1
   \   00016F   AA82         MOV     R2,DPL
   \   000171   AB83         MOV     R3,DPH
   \   000173   12....       LCALL   ??AddrMgrEntryRelease?relay
   2887            }
   2888          
   2889              // clear copy of key in RAM
   2890            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeyLoad_6:
   \   000176                ; Setup parameters for call to function osal_memset
   \   000176   7C20         MOV     R4,#0x20
   \   000178   7D00         MOV     R5,#0x0
   \   00017A   7900         MOV     R1,#0x0
   \   00017C   740D         MOV     A,#0xd
   \   00017E   12....       LCALL   ?XSTACK_DISP0_8
   \   000181   AA82         MOV     R2,DPL
   \   000183   AB83         MOV     R3,DPH
   \   000185   12....       LCALL   ??osal_memset?relay
   2891          
   2892            return status;
   \   000188   EE           MOV     A,R6
   \   000189   F9           MOV     R1,A
   \   00018A   742D         MOV     A,#0x2d
   \   00018C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00018F   7F0C         MOV     R7,#0xc
   \   000191   02....       LJMP    ?BANKED_LEAVE_XDATA
   2893          }
   2894          
   2895          /******************************************************************************
   2896           * @fn          APSME_IsDefaultTCLK
   2897           *
   2898           * @brief       Return TRUE or FALSE based on the extended address.  If the
   2899           *              input ext address is all FFs, it means the trust center link
   2900           *              assoiciated with the address is the default trust center link key
   2901           *
   2902           * @param       extAddr - [in] extended address
   2903           *
   2904           * @return      uint8 TRUE/FALSE
   2905           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2906          uint8 APSME_IsDefaultTCLK( uint8 *extAddr )
   \                     APSME_IsDefaultTCLK:
   2907          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2908            return osal_isbufset( extAddr, 0xFF, Z_EXTADDR_LEN );
   \   000004                ; Setup parameters for call to function osal_isbufset
   \   000004   7C08         MOV     R4,#0x8
   \   000006   79FF         MOV     R1,#-0x1
   \   000008   12....       LCALL   ??osal_isbufset?relay
   \   00000B   02....       LJMP    ??Subroutine61_0 & 0xFFFF
   2909          }
   2910          
   2911          /******************************************************************************
   2912           * @fn          ZDSecMgrNwkKeyInit
   2913           *
   2914           * @brief       Initialize the NV items for
   2915           *                  ZCD_NV_NWKKEY,
   2916           *                  ZCD_NV_NWK_ACTIVE_KEY_INFO and
   2917           *                  ZCD_NV_NWK_ALTERN_KEY_INFO
   2918           *
   2919           * @param       setDefault
   2920           *
   2921           * @return      none
   2922           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2923          void ZDSecMgrNwkKeyInit(uint8 setDefault)
   \                     ZDSecMgrNwkKeyInit:
   2924          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 38
   \   000005   74DA         MOV     A,#-0x26
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   2925            uint8 status;
   2926            nwkKeyDesc nwkKey;
   2927          
   2928            // Initialize NV items for NWK key, this structure contains the frame counter
   2929            // and is only used when NV_RESTORE is enabled
   2930            nwkActiveKeyItems keyItems;
   2931          
   2932            osal_memset( &keyItems, 0, sizeof( nwkActiveKeyItems ) );
   \   00000C                ; Setup parameters for call to function osal_memset
   \   00000C   7C15         MOV     R4,#0x15
   \   00000E   7D00         MOV     R5,#0x0
   \   000010   7900         MOV     R1,#0x0
   \   000012   7411         MOV     A,#0x11
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   AA82         MOV     R2,DPL
   \   000019   AB83         MOV     R3,DPH
   \   00001B   12....       LCALL   ??osal_memset?relay
   2933          
   2934            status = osal_nv_item_init( ZCD_NV_NWKKEY, sizeof(nwkActiveKeyItems), (void *)&keyItems );
   2935          
   2936          #if defined ( NV_RESTORE )
   2937            // reset the values of NV items if NV_RESTORE is not enabled
   2938            if ((status == SUCCESS) && (setDefault == TRUE))
   \   00001E                ; Setup parameters for call to function osal_nv_item_init
   \   00001E   7411         MOV     A,#0x11
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   8582..       MOV     ?V0 + 0,DPL
   \   000026   8583..       MOV     ?V0 + 1,DPH
   \   000029   78..         MOV     R0,#?V0 + 0
   \   00002B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002E   7C15         MOV     R4,#0x15
   \   000030   7D00         MOV     R5,#0x0
   \   000032   7A82         MOV     R2,#-0x7e
   \   000034   7B00         MOV     R3,#0x0
   \   000036   12....       LCALL   ??osal_nv_item_init?relay
   \   000039   7402         MOV     A,#0x2
   \   00003B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003E   E9           MOV     A,R1
   \   00003F   7025         JNZ     ??ZDSecMgrNwkKeyInit_0
   \   000041   7401         MOV     A,#0x1
   \   000043   6E           XRL     A,R6
   \   000044   7020         JNZ     ??ZDSecMgrNwkKeyInit_0
   2939            {
   2940              // clear NV data to default values
   2941              osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems );
   \   000046                ; Setup parameters for call to function osal_nv_write
   \   000046   78..         MOV     R0,#?V0 + 0
   \   000048   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004B   75..15       MOV     ?V0 + 0,#0x15
   \   00004E   75..00       MOV     ?V0 + 1,#0x0
   \   000051   78..         MOV     R0,#?V0 + 0
   \   000053   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000056   7C00         MOV     R4,#0x0
   \   000058   7D00         MOV     R5,#0x0
   \   00005A   7A82         MOV     R2,#-0x7e
   \   00005C   7B00         MOV     R3,#0x0
   \   00005E   12....       LCALL   ??osal_nv_write?relay
   \   000061   7404         MOV     A,#0x4
   \   000063   12....       LCALL   ?DEALLOC_XSTACK8
   2942            }
   2943          #else
   2944            (void)setDefault;   // to eliminate compiler warning
   2945          
   2946            // reset the values of NV items if NV_RESTORE is not enabled
   2947            if (status == SUCCESS)
   2948            {
   2949              osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems );
   2950            }
   2951          #endif // defined (NV_RESTORE)
   2952          
   2953            // Initialize NV items for NWK Active and Alternate keys. These items are used
   2954            // all the time, independently of NV_RESTORE being set or not
   2955            osal_memset( &nwkKey, 0x00, sizeof(nwkKey) );
   \                     ??ZDSecMgrNwkKeyInit_0:
   \   000066                ; Setup parameters for call to function osal_memset
   \   000066   7C11         MOV     R4,#0x11
   \   000068   7D00         MOV     R5,#0x0
   \   00006A   7900         MOV     R1,#0x0
   \   00006C   85..82       MOV     DPL,?XSP + 0
   \   00006F   85..83       MOV     DPH,?XSP + 1
   \   000072   AA82         MOV     R2,DPL
   \   000074   AB83         MOV     R3,DPH
   \   000076   12....       LCALL   ??osal_memset?relay
   2956          
   2957            status = osal_nv_item_init( ZCD_NV_NWK_ACTIVE_KEY_INFO, sizeof(nwkKey), &nwkKey);
   2958          
   2959          #if defined ( NV_RESTORE )
   2960            // reset the values of NV items if NV_RESTORE is not enabled
   2961            if ((status == SUCCESS) && (setDefault == TRUE))
   \   000079                ; Setup parameters for call to function osal_nv_item_init
   \   000079   85..82       MOV     DPL,?XSP + 0
   \   00007C   85..83       MOV     DPH,?XSP + 1
   \   00007F   8582..       MOV     ?V0 + 0,DPL
   \   000082   8583..       MOV     ?V0 + 1,DPH
   \   000085   78..         MOV     R0,#?V0 + 0
   \   000087   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008A   7C11         MOV     R4,#0x11
   \   00008C   7D00         MOV     R5,#0x0
   \   00008E   7A3A         MOV     R2,#0x3a
   \   000090   7B00         MOV     R3,#0x0
   \   000092   12....       LCALL   ??osal_nv_item_init?relay
   \   000095   7402         MOV     A,#0x2
   \   000097   12....       LCALL   ?DEALLOC_XSTACK8
   \   00009A   E9           MOV     A,R1
   \   00009B   7025         JNZ     ??ZDSecMgrNwkKeyInit_1
   \   00009D   7401         MOV     A,#0x1
   \   00009F   6E           XRL     A,R6
   \   0000A0   7020         JNZ     ??ZDSecMgrNwkKeyInit_1
   2962            {
   2963              // clear NV data to default values
   2964              osal_nv_write( ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   \   0000A2                ; Setup parameters for call to function osal_nv_write
   \   0000A2   78..         MOV     R0,#?V0 + 0
   \   0000A4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A7   75..11       MOV     ?V0 + 0,#0x11
   \   0000AA   75..00       MOV     ?V0 + 1,#0x0
   \   0000AD   78..         MOV     R0,#?V0 + 0
   \   0000AF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B2   7C00         MOV     R4,#0x0
   \   0000B4   7D00         MOV     R5,#0x0
   \   0000B6   7A3A         MOV     R2,#0x3a
   \   0000B8   7B00         MOV     R3,#0x0
   \   0000BA   12....       LCALL   ??osal_nv_write?relay
   \   0000BD   7404         MOV     A,#0x4
   \   0000BF   12....       LCALL   ?DEALLOC_XSTACK8
   2965            }
   2966          #else
   2967            // reset the values of NV items if NV_RESTORE is not enabled
   2968            if (status == SUCCESS)
   2969            {
   2970              osal_nv_write( ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   2971            }
   2972          #endif // defined (NV_RESTORE)
   2973          
   2974            status = osal_nv_item_init( ZCD_NV_NWK_ALTERN_KEY_INFO, sizeof(nwkKey), &nwkKey );
   2975          
   2976          #if defined ( NV_RESTORE )
   2977            // reset the values of NV items if NV_RESTORE is not enabled
   2978            if ((status == SUCCESS) && (setDefault == TRUE))
   \                     ??ZDSecMgrNwkKeyInit_1:
   \   0000C2                ; Setup parameters for call to function osal_nv_item_init
   \   0000C2   85..82       MOV     DPL,?XSP + 0
   \   0000C5   85..83       MOV     DPH,?XSP + 1
   \   0000C8   8582..       MOV     ?V0 + 0,DPL
   \   0000CB   8583..       MOV     ?V0 + 1,DPH
   \   0000CE   78..         MOV     R0,#?V0 + 0
   \   0000D0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000D3   7C11         MOV     R4,#0x11
   \   0000D5   7D00         MOV     R5,#0x0
   \   0000D7   7A3B         MOV     R2,#0x3b
   \   0000D9   7B00         MOV     R3,#0x0
   \   0000DB   12....       LCALL   ??osal_nv_item_init?relay
   \   0000DE   7402         MOV     A,#0x2
   \   0000E0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E3   E9           MOV     A,R1
   \   0000E4   7025         JNZ     ??ZDSecMgrNwkKeyInit_2
   \   0000E6   7401         MOV     A,#0x1
   \   0000E8   6E           XRL     A,R6
   \   0000E9   7020         JNZ     ??ZDSecMgrNwkKeyInit_2
   2979            {
   2980              // clear NV data to default values
   2981              osal_nv_write( ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   \   0000EB                ; Setup parameters for call to function osal_nv_write
   \   0000EB   78..         MOV     R0,#?V0 + 0
   \   0000ED   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F0   75..11       MOV     ?V0 + 0,#0x11
   \   0000F3   75..00       MOV     ?V0 + 1,#0x0
   \   0000F6   78..         MOV     R0,#?V0 + 0
   \   0000F8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000FB   7C00         MOV     R4,#0x0
   \   0000FD   7D00         MOV     R5,#0x0
   \   0000FF   7A3B         MOV     R2,#0x3b
   \   000101   7B00         MOV     R3,#0x0
   \   000103   12....       LCALL   ??osal_nv_write?relay
   \   000106   7404         MOV     A,#0x4
   \   000108   12....       LCALL   ?DEALLOC_XSTACK8
   2982            }
   2983          #else
   2984            // reset the values of NV items if NV_RESTORE is not enabled
   2985            if (status == SUCCESS)
   2986            {
   2987              osal_nv_write( ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   2988            }
   2989          #endif // defined (NV_RESTORE)
   2990          
   2991          }
   \                     ??ZDSecMgrNwkKeyInit_2:
   \   00010B                REQUIRE ?Subroutine9
   \   00010B                ; // Fall through to label ?Subroutine9

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   7426         MOV     A,#0x26
   \   000002   80..         SJMP    ??Subroutine72_0
   2992          
   2993          /*********************************************************************
   2994           * @fn          ZDSecMgrReadKeyFromNv
   2995           *
   2996           * @brief       Looks for a specific key in NV based on Index value
   2997           *
   2998           * @param   keyNvId - Index of key to look in NV
   2999           *                    valid values are:
   3000           *                    ZCD_NV_NWK_ACTIVE_KEY_INFO
   3001           *                    ZCD_NV_NWK_ALTERN_KEY_INFO
   3002           *                    ZCD_NV_TCLK_TABLE_START + <offset_in_table>
   3003           *                    ZCD_NV_APS_LINK_KEY_DATA_START + <offset_in_table>
   3004           *                    ZCD_NV_PRECFGKEY
   3005           *
   3006           * @param  *keyinfo - Data is read into this buffer.
   3007           *
   3008           * @return  SUCCESS if NV data was copied to the keyinfo parameter .
   3009           *          Otherwise, NV_OPER_FAILED for failure.
   3010           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3011          ZStatus_t ZDSecMgrReadKeyFromNv(uint16 keyNvId, void *keyinfo)
   \                     ZDSecMgrReadKeyFromNv:
   3012          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   3013            if ((keyNvId == ZCD_NV_NWK_ACTIVE_KEY_INFO) ||
   3014                (keyNvId == ZCD_NV_NWK_ALTERN_KEY_INFO))
   \   000005   743A         MOV     A,#0x3a
   \   000007   6A           XRL     A,R2
   \   000008   7001         JNZ     ??ZDSecMgrReadKeyFromNv_0
   \   00000A   EB           MOV     A,R3
   \                     ??ZDSecMgrReadKeyFromNv_0:
   \   00000B   6008         JZ      ??ZDSecMgrReadKeyFromNv_1
   \   00000D   743B         MOV     A,#0x3b
   \   00000F   6A           XRL     A,R2
   \   000010   7001         JNZ     ??ZDSecMgrReadKeyFromNv_2
   \   000012   EB           MOV     A,R3
   \                     ??ZDSecMgrReadKeyFromNv_2:
   \   000013   7018         JNZ     ??ZDSecMgrReadKeyFromNv_3
   3015            {
   3016              // get NWK active or alternate key from NV
   3017              return (osal_nv_read(keyNvId,
   3018                                   osal_offsetof(nwkKeyDesc, key),
   3019                                   SEC_KEY_LEN,
   3020                                   keyinfo));
   \                     ??ZDSecMgrReadKeyFromNv_1:
   \   000015                ; Setup parameters for call to function osal_nv_read
   \   000015   8C..         MOV     ?V0 + 0,R4
   \   000017   8D..         MOV     ?V0 + 1,R5
   \   000019   78..         MOV     R0,#?V0 + 0
   \   00001B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001E   75..10       MOV     ?V0 + 0,#0x10
   \   000021   75..00       MOV     ?V0 + 1,#0x0
   \   000024   78..         MOV     R0,#?V0 + 0
   \   000026   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000029   7C01         MOV     R4,#0x1
   \   00002B   8049         SJMP    ??ZDSecMgrReadKeyFromNv_4
   3021            }
   3022            else if ((keyNvId >= ZCD_NV_TCLK_TABLE_START) &&
   3023                     (keyNvId < (ZCD_NV_TCLK_TABLE_START + ZDSECMGR_TC_DEVICE_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_3:
   \   00002D   EA           MOV     A,R2
   \   00002E   24FF         ADD     A,#-0x1
   \   000030   F8           MOV     R0,A
   \   000031   EB           MOV     A,R3
   \   000032   34FE         ADDC    A,#-0x2
   \   000034   F9           MOV     R1,A
   \   000035   C3           CLR     C
   \   000036   E8           MOV     A,R0
   \   000037   9402         SUBB    A,#0x2
   \   000039   E9           MOV     A,R1
   \   00003A   9400         SUBB    A,#0x0
   \   00003C   5018         JNC     ??ZDSecMgrReadKeyFromNv_5
   3024            {
   3025              // Read entry keyNvId of the TC link key table from NV. keyNvId should be
   3026              // ZCD_NV_TCLK_TABLE_START + <offset_in_table>
   3027              return (osal_nv_read(keyNvId,
   3028                                   osal_offsetof(APSME_TCLinkKey_t, key),
   3029                                   SEC_KEY_LEN,
   3030                                   keyinfo));
   \   00003E                ; Setup parameters for call to function osal_nv_read
   \   00003E   8C..         MOV     ?V0 + 0,R4
   \   000040   8D..         MOV     ?V0 + 1,R5
   \   000042   78..         MOV     R0,#?V0 + 0
   \   000044   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000047   75..10       MOV     ?V0 + 0,#0x10
   \   00004A   75..00       MOV     ?V0 + 1,#0x0
   \   00004D   78..         MOV     R0,#?V0 + 0
   \   00004F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000052   7C08         MOV     R4,#0x8
   \   000054   8020         SJMP    ??ZDSecMgrReadKeyFromNv_4
   3031            }
   3032            else if ((keyNvId >= ZCD_NV_APS_LINK_KEY_DATA_START) &&
   3033                     (keyNvId < (ZCD_NV_APS_LINK_KEY_DATA_START + ZDSECMGR_ENTRY_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_5:
   \   000056   19           DEC     R1
   \   000057   C3           CLR     C
   \   000058   E8           MOV     A,R0
   \   000059   9403         SUBB    A,#0x3
   \   00005B   E9           MOV     A,R1
   \   00005C   9400         SUBB    A,#0x0
   \   00005E   501A         JNC     ??ZDSecMgrReadKeyFromNv_6
   3034            {
   3035              // Read entry keyNvId of the APS link key table from NV. keyNvId should be
   3036              // ZCD_NV_APS_LINK_KEY_DATA_START + <offset_in_table>
   3037              return (osal_nv_read(keyNvId,
   3038                                   osal_offsetof(APSME_LinkKeyData_t, key),
   3039                                   SEC_KEY_LEN,
   3040                                   keyinfo));
   \   000060                ; Setup parameters for call to function osal_nv_read
   \   000060   8C..         MOV     ?V0 + 0,R4
   \   000062   8D..         MOV     ?V0 + 1,R5
   \   000064   78..         MOV     R0,#?V0 + 0
   \   000066   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000069   75..10       MOV     ?V0 + 0,#0x10
   \   00006C   75..00       MOV     ?V0 + 1,#0x0
   \   00006F   78..         MOV     R0,#?V0 + 0
   \   000071   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000074   7C00         MOV     R4,#0x0
   \                     ??ZDSecMgrReadKeyFromNv_4:
   \   000076   7D00         MOV     R5,#0x0
   \   000078   8024         SJMP    ??ZDSecMgrReadKeyFromNv_7
   3041            }
   3042            else if (keyNvId == ZCD_NV_PRECFGKEY)
   \                     ??ZDSecMgrReadKeyFromNv_6:
   \   00007A   7462         MOV     A,#0x62
   \   00007C   6A           XRL     A,R2
   \   00007D   7001         JNZ     ??ZDSecMgrReadKeyFromNv_8
   \   00007F   EB           MOV     A,R3
   \                     ??ZDSecMgrReadKeyFromNv_8:
   \   000080   7026         JNZ     ??ZDSecMgrReadKeyFromNv_9
   3043            {
   3044              // Read entry keyNvId of the Preconfig key from NV.
   3045              return (osal_nv_read(keyNvId,
   3046                                   0,
   3047                                   SEC_KEY_LEN,
   3048                                   keyinfo));
   \   000082                ; Setup parameters for call to function osal_nv_read
   \   000082   8C..         MOV     ?V0 + 0,R4
   \   000084   8D..         MOV     ?V0 + 1,R5
   \   000086   78..         MOV     R0,#?V0 + 0
   \   000088   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008B   75..10       MOV     ?V0 + 0,#0x10
   \   00008E   75..00       MOV     ?V0 + 1,#0x0
   \   000091   78..         MOV     R0,#?V0 + 0
   \   000093   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000096   7C00         MOV     R4,#0x0
   \   000098   7D00         MOV     R5,#0x0
   \   00009A   7A62         MOV     R2,#0x62
   \   00009C   7B00         MOV     R3,#0x0
   \                     ??ZDSecMgrReadKeyFromNv_7:
   \   00009E   12....       LCALL   ??osal_nv_read?relay
   \   0000A1   7404         MOV     A,#0x4
   \   0000A3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A6   8002         SJMP    ??ZDSecMgrReadKeyFromNv_10
   3049            }
   3050          
   3051            return NV_OPER_FAILED;
   \                     ??ZDSecMgrReadKeyFromNv_9:
   \   0000A8   790A         MOV     R1,#0xa
   \                     ??ZDSecMgrReadKeyFromNv_10:
   \   0000AA   02....       LJMP    ??Subroutine73_0 & 0xFFFF
   3052          }
   3053          
   3054          /******************************************************************************
   3055           * @fn          ZDSecMgrApsLinkKeyInit
   3056           *
   3057           * @brief       Initialize the NV table for Application link keys
   3058           *
   3059           * @param       none
   3060           *
   3061           * @return      none
   3062           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3063          void ZDSecMgrApsLinkKeyInit(void)
   \                     ZDSecMgrApsLinkKeyInit:
   3064          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 24
   \   000005   74E8         MOV     A,#-0x18
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3065            APSME_LinkKeyData_t pApsLinkKey;
   3066            uint8 i;
   3067            uint8 status;
   3068          
   3069            // Initialize all NV items for APS link key, if not exist already.
   3070            osal_memset( &pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C18         MOV     R4,#0x18
   \   00000C   7D00         MOV     R5,#0x0
   \   00000E   7900         MOV     R1,#0x0
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   AA82         MOV     R2,DPL
   \   000018   AB83         MOV     R3,DPH
   \   00001A   12....       LCALL   ??osal_memset?relay
   3071          
   3072            for( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   00001D   7E00         MOV     R6,#0x0
   3073            {
   3074              status = osal_nv_item_init( (ZCD_NV_APS_LINK_KEY_DATA_START + i),
   3075                                         sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   \                     ??ZDSecMgrApsLinkKeyInit_0:
   \   00001F                ; Setup parameters for call to function osal_nv_item_init
   \   00001F   85..82       MOV     DPL,?XSP + 0
   \   000022   85..83       MOV     DPH,?XSP + 1
   \   000025   8582..       MOV     ?V0 + 0,DPL
   \   000028   8583..       MOV     ?V0 + 1,DPH
   \   00002B   78..         MOV     R0,#?V0 + 0
   \   00002D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000030   7C18         MOV     R4,#0x18
   \   000032   7D00         MOV     R5,#0x0
   \   000034   8E..         MOV     ?V0 + 0,R6
   \   000036   E5..         MOV     A,?V0 + 0
   \   000038   2401         ADD     A,#0x1
   \   00003A   FA           MOV     R2,A
   \   00003B   E4           CLR     A
   \   00003C   3402         ADDC    A,#0x2
   \   00003E   FB           MOV     R3,A
   \   00003F   12....       LCALL   ??osal_nv_item_init?relay
   \   000042   7402         MOV     A,#0x2
   \   000044   12....       LCALL   ?DEALLOC_XSTACK8
   3076          
   3077          #if defined ( NV_RESTORE )
   3078              (void)status;   // to eliminate compiler warning
   3079          #else
   3080              // reset the values of NV items if NV_RESTORE is not enabled
   3081              if (status == SUCCESS)
   3082              {
   3083                osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0,
   3084                              sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   3085          
   3086              }
   3087          #endif // defined (NV_RESTORE)
   3088            }
   \   000047   0E           INC     R6
   \   000048   EE           MOV     A,R6
   \   000049   C3           CLR     C
   \   00004A   9403         SUBB    A,#0x3
   \   00004C   40D1         JC      ??ZDSecMgrApsLinkKeyInit_0
   3089          }
   \   00004E   7418         MOV     A,#0x18
   \   000050   02....       LJMP    ??Subroutine72_0 & 0xFFFF
   3090          
   3091          /******************************************************************************
   3092           * @fn          ZDSecMgrInitNVKeyTables
   3093           *
   3094           * @brief       Initialize the NV table for All keys: NWK, Master, TCLK and APS
   3095           *
   3096           * @param       setDefault - TRUE to set default values
   3097           *
   3098           * @return      none
   3099           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3100          void ZDSecMgrInitNVKeyTables(uint8 setDefault)
   \                     ZDSecMgrInitNVKeyTables:
   3101          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   3102            ZDSecMgrNwkKeyInit(setDefault);
   \   000007                ; Setup parameters for call to function ZDSecMgrNwkKeyInit
   \   000007   12....       LCALL   ??ZDSecMgrNwkKeyInit?relay
   3103            ZDSecMgrApsLinkKeyInit();
   \   00000A                ; Setup parameters for call to function ZDSecMgrApsLinkKeyInit
   \   00000A   12....       LCALL   ??ZDSecMgrApsLinkKeyInit?relay
   3104            APSME_TCLinkKeyInit(setDefault);
   \   00000D                ; Setup parameters for call to function APSME_TCLinkKeyInit
   \   00000D   EE           MOV     A,R6
   \   00000E   F9           MOV     R1,A
   \   00000F   12....       LCALL   ??APSME_TCLinkKeyInit?relay
   3105          }
   \   000012   02....       LJMP    ??Subroutine68_0 & 0xFFFF
   3106          
   3107          /******************************************************************************
   3108           * @fn          ZDSecMgrSaveApsLinkKey
   3109           *
   3110           * @brief       Save APS Link Key to NV. It will loop through all the keys
   3111           *              to see which one to save.
   3112           *
   3113           * @param       none
   3114           *
   3115           * @return      none
   3116           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   F582         MOV     DPL,A
   \   000002   E5..         MOV     A,?V0 + 7
   \   000004                REQUIRE ??Subroutine71_0
   \   000004                ; // Fall through to label ??Subroutine71_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3117          void ZDSecMgrSaveApsLinkKey(void)
   \                     ZDSecMgrSaveApsLinkKey:
   3118          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 0
   3119            APSME_LinkKeyData_t *pKeyData = NULL;
   3120            int i;
   3121          
   3122            pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000005                ; Setup parameters for call to function osal_mem_alloc
   \   000005   7A18         MOV     R2,#0x18
   \   000007   7B00         MOV     R3,#0x0
   \   000009   12....       LCALL   ??osal_mem_alloc?relay
   \   00000C   8A..         MOV     ?V0 + 6,R2
   \   00000E   8B..         MOV     ?V0 + 7,R3
   3123          
   3124            if (pKeyData != NULL)
   \   000010   EA           MOV     A,R2
   \   000011   45..         ORL     A,?V0 + 7
   \   000013   7003         JNZ     $+5
   \   000015   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_0 & 0xFFFF
   3125            {
   3126              // checks all pending flags to know which one to save
   3127              for (i = 0; i < ZDSECMGR_ENTRY_MAX; i++)
   \   000018   7E00         MOV     R6,#0x0
   \   00001A   7F00         MOV     R7,#0x0
   3128              {
   3129                if (ApsLinkKeyFrmCntr[i].pendingFlag == TRUE)
   \                     ??ZDSecMgrSaveApsLinkKey_1:
   \   00001C   EE           MOV     A,R6
   \   00001D   F8           MOV     R0,A
   \   00001E   EF           MOV     A,R7
   \   00001F   F9           MOV     R1,A
   \   000020   E8           MOV     A,R0
   \   000021   75F009       MOV     B,#0x9
   \   000024   A4           MUL     AB
   \   000025   F8           MOV     R0,A
   \   000026   AAF0         MOV     R2,B
   \   000028   75F009       MOV     B,#0x9
   \   00002B   E9           MOV     A,R1
   \   00002C   A4           MUL     AB
   \   00002D   2A           ADD     A,R2
   \   00002E   F9           MOV     R1,A
   \   00002F   74..         MOV     A,#ApsLinkKeyFrmCntr & 0xff
   \   000031   28           ADD     A,R0
   \   000032   F5..         MOV     ?V0 + 0,A
   \   000034   74..         MOV     A,#(ApsLinkKeyFrmCntr >> 8) & 0xff
   \   000036   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000039   707F         JNZ     ??ZDSecMgrSaveApsLinkKey_2
   \   00003B   EE           MOV     A,R6
   \   00003C   2401         ADD     A,#0x1
   \   00003E   F5..         MOV     ?V0 + 2,A
   \   000040   EF           MOV     A,R7
   \   000041   3402         ADDC    A,#0x2
   \   000043   F5..         MOV     ?V0 + 3,A
   \   000045                ; Setup parameters for call to function osal_nv_read
   \   000045   78..         MOV     R0,#?V0 + 6
   \   000047   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004A   75..18       MOV     ?V0 + 8,#0x18
   \   00004D   75..00       MOV     ?V0 + 9,#0x0
   \   000050   78..         MOV     R0,#?V0 + 8
   \   000052   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000055   7C00         MOV     R4,#0x0
   \   000057   7D00         MOV     R5,#0x0
   \   000059   AA..         MOV     R2,?V0 + 2
   \   00005B   AB..         MOV     R3,?V0 + 3
   3130                {
   3131                  // retrieve key from NV
   3132                  if (osal_nv_read(ZCD_NV_APS_LINK_KEY_DATA_START + i, 0,
   3133                                   sizeof(APSME_LinkKeyData_t), pKeyData) == SUCCESS)
   \   00005D   12....       LCALL   ??osal_nv_read?relay
   \   000060   7404         MOV     A,#0x4
   \   000062   12....       LCALL   ?DEALLOC_XSTACK8
   \   000065   E9           MOV     A,R1
   \   000066   7052         JNZ     ??ZDSecMgrSaveApsLinkKey_2
   3134                  {
   3135                    pKeyData->txFrmCntr = ApsLinkKeyFrmCntr[i].txFrmCntr;
   \   000068   85..82       MOV     DPL,?V0 + 0
   \   00006B   85..83       MOV     DPH,?V0 + 1
   \   00006E   12....       LCALL   ?XLOAD_R2345
   \   000071   E5..         MOV     A,?V0 + 6
   \   000073   2410         ADD     A,#0x10
   \   000075   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_189:
   \   000078   12....       LCALL   ?XSTORE_R2345
   3136                    pKeyData->rxFrmCntr = ApsLinkKeyFrmCntr[i].rxFrmCntr;
   \   00007B   85..82       MOV     DPL,?V0 + 0
   \   00007E   85..83       MOV     DPH,?V0 + 1
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   A3           INC     DPTR
   \   000084   A3           INC     DPTR
   \   000085   12....       LCALL   ?XLOAD_R2345
   \   000088   E5..         MOV     A,?V0 + 6
   \   00008A   2414         ADD     A,#0x14
   \   00008C   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_190:
   \   00008F   12....       LCALL   ?XSTORE_R2345
   3137          
   3138                    // Write the APS link key back to the NV
   3139                    osal_nv_write(ZCD_NV_APS_LINK_KEY_DATA_START + i, 0,
   3140                                  sizeof(APSME_LinkKeyData_t), pKeyData);
   \   000092                ; Setup parameters for call to function osal_nv_write
   \   000092   78..         MOV     R0,#?V0 + 6
   \   000094   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000097   75..18       MOV     ?V0 + 0,#0x18
   \   00009A   75..00       MOV     ?V0 + 1,#0x0
   \   00009D   78..         MOV     R0,#?V0 + 0
   \   00009F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A2   7C00         MOV     R4,#0x0
   \   0000A4   7D00         MOV     R5,#0x0
   \   0000A6   AA..         MOV     R2,?V0 + 2
   \   0000A8   AB..         MOV     R3,?V0 + 3
   \   0000AA   12....       LCALL   ??osal_nv_write?relay
   \   0000AD   7404         MOV     A,#0x4
   \   0000AF   12....       LCALL   ?DEALLOC_XSTACK8
   3141          
   3142                    // clear the pending write flag
   3143                    ApsLinkKeyFrmCntr[i].pendingFlag = FALSE;
   \   0000B2   85..82       MOV     DPL,?V0 + 4
   \   0000B5   85..83       MOV     DPH,?V0 + 5
   \   0000B8   E4           CLR     A
   \   0000B9   F0           MOVX    @DPTR,A
   3144                  }
   3145                }
   3146              }
   \                     ??ZDSecMgrSaveApsLinkKey_2:
   \   0000BA   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   0000BD   A2D2         MOV     C,0xD0 /* PSW */.2
   \   0000BF   65D0         XRL     A,PSW
   \   0000C1   33           RLC     A
   \   0000C2   5003         JNC     $+5
   \   0000C4   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_1 & 0xFFFF
   3147          
   3148              // clear copy of key in RAM
   3149              osal_memset( pKeyData, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   0000C7                ; Setup parameters for call to function osal_memset
   \   0000C7   7C18         MOV     R4,#0x18
   \   0000C9   7D00         MOV     R5,#0x0
   \   0000CB   7900         MOV     R1,#0x0
   \   0000CD   AA..         MOV     R2,?V0 + 6
   \   0000CF   AB..         MOV     R3,?V0 + 7
   \   0000D1   12....       LCALL   ??osal_memset?relay
   3150          
   3151              osal_mem_free(pKeyData);
   \   0000D4                ; Setup parameters for call to function osal_mem_free
   \   0000D4   AA..         MOV     R2,?V0 + 6
   \   0000D6   AB..         MOV     R3,?V0 + 7
   \   0000D8   12....       LCALL   ??osal_mem_free?relay
   3152            }
   3153          }
   \                     ??ZDSecMgrSaveApsLinkKey_0:
   \   0000DB   80..         SJMP    ??Subroutine74_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   39           ADDC    A,R1
   \   000001   F5..         MOV     ?V0 + 1,A
   \   000003   E5..         MOV     A,?V0 + 0
   \   000005   2408         ADD     A,#0x8
   \   000007   F5..         MOV     ?V0 + 4,A
   \   000009   E5..         MOV     A,?V0 + 1
   \   00000B   3400         ADDC    A,#0x0
   \   00000D   F5..         MOV     ?V0 + 5,A
   \   00000F   85..82       MOV     DPL,?V0 + 4
   \   000012   F583         MOV     DPH,A
   \   000014   E0           MOVX    A,@DPTR
   \   000015   6401         XRL     A,#0x1
   \   000017   22           RET
   3154          
   3155          /******************************************************************************
   3156           * @fn          ZDSecMgrSaveTCLinkKey
   3157           *
   3158           * @brief       Save TC Link Key to NV. It will loop through all the keys
   3159           *              to see which one to save.
   3160           *
   3161           * @param       none
   3162           *
   3163           * @return      none
   3164           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3165          void ZDSecMgrSaveTCLinkKey(void)
   \                     ZDSecMgrSaveTCLinkKey:
   3166          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 0
   3167            APSME_TCLinkKey_t *pKeyData = NULL;
   3168            uint16 i;
   3169          
   3170            pKeyData = (APSME_TCLinkKey_t *)osal_mem_alloc(sizeof(APSME_TCLinkKey_t));
   \   000005                ; Setup parameters for call to function osal_mem_alloc
   \   000005   7A20         MOV     R2,#0x20
   \   000007   7B00         MOV     R3,#0x0
   \   000009   12....       LCALL   ??osal_mem_alloc?relay
   \   00000C   8A..         MOV     ?V0 + 6,R2
   \   00000E   8B..         MOV     ?V0 + 7,R3
   3171          
   3172            if (pKeyData != NULL)
   \   000010   EA           MOV     A,R2
   \   000011   45..         ORL     A,?V0 + 7
   \   000013   7003         JNZ     $+5
   \   000015   02....       LJMP    ??ZDSecMgrSaveTCLinkKey_0 & 0xFFFF
   3173            {
   3174              for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \   000018   7E00         MOV     R6,#0x0
   \   00001A   7F00         MOV     R7,#0x0
   3175              {
   3176                if (TCLinkKeyFrmCntr[i].pendingFlag == TRUE)
   \                     ??ZDSecMgrSaveTCLinkKey_1:
   \   00001C   EE           MOV     A,R6
   \   00001D   F8           MOV     R0,A
   \   00001E   EF           MOV     A,R7
   \   00001F   F9           MOV     R1,A
   \   000020   E8           MOV     A,R0
   \   000021   75F009       MOV     B,#0x9
   \   000024   A4           MUL     AB
   \   000025   F8           MOV     R0,A
   \   000026   AAF0         MOV     R2,B
   \   000028   75F009       MOV     B,#0x9
   \   00002B   E9           MOV     A,R1
   \   00002C   A4           MUL     AB
   \   00002D   2A           ADD     A,R2
   \   00002E   F9           MOV     R1,A
   \   00002F   74..         MOV     A,#TCLinkKeyFrmCntr & 0xff
   \   000031   28           ADD     A,R0
   \   000032   F5..         MOV     ?V0 + 0,A
   \   000034   74..         MOV     A,#(TCLinkKeyFrmCntr >> 8) & 0xff
   \   000036   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000039   707F         JNZ     ??ZDSecMgrSaveTCLinkKey_2
   3177                {
   3178                  if (osal_nv_read(ZCD_NV_TCLK_TABLE_START + i, 0,
   3179                                   sizeof(APSME_TCLinkKey_t), pKeyData) == SUCCESS)
   \   00003B   EE           MOV     A,R6
   \   00003C   2401         ADD     A,#0x1
   \   00003E   F5..         MOV     ?V0 + 2,A
   \   000040   EF           MOV     A,R7
   \   000041   3401         ADDC    A,#0x1
   \   000043   F5..         MOV     ?V0 + 3,A
   \   000045                ; Setup parameters for call to function osal_nv_read
   \   000045   78..         MOV     R0,#?V0 + 6
   \   000047   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004A   75..20       MOV     ?V0 + 8,#0x20
   \   00004D   75..00       MOV     ?V0 + 9,#0x0
   \   000050   78..         MOV     R0,#?V0 + 8
   \   000052   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000055   7C00         MOV     R4,#0x0
   \   000057   7D00         MOV     R5,#0x0
   \   000059   AA..         MOV     R2,?V0 + 2
   \   00005B   AB..         MOV     R3,?V0 + 3
   \   00005D   12....       LCALL   ??osal_nv_read?relay
   \   000060   7404         MOV     A,#0x4
   \   000062   12....       LCALL   ?DEALLOC_XSTACK8
   \   000065   E9           MOV     A,R1
   \   000066   7052         JNZ     ??ZDSecMgrSaveTCLinkKey_2
   3180                  {
   3181                    pKeyData->txFrmCntr = TCLinkKeyFrmCntr[i].txFrmCntr;
   \   000068   85..82       MOV     DPL,?V0 + 0
   \   00006B   85..83       MOV     DPH,?V0 + 1
   \   00006E   12....       LCALL   ?XLOAD_R2345
   \   000071   E5..         MOV     A,?V0 + 6
   \   000073   2418         ADD     A,#0x18
   \   000075   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_191:
   \   000078   12....       LCALL   ?XSTORE_R2345
   3182                    pKeyData->rxFrmCntr = TCLinkKeyFrmCntr[i].rxFrmCntr;
   \   00007B   85..82       MOV     DPL,?V0 + 0
   \   00007E   85..83       MOV     DPH,?V0 + 1
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   A3           INC     DPTR
   \   000084   A3           INC     DPTR
   \   000085   12....       LCALL   ?XLOAD_R2345
   \   000088   E5..         MOV     A,?V0 + 6
   \   00008A   241C         ADD     A,#0x1c
   \   00008C   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_192:
   \   00008F   12....       LCALL   ?XSTORE_R2345
   3183          
   3184                    // Write the TC link key back to the NV
   3185                    osal_nv_write(ZCD_NV_TCLK_TABLE_START + i, 0,
   3186                                  sizeof(APSME_TCLinkKey_t), pKeyData);
   \   000092                ; Setup parameters for call to function osal_nv_write
   \   000092   78..         MOV     R0,#?V0 + 6
   \   000094   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000097   75..20       MOV     ?V0 + 0,#0x20
   \   00009A   75..00       MOV     ?V0 + 1,#0x0
   \   00009D   78..         MOV     R0,#?V0 + 0
   \   00009F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A2   7C00         MOV     R4,#0x0
   \   0000A4   7D00         MOV     R5,#0x0
   \   0000A6   AA..         MOV     R2,?V0 + 2
   \   0000A8   AB..         MOV     R3,?V0 + 3
   \   0000AA   12....       LCALL   ??osal_nv_write?relay
   \   0000AD   7404         MOV     A,#0x4
   \   0000AF   12....       LCALL   ?DEALLOC_XSTACK8
   3187          
   3188                    // clear the pending write flag
   3189                    TCLinkKeyFrmCntr[i].pendingFlag = FALSE;
   \   0000B2   85..82       MOV     DPL,?V0 + 4
   \   0000B5   85..83       MOV     DPH,?V0 + 5
   \   0000B8   E4           CLR     A
   \   0000B9   F0           MOVX    @DPTR,A
   3190                  }
   3191                }
   3192              }
   \                     ??ZDSecMgrSaveTCLinkKey_2:
   \   0000BA   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   0000BD   9402         SUBB    A,#0x2
   \   0000BF   EF           MOV     A,R7
   \   0000C0   9400         SUBB    A,#0x0
   \   0000C2   5003         JNC     $+5
   \   0000C4   02....       LJMP    ??ZDSecMgrSaveTCLinkKey_1 & 0xFFFF
   3193                // clear copy of key in RAM
   3194              osal_memset( pKeyData, 0x00, sizeof(APSME_TCLinkKey_t) );
   \   0000C7                ; Setup parameters for call to function osal_memset
   \   0000C7   7C20         MOV     R4,#0x20
   \   0000C9   7D00         MOV     R5,#0x0
   \   0000CB   7900         MOV     R1,#0x0
   \   0000CD   AA..         MOV     R2,?V0 + 6
   \   0000CF   AB..         MOV     R3,?V0 + 7
   \   0000D1   12....       LCALL   ??osal_memset?relay
   3195          
   3196              osal_mem_free(pKeyData);
   \   0000D4                ; Setup parameters for call to function osal_mem_free
   \   0000D4   AA..         MOV     R2,?V0 + 6
   \   0000D6   AB..         MOV     R3,?V0 + 7
   \   0000D8   12....       LCALL   ??osal_mem_free?relay
   3197            }
   3198          }
   \                     ??ZDSecMgrSaveTCLinkKey_0:
   \   0000DB   02....       LJMP    ??Subroutine74_0 & 0xFFFF
   3199          
   3200          /******************************************************************************
   3201           * @fn          ZDSecMgrUpdateTCAddress
   3202           *
   3203           * @brief       Update Trust Center address and save to NV.
   3204           *
   3205           * @param       extAddr - [in] extended address or NULL if no TC protected
   3206           *
   3207           * @return      none
   3208           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3209          void ZDSecMgrUpdateTCAddress( uint8 *extAddr )
   \                     ZDSecMgrUpdateTCAddress:
   3210          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3211            uint8 noTCAddress[Z_EXTADDR_LEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   AC82         MOV     R4,DPL
   \   000012   AD83         MOV     R5,DPH
   \   000014   7583..       MOV     DPH,#(`?<Constant {255, 255, 255, 255, 255, 255, 255,` >> 8) & 0xff
   \   000017   7582..       MOV     DPL,#`?<Constant {255, 255, 255, 255, 255, 255, 255,` & 0xff
   \   00001A   7408         MOV     A,#0x8
   \   00001C   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   3212            APSME_SetRequest( apsTrustCenterAddress, 0, ( extAddr != NULL) ? extAddr : noTCAddress );
   \   00001F   EA           MOV     A,R2
   \   000020   4B           ORL     A,R3
   \   000021   700A         JNZ     ??ZDSecMgrUpdateTCAddress_0
   \   000023   85..82       MOV     DPL,?XSP + 0
   \   000026   85..83       MOV     DPH,?XSP + 1
   \   000029   AA82         MOV     R2,DPL
   \   00002B   AB83         MOV     R3,DPH
   \                     ??ZDSecMgrUpdateTCAddress_0:
   \   00002D                ; Setup parameters for call to function APSME_SetRequest
   \   00002D   EA           MOV     A,R2
   \   00002E   FC           MOV     R4,A
   \   00002F   EB           MOV     A,R3
   \   000030   FD           MOV     R5,A
   \   000031   7A00         MOV     R2,#0x0
   \   000033   7B00         MOV     R3,#0x0
   \   000035   79AB         MOV     R1,#-0x55
   \   000037   12....       LCALL   ??APSME_SetRequest?relay
   3213          #if defined ( NV_RESTORE )
   3214            osal_nv_write( ZCD_NV_TRUSTCENTER_ADDR, 0, Z_EXTADDR_LEN, zgApsTrustCenterAddr );
   \   00003A                ; Setup parameters for call to function osal_nv_write
   \   00003A   75....       MOV     ?V0 + 0,#zgApsTrustCenterAddr & 0xff
   \   00003D   75....       MOV     ?V0 + 1,#(zgApsTrustCenterAddr >> 8) & 0xff
   \   000040   78..         MOV     R0,#?V0 + 0
   \   000042   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000045   75..08       MOV     ?V0 + 0,#0x8
   \   000048   75..00       MOV     ?V0 + 1,#0x0
   \   00004B   78..         MOV     R0,#?V0 + 0
   \   00004D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000050   7C00         MOV     R4,#0x0
   \   000052   7D00         MOV     R5,#0x0
   \   000054   7A71         MOV     R2,#0x71
   \   000056   7B00         MOV     R3,#0x0
   \   000058   12....       LCALL   ??osal_nv_write?relay
   \   00005B   7404         MOV     A,#0x4
   \   00005D   12....       LCALL   ?DEALLOC_XSTACK8
   3215          #endif
   3216          }
   \   000060   7408         MOV     A,#0x8
   \   000062   02....       LJMP    ??Subroutine72_0 & 0xFFFF
   3217          
   3218          #if defined ( ZBA_FALLBACK_NWKKEY )
   3219          /******************************************************************************
   3220           * @fn          ZDSecMgrFallbackNwkKey
   3221           *
   3222           * @brief       Use the ZBA fallback network key.
   3223           *
   3224           * @param       none
   3225           *
   3226           * @return      none
   3227           */
   3228          void ZDSecMgrFallbackNwkKey( void )
   3229          {
   3230            if ( !_NIB.nwkKeyLoaded )
   3231            {
   3232              uint8 fallbackKey[SEC_KEY_LEN];
   3233          
   3234              ZDSecMgrReadKeyFromNv( ZCD_NV_PRECFGKEY, fallbackKey );
   3235              SSP_UpdateNwkKey( fallbackKey, 0);
   3236              SSP_SwitchNwkKey( 0 );
   3237          
   3238              // clear local copy of key
   3239              osal_memset( fallbackKey, 0x00, SEC_KEY_LEN );
   3240          
   3241              // handle next step in authentication process
   3242              ZDSecMgrAuthNwkKey();
   3243            }
   3244          }
   3245          #endif // defined ( ZBA_FALLBACK_NWKKEY )
   3246          
   3247          #if defined ( NV_RESTORE )
   3248          /******************************************************************************
   3249           * @fn          ZDSecMgrClearNVKeyValues
   3250           *
   3251           * @brief       If NV_RESTORE is enabled and the status of the network needs
   3252           *              default values this fuction clears ZCD_NV_NWKKEY,
   3253           *              ZCD_NV_NWK_ACTIVE_KEY_INFO and ZCD_NV_NWK_ALTERN_KEY_INFO link
   3254           *
   3255           * @param       none
   3256           *
   3257           * @return      none
   3258           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3259          void ZDSecMgrClearNVKeyValues(void)
   \                     ZDSecMgrClearNVKeyValues:
   3260          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 38
   \   000005   74DA         MOV     A,#-0x26
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3261            nwkActiveKeyItems keyItems;
   3262            nwkKeyDesc nwkKey;
   3263          
   3264            osal_memset(&keyItems, 0x00, sizeof(nwkActiveKeyItems));
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C15         MOV     R4,#0x15
   \   00000C   7D00         MOV     R5,#0x0
   \   00000E   7900         MOV     R1,#0x0
   \   000010   7411         MOV     A,#0x11
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   AA82         MOV     R2,DPL
   \   000017   AB83         MOV     R3,DPH
   \   000019   12....       LCALL   ??osal_memset?relay
   3265          
   3266            osal_nv_write(ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems);
   \   00001C                ; Setup parameters for call to function osal_nv_write
   \   00001C   7411         MOV     A,#0x11
   \   00001E   12....       LCALL   ?XSTACK_DISP0_8
   \   000021   8582..       MOV     ?V0 + 0,DPL
   \   000024   8583..       MOV     ?V0 + 1,DPH
   \   000027   78..         MOV     R0,#?V0 + 0
   \   000029   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002C   75..15       MOV     ?V0 + 0,#0x15
   \   00002F   75..00       MOV     ?V0 + 1,#0x0
   \   000032   78..         MOV     R0,#?V0 + 0
   \   000034   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000037   7C00         MOV     R4,#0x0
   \   000039   7D00         MOV     R5,#0x0
   \   00003B   7A82         MOV     R2,#-0x7e
   \   00003D   7B00         MOV     R3,#0x0
   \   00003F   12....       LCALL   ??osal_nv_write?relay
   \   000042   7404         MOV     A,#0x4
   \   000044   12....       LCALL   ?DEALLOC_XSTACK8
   3267          
   3268            // Initialize NV items for NWK Active and Alternate keys.
   3269            osal_memset( &nwkKey, 0x00, sizeof(nwkKeyDesc) );
   \   000047                ; Setup parameters for call to function osal_memset
   \   000047   7C11         MOV     R4,#0x11
   \   000049   7D00         MOV     R5,#0x0
   \   00004B   7900         MOV     R1,#0x0
   \   00004D   85..82       MOV     DPL,?XSP + 0
   \   000050   85..83       MOV     DPH,?XSP + 1
   \   000053   AA82         MOV     R2,DPL
   \   000055   AB83         MOV     R3,DPH
   \   000057   12....       LCALL   ??osal_memset?relay
   3270          
   3271            osal_nv_write(ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKeyDesc), &nwkKey);
   \   00005A                ; Setup parameters for call to function osal_nv_write
   \   00005A   85..82       MOV     DPL,?XSP + 0
   \   00005D   85..83       MOV     DPH,?XSP + 1
   \   000060   8582..       MOV     ?V0 + 0,DPL
   \   000063   8583..       MOV     ?V0 + 1,DPH
   \   000066   78..         MOV     R0,#?V0 + 0
   \   000068   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006B   75..11       MOV     ?V0 + 0,#0x11
   \   00006E   75..00       MOV     ?V0 + 1,#0x0
   \   000071   78..         MOV     R0,#?V0 + 0
   \   000073   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000076   7C00         MOV     R4,#0x0
   \   000078   7D00         MOV     R5,#0x0
   \   00007A   7A3A         MOV     R2,#0x3a
   \   00007C   7B00         MOV     R3,#0x0
   \   00007E   12....       LCALL   ??osal_nv_write?relay
   \   000081   7404         MOV     A,#0x4
   \   000083   12....       LCALL   ?DEALLOC_XSTACK8
   3272          
   3273            osal_nv_write(ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKeyDesc), &nwkKey);
   \   000086                ; Setup parameters for call to function osal_nv_write
   \   000086   85..82       MOV     DPL,?XSP + 0
   \   000089   85..83       MOV     DPH,?XSP + 1
   \   00008C   8582..       MOV     ?V0 + 0,DPL
   \   00008F   8583..       MOV     ?V0 + 1,DPH
   \   000092   78..         MOV     R0,#?V0 + 0
   \   000094   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000097   75..11       MOV     ?V0 + 0,#0x11
   \   00009A   75..00       MOV     ?V0 + 1,#0x0
   \   00009D   78..         MOV     R0,#?V0 + 0
   \   00009F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A2   7C00         MOV     R4,#0x0
   \   0000A4   7D00         MOV     R5,#0x0
   \   0000A6   7A3B         MOV     R2,#0x3b
   \   0000A8   7B00         MOV     R3,#0x0
   \   0000AA   12....       LCALL   ??osal_nv_write?relay
   \   0000AD   7404         MOV     A,#0x4
   \   0000AF   12....       LCALL   ?DEALLOC_XSTACK8
   3274          }
   \   0000B2   02....       LJMP    ?Subroutine9 & 0xFFFF

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrAppKeyType>`:
   \   000000   03           DB 3

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddrStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrExtAddrStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrExtAddrLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddrClear?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrClear

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupAMI?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupAMI

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupExt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupExtGetIndex?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExtGetIndex

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupAMIGetIndex?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupAMIGetIndex

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryFree?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryFree

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryNew?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAppKeyGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAppKeyReq?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyReq

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSendNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceRemoveByExtAddr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemoveByExtAddr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateRM?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateRM

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoin?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoin

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoinDirect?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinDirect

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoinFwd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinFwd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceNew?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAssocDeviceAuth?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAssocDeviceAuth

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrPermitJoining?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoining

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrPermitJoiningTimeout?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoiningTimeout

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrNewDeviceEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNewDeviceEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTCExtAddrCheck?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCExtAddrCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTCDataLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCDataLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTransportKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTransportKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrUpdateDeviceInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRemoveDeviceInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRemoveDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRequestKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSwitchKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSwitchKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRequestAppKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestAppKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSetupPartner?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetupPartner

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_LinkKeySet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeySet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticationSet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticationCheck?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_LinkKeyNVIdGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeyNVIdGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_IsLinkKeyValid?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_IsLinkKeyValid

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_KeyFwdToChild?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_KeyFwdToChild

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddLinkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrInitNV?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInitNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrWriteNV?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrWriteNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRestoreFromNV?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRestoreFromNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSetDefaultNV?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetDefaultNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAPSRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAPSRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_TCLinkKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_TCLinkKeySync?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeySync

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_TCLinkKeyLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_IsDefaultTCLK?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_IsDefaultTCLK

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrNwkKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNwkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrReadKeyFromNv?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrReadKeyFromNv

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrApsLinkKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrApsLinkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrInitNVKeyTables?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInitNVKeyTables

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSaveApsLinkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSaveApsLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSaveTCLinkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSaveTCLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrUpdateTCAddress?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateTCAddress

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrClearNVKeyValues?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrClearNVKeyValues

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {255, 255, 255, 255, 255, 255, 255,`:
   \   000000   FF           DB 255
   \   000001   FF           DB 255
   \   000002   FF           DB 255
   \   000003   FF           DB 255
   \   000004   FF           DB 255
   \   000005   FF           DB 255
   \   000006   FF           DB 255
   \   000007   FF           DB 255

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3e9:
   \   000000   E9030000     DD 1001

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_b:
   \   000000   0B000000     DD 11

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_a:
   \   000000   0A000000     DD 10
   3275          #endif // defined ( NV_RESTORE )
   3276          
   3277          /******************************************************************************
   3278          ******************************************************************************/

   Maximum stack usage in bytes:

   ISTACK PSTACK XSTACK Function
   ------ ------ ------ --------
       2      0     65  APSME_IsDefaultTCLK
                          2 0  0 -> osal_isbufset
       0      0     37  APSME_IsLinkKeyValid
                          0 0 33 -> APSME_LinkKeyNVIdGet
                          0 0 33 -> osal_mem_alloc
                          0 0 33 -> osal_mem_free
                          0 0 36 -> osal_memcmp
                          0 0 33 -> osal_memset
                          0 0 37 -> osal_nv_read
       2      0      0  APSME_KeyFwdToChild
                          2 0  0 -> AssocGetWithExt
                          2 0  0 -> ZDSecMgrAssocDeviceAuth
       0      0     44  APSME_LinkKeyNVIdGet
                          0 0 11 -> ZDSecMgrEntryLookupExt
       0      0     57  APSME_LinkKeySet
                          0 0 21 -> ZDSecMgrEntryLookupExtGetIndex
                          0 0 19 -> osal_mem_alloc
                          0 0 19 -> osal_mem_free
                          0 0 22 -> osal_memcpy
                          0 0 19 -> osal_memset
                          0 0 23 -> osal_nv_read
                          0 0 23 -> osal_nv_write
       0      0     61  APSME_TCLinkKeyInit
                          0 0 51 -> osal_memcpy
                          0 0 48 -> osal_memset
                          0 0 50 -> osal_nv_item_init
                          0 0 52 -> osal_nv_read
                          0 0 52 -> osal_nv_write
       0      0     69  APSME_TCLinkKeyLoad
                          0 0 65 -> APSME_IsDefaultTCLK
                          0 0 65 -> APSME_IsDistributedSecurity
                          0 0 65 -> AddrMgrEntryLookupNwk
                          0 0 65 -> AddrMgrEntryRelease
                          0 0 65 -> AddrMgrExtAddrEqual
                          0 0 65 -> AddrMgrExtAddrValid
                          0 0 65 -> osal_memset
                          0 0 69 -> osal_nv_read
                          0 0 65 -> osal_set_event
       0      0     54  APSME_TCLinkKeySync
                          0 0 50 -> APSME_IsDefaultTCLK
                          0 0 50 -> APSME_LookupExtAddr
                          0 0 50 -> AddrMgrExtAddrEqual
                          0 0 50 -> AddrMgrExtAddrValid
                          0 0 50 -> osal_memset
                          0 0 54 -> osal_nv_read
                          0 0 50 -> sAddrExtCmp
       2      0     10  ZDSecMgrAPSRemove
                          2 0  8 -> ZDSecMgrDeviceRemove
       0      0     20  ZDSecMgrAddLinkKey
                          0 0 16 -> APSME_LinkKeySet
                          0 0 18 -> ZDSecMgrAddrStore
                          0 0 16 -> ZDSecMgrAuthenticationSet
                          0 0 16 -> ZDSecMgrEntryLookupAMI
                          0 0 16 -> ZDSecMgrEntryNew
                          0 0 16 -> ZDSecMgrWriteNV
       0      0     57  ZDSecMgrAddrClear
                          0 0 24 -> AddrMgrEntryRelease
                          0 0 24 -> ZDSecMgrExtAddrLookup
       0      0     58  ZDSecMgrAddrStore
                          0 0 22 -> AddrMgrEntryUpdate
                          0 0 22 -> AddrMgrExtAddrSet
       1      0     17  ZDSecMgrAppKeyGet
                          0 0  9 -> SSP_GetTrueRand
       1      0     49  ZDSecMgrAppKeyReq
                          0 0 49 -> APSME_LookupExtAddr
                          0 0 49 -> APSME_LookupNwkAddr
                          0 0 49 -> APSME_TransportKeyReq
                          0 0 49 -> SSP_GetTrueRand
                          0 0 49 -> osal_memset
       0      0     45  ZDSecMgrApsLinkKeyInit
                          0 0 34 -> osal_memset
                          0 0 36 -> osal_nv_item_init
       2      0     33  ZDSecMgrAssocDeviceAuth
       2      0     34  ZDSecMgrAuthNwkKey
                          2 0  0 -> osal_set_event
       0      0     21  ZDSecMgrAuthenticationCheck
                          0 0 21 -> APSME_GetRequest
                          0 0 21 -> AddrMgrExtAddrLookup
                          0 0 21 -> NLME_GetExtAddr
                          0 0 21 -> ZDSecMgrEntryLookupExt
                          0 0 21 -> ZDSecMgrExtAddrLookup
                          0 0 21 -> sAddrExtCmp
       1      0     27  ZDSecMgrAuthenticationSet
                          0 0 11 -> ZDSecMgrEntryLookupExt
       0      0     52  ZDSecMgrClearNVKeyValues
                          0 0 48 -> osal_memset
                          0 0 52 -> osal_nv_write
       2      0      0  ZDSecMgrConfig
                          2 0  0 -> APSME_SecurityCM_RD
                          2 0  0 -> SSP_Init
       0      0     26  ZDSecMgrDeviceJoin
                          0 0 15 -> ZDSecMgrAddrClear
                          0 0 17 -> ZDSecMgrAddrStore
                          0 0 15 -> ZDSecMgrDeviceRemove
                          0 0 15 -> ZDSecMgrDeviceValidate
                          0 0 15 -> ZDSecMgrSendNwkKey
       0      0     18  ZDSecMgrDeviceJoinDirect
                          0 0  9 -> AssocGetWithShort
                          0 0  9 -> ZDSecMgrAssocDeviceAuth
                          0 0  9 -> ZDSecMgrDeviceJoin
       2      0     17  ZDSecMgrDeviceJoinFwd
                          2 0  8 -> APSME_UpdateDeviceReq
                          2 0  8 -> AssocGetWithShort
                          2 0  8 -> ZDSecMgrAssocDeviceAuth
       0      0     42  ZDSecMgrDeviceNew
                          0 0  9 -> APSME_IsDistributedSecurity
                          0 0  9 -> ZDSecMgrDeviceJoinDirect
                          0 0  9 -> ZDSecMgrDeviceJoinFwd
       0      0     37  ZDSecMgrDeviceRemove
                          0 0 20 -> APSME_RemoveDeviceReq
                          0 0 20 -> AssocGetWithExt
                          0 0 20 -> NLME_GetShortAddr
                          0 0 20 -> NLME_LeaveReq
       0      0     11  ZDSecMgrDeviceRemoveByExtAddr
                          0 0 11 -> ZDSecMgrEntryFree
                          0 0 11 -> ZDSecMgrEntryLookupExt
       2      0     15  ZDSecMgrDeviceValidate
                          2 0  0 -> ZDSecMgrDeviceValidateRM
       2      0      0  ZDSecMgrDeviceValidateRM
       0      0     35  ZDSecMgrEntryFree
                          0 0 20 -> ZDSecMgrEntryLookupAMIGetIndex
                          0 0 20 -> osal_mem_alloc
                          0 0 20 -> osal_mem_free
                          0 0 20 -> osal_memset
                          0 0 24 -> osal_nv_read
                          0 0 24 -> osal_nv_write
       0      0     18  ZDSecMgrEntryInit
                          0 0  9 -> ZDSecMgrRestoreFromNV
                          0 0  9 -> osal_mem_alloc
       0      0     22  ZDSecMgrEntryLookup
                          0 0 22 -> AddrMgrEntryLookupNwk
       0      0     43  ZDSecMgrEntryLookupAMI
       0      0     29  ZDSecMgrEntryLookupAMIGetIndex
       0      0     32  ZDSecMgrEntryLookupExt
                          0 0 11 -> ZDSecMgrEntryLookupAMI
                          0 0 11 -> ZDSecMgrExtAddrLookup
       0      0     33  ZDSecMgrEntryLookupExtGetIndex
                          0 0 12 -> ZDSecMgrExtAddrLookup
       0      0     43  ZDSecMgrEntryNew
       0      0     56  ZDSecMgrExtAddrLookup
                          0 0 22 -> AddrMgrEntryLookupExt
                          0 0 22 -> AddrMgrExtAddrSet
       0      0     24  ZDSecMgrExtAddrStore
                          0 0 22 -> AddrMgrEntryUpdate
                          0 0 22 -> AddrMgrExtAddrSet
       0      0      9  ZDSecMgrInit
                          0 0  9 -> APSME_IsDistributedSecurity
                          0 0  9 -> APSME_SecurityCM_RD
                          0 0  9 -> SSP_Init
                          0 0  9 -> ZDSecMgrEntryInit
       0      0     16  ZDSecMgrInitNV
                          0 0 14 -> osal_nv_item_init
                          0 0 16 -> osal_nv_write
       0      0      9  ZDSecMgrInitNVKeyTables
                          0 0  9 -> APSME_TCLinkKeyInit
                          0 0  9 -> ZDSecMgrApsLinkKeyInit
                          0 0  9 -> ZDSecMgrNwkKeyInit
       1      0     33  ZDSecMgrNewDeviceEvent
                          0 0 33 -> AddrMgrEntryGet
                          0 0 33 -> AssocGetWithShort
                          0 0 33 -> AssocRemove
                          0 0 33 -> NLME_GetShortAddr
                          0 0 33 -> ZDSecMgrAddrClear
                          0 0 33 -> ZDSecMgrAssocDeviceAuth
                          0 0 33 -> ZDSecMgrDeviceNew
       0      0     61  ZDSecMgrNwkKeyInit
                          0 0 48 -> osal_memset
                          0 0 50 -> osal_nv_item_init
                          0 0 52 -> osal_nv_write
       2      0      0  ZDSecMgrPermitJoining
       2      0      0  ZDSecMgrPermitJoiningTimeout
       0      0     48  ZDSecMgrReadKeyFromNv
                          0 0 14 -> osal_nv_read
       0      0     17  ZDSecMgrRemoveDeviceInd
                          0 0 17 -> APSME_LookupNwkAddr
                          0 0 17 -> NLME_GetShortAddr
                          0 0 17 -> ZDSecMgrDeviceRemove
       2      0      4  ZDSecMgrRequestAppKey
                          2 0  4 -> APSME_RequestKeyReq
       2      0      0  ZDSecMgrRequestKeyInd
                          2 0  0 -> ZDSecMgrAppKeyReq
       0      0     33  ZDSecMgrRestoreFromNV
                          0 0 20 -> osal_mem_alloc
                          0 0 20 -> osal_mem_free
                          0 0 20 -> osal_memset
                          0 0 24 -> osal_nv_read
                          0 0 24 -> osal_nv_write
       0      0     22  ZDSecMgrSaveApsLinkKey
                          0 0 18 -> osal_mem_alloc
                          0 0 18 -> osal_mem_free
                          0 0 18 -> osal_memset
                          0 0 22 -> osal_nv_read
                          0 0 22 -> osal_nv_write
       0      0     22  ZDSecMgrSaveTCLinkKey
                          0 0 18 -> osal_mem_alloc
                          0 0 18 -> osal_mem_free
                          0 0 18 -> osal_memset
                          0 0 22 -> osal_nv_read
                          0 0 22 -> osal_nv_write
       1      0     65  ZDSecMgrSendNwkKey
                          0 0 46 -> APSME_TransportKeyReq
                          0 0 46 -> NLME_GetShortAddr
                          0 0 50 -> NLME_ReadNwkKeyInfo
                          0 0 46 -> osal_memset
       0      0     23  ZDSecMgrSetDefaultNV
                          0 0 19 -> osal_mem_alloc
                          0 0 19 -> osal_mem_free
                          0 0 19 -> osal_memset
                          0 0 23 -> osal_nv_write
       0      0     24  ZDSecMgrSetupPartner
                          0 0 24 -> AddrMgrEntryUpdate
                          0 0 24 -> AddrMgrExtAddrSet
                          0 0 24 -> AddrMgrExtAddrValid
                          0 0 24 -> ZDP_IEEEAddrReq
                          0 0 24 -> ZDP_NwkAddrReq
       2      0      0  ZDSecMgrSwitchKeyInd
                          2 0  0 -> SSP_SwitchNwkKey
                          2 0  0 -> ZDApp_NVUpdate
       0      0     61  ZDSecMgrTCDataLoad
                          0 0 25 -> APSME_IsDistributedSecurity
                          0 0 25 -> AddrMgrEntryLookupExt
                          0 0 27 -> ZDSecMgrAddrStore
                          0 0 25 -> sAddrExtCpy
       0      0     17  ZDSecMgrTCExtAddrCheck
                          0 0 17 -> APSME_GetRequest
                          0 0 17 -> sAddrExtCmp
       0      0     36  ZDSecMgrTransportKeyInd
                          0 0 34 -> APSME_LinkKeySet
                          0 0 34 -> SSP_SwitchNwkKey
                          0 0 34 -> SSP_UpdateNwkKey
                          0 0 34 -> ZDP_NwkAddrReq
                          0 0 36 -> ZDSecMgrAddrStore
                          0 0 34 -> ZDSecMgrAuthNwkKey
                          0 0 34 -> ZDSecMgrEntryLookupAMI
                          0 0 34 -> ZDSecMgrEntryNew
                          0 0 34 -> ZDSecMgrExtAddrLookup
                          0 0 34 -> ZDSecMgrReadKeyFromNv
                          0 0 34 -> ZDSecMgrTCDataLoad
                          0 0 34 -> ZDSecMgrUpdateTCAddress
                          0 0 34 -> ZDSecMgrWriteNV
                          0 0 34 -> osal_isbufset
                          0 0 34 -> osal_memset
       2      0      8  ZDSecMgrUpdateDeviceInd
                          2 0  8 -> ZDSecMgrDeviceJoin
       2      0     56  ZDSecMgrUpdateTCAddress
                          0 0 18 -> APSME_SetRequest
                          0 0 22 -> osal_nv_write
       0      0     52  ZDSecMgrWriteNV
                          0 0 18 -> osal_nv_write


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant {255, 255, 255, 255, 255, 255, 255,
       1  ?<Initializer for ZDSecMgrAppKeyType>
       6  ??APSME_IsDefaultTCLK?relay
       6  ??APSME_IsLinkKeyValid?relay
       6  ??APSME_KeyFwdToChild?relay
       6  ??APSME_LinkKeyNVIdGet?relay
       6  ??APSME_LinkKeySet?relay
       6  ??APSME_TCLinkKeyInit?relay
       6  ??APSME_TCLinkKeyLoad?relay
       6  ??APSME_TCLinkKeySync?relay
       5  ??Subroutine53_0
       8  ??Subroutine54_0
       9  ??Subroutine55_0
       8  ??Subroutine56_0
       6  ??Subroutine57_0
       2  ??Subroutine58_0
       6  ??Subroutine59_0
       3  ??Subroutine60_0
       7  ??Subroutine61_0
       6  ??Subroutine62_0
       6  ??Subroutine63_0
      12  ??Subroutine64_0
       2  ??Subroutine65_0
       9  ??Subroutine66_0
       3  ??Subroutine67_0
       5  ??Subroutine68_0
       5  ??Subroutine69_0
       4  ??Subroutine70_0
       5  ??Subroutine71_0
       3  ??Subroutine72_0
       5  ??Subroutine73_0
       5  ??Subroutine74_0
       6  ??ZDSecMgrAPSRemove?relay
       6  ??ZDSecMgrAddLinkKey?relay
       6  ??ZDSecMgrAddrClear?relay
       6  ??ZDSecMgrAddrStore?relay
       6  ??ZDSecMgrAppKeyGet?relay
       6  ??ZDSecMgrAppKeyReq?relay
       6  ??ZDSecMgrApsLinkKeyInit?relay
       6  ??ZDSecMgrAssocDeviceAuth?relay
       6  ??ZDSecMgrAuthNwkKey?relay
       6  ??ZDSecMgrAuthenticationCheck?relay
       6  ??ZDSecMgrAuthenticationSet?relay
       6  ??ZDSecMgrClearNVKeyValues?relay
       6  ??ZDSecMgrConfig?relay
       6  ??ZDSecMgrDeviceJoin?relay
       6  ??ZDSecMgrDeviceJoinDirect?relay
       6  ??ZDSecMgrDeviceJoinFwd?relay
       6  ??ZDSecMgrDeviceNew?relay
       6  ??ZDSecMgrDeviceRemove?relay
       6  ??ZDSecMgrDeviceRemoveByExtAddr?relay
       6  ??ZDSecMgrDeviceValidate?relay
       6  ??ZDSecMgrDeviceValidateRM?relay
       6  ??ZDSecMgrEntryFree?relay
       6  ??ZDSecMgrEntryInit?relay
       6  ??ZDSecMgrEntryLookup?relay
       6  ??ZDSecMgrEntryLookupAMI?relay
       6  ??ZDSecMgrEntryLookupAMIGetIndex?relay
       6  ??ZDSecMgrEntryLookupExt?relay
       6  ??ZDSecMgrEntryLookupExtGetIndex?relay
       6  ??ZDSecMgrEntryNew?relay
       6  ??ZDSecMgrExtAddrLookup?relay
       6  ??ZDSecMgrExtAddrStore?relay
       6  ??ZDSecMgrInit?relay
       6  ??ZDSecMgrInitNV?relay
       6  ??ZDSecMgrInitNVKeyTables?relay
       6  ??ZDSecMgrNewDeviceEvent?relay
       6  ??ZDSecMgrNwkKeyInit?relay
       6  ??ZDSecMgrPermitJoining?relay
       6  ??ZDSecMgrPermitJoiningTimeout?relay
       6  ??ZDSecMgrReadKeyFromNv?relay
       6  ??ZDSecMgrRemoveDeviceInd?relay
       6  ??ZDSecMgrRequestAppKey?relay
       6  ??ZDSecMgrRequestKeyInd?relay
       6  ??ZDSecMgrRestoreFromNV?relay
       6  ??ZDSecMgrSaveApsLinkKey?relay
       6  ??ZDSecMgrSaveTCLinkKey?relay
       6  ??ZDSecMgrSendNwkKey?relay
       6  ??ZDSecMgrSetDefaultNV?relay
       6  ??ZDSecMgrSetupPartner?relay
       6  ??ZDSecMgrSwitchKeyInd?relay
       6  ??ZDSecMgrTCDataLoad?relay
       6  ??ZDSecMgrTCExtAddrCheck?relay
       6  ??ZDSecMgrTransportKeyInd?relay
       6  ??ZDSecMgrUpdateDeviceInd?relay
       6  ??ZDSecMgrUpdateTCAddress?relay
       6  ??ZDSecMgrWriteNV?relay
       2  ?Subroutine0
       2  ?Subroutine1
       4  ?Subroutine10
       3  ?Subroutine11
       4  ?Subroutine12
       6  ?Subroutine13
      15  ?Subroutine14
      25  ?Subroutine15
      13  ?Subroutine16
      11  ?Subroutine17
       6  ?Subroutine18
      15  ?Subroutine19
       8  ?Subroutine2
       6  ?Subroutine20
       6  ?Subroutine21
       3  ?Subroutine22
       6  ?Subroutine23
      17  ?Subroutine24
       6  ?Subroutine25
       4  ?Subroutine26
       8  ?Subroutine27
      14  ?Subroutine28
       4  ?Subroutine29
       8  ?Subroutine3
       6  ?Subroutine30
       9  ?Subroutine31
      16  ?Subroutine32
       9  ?Subroutine33
      28  ?Subroutine34
       8  ?Subroutine35
      20  ?Subroutine36
       4  ?Subroutine37
       5  ?Subroutine38
      13  ?Subroutine39
       2  ?Subroutine4
      24  ?Subroutine40
      27  ?Subroutine41
       4  ?Subroutine42
       6  ?Subroutine43
       7  ?Subroutine44
      12  ?Subroutine45
       6  ?Subroutine46
      12  ?Subroutine47
       9  ?Subroutine48
      30  ?Subroutine49
       8  ?Subroutine5
       8  ?Subroutine50
      11  ?Subroutine51
       9  ?Subroutine52
       3  ?Subroutine6
       5  ?Subroutine7
       5  ?Subroutine8
       4  ?Subroutine9
      14  APSME_IsDefaultTCLK
     190  APSME_IsLinkKeyValid
      57  APSME_KeyFwdToChild
      60  APSME_LinkKeyNVIdGet
     290  APSME_LinkKeySet
     355  APSME_TCLinkKeyInit
     404  APSME_TCLinkKeyLoad
     366  APSME_TCLinkKeySync
      27  ApsLinkKeyFrmCntr
      18  TCLinkKeyFrmCntr
      32  TrustCenterLinkKey
      76  ZDSecMgrAPSRemove
     141  ZDSecMgrAddLinkKey
      72  ZDSecMgrAddrClear
      73  ZDSecMgrAddrStore
      53  ZDSecMgrAppKeyGet
     245  ZDSecMgrAppKeyReq
       1  ZDSecMgrAppKeyType
      83  ZDSecMgrApsLinkKeyInit
      23  ZDSecMgrAssocDeviceAuth
      26  ZDSecMgrAuthNwkKey
     138  ZDSecMgrAuthenticationCheck
      33  ZDSecMgrAuthenticationSet
     181  ZDSecMgrClearNVKeyValues
      12  ZDSecMgrConfig
     139  ZDSecMgrDeviceJoin
      35  ZDSecMgrDeviceJoinDirect
     188  ZDSecMgrDeviceJoinFwd
      34  ZDSecMgrDeviceNew
     249  ZDSecMgrDeviceRemove
      44  ZDSecMgrDeviceRemoveByExtAddr
      22  ZDSecMgrDeviceValidate
      17  ZDSecMgrDeviceValidateRM
       2  ZDSecMgrEntries
     375  ZDSecMgrEntryFree
      69  ZDSecMgrEntryInit
      95  ZDSecMgrEntryLookup
      62  ZDSecMgrEntryLookupAMI
      58  ZDSecMgrEntryLookupAMIGetIndex
      65  ZDSecMgrEntryLookupExt
     101  ZDSecMgrEntryLookupExtGetIndex
     118  ZDSecMgrEntryNew
      78  ZDSecMgrExtAddrLookup
      73  ZDSecMgrExtAddrStore
      34  ZDSecMgrInit
     106  ZDSecMgrInitNV
      21  ZDSecMgrInitNVKeyTables
     213  ZDSecMgrNewDeviceEvent
     267  ZDSecMgrNwkKeyInit
      38  ZDSecMgrPermitJoining
       1  ZDSecMgrPermitJoiningEnabled
       1  ZDSecMgrPermitJoiningTimed
      23  ZDSecMgrPermitJoiningTimeout
     173  ZDSecMgrReadKeyFromNv
      62  ZDSecMgrRemoveDeviceInd
      38  ZDSecMgrRequestAppKey
      30  ZDSecMgrRequestKeyInd
     466  ZDSecMgrRestoreFromNV
     221  ZDSecMgrSaveApsLinkKey
     222  ZDSecMgrSaveTCLinkKey
     277  ZDSecMgrSendNwkKey
     190  ZDSecMgrSetDefaultNV
     133  ZDSecMgrSetupPartner
      23  ZDSecMgrSwitchKeyInd
       1  ZDSecMgrTCAuthenticated
      98  ZDSecMgrTCDataLoad
       8  ZDSecMgrTCExtAddr
      50  ZDSecMgrTCExtAddrCheck
     383  ZDSecMgrTransportKeyInd
     112  ZDSecMgrUpdateDeviceInd
     101  ZDSecMgrUpdateTCAddress
     175  ZDSecMgrWriteNV
       4  __Constant_1
       4  __Constant_3e9
       4  __Constant_a
       4  __Constant_b

 
 8 800 bytes in segment BANKED_CODE
   378 bytes in segment BANK_RELAYS
     1 byte  in segment XDATA_I
     1 byte  in segment XDATA_ID
    24 bytes in segment XDATA_ROM_C
    90 bytes in segment XDATA_Z
 
 9 179 bytes of CODE  memory
     8 bytes of CONST memory (+ 16 bytes shared)
    91 bytes of XDATA memory

Errors: none
Warnings: none
