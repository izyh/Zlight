###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.20.2.41139 for 8051             27/May/2014  19:14:20 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  D:\Texas Instruments\Z-Stack Lighting              #
#                          1.0.2\Components\stack\zcl\zcl.c                   #
#    Command line       =  -f "D:\Texas Instruments\Z-Stack Lighting          #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\Tools\CC2530DB\f8wRouter.cfg" (-DCPU32MHZ        #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8       #
#                          -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f "D:\Texas         #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\Tools\CC2530DB\f8wConfig.cfg" (-DZIGBEEPRO       #
#                          -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR       #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100    #
#                          -DREJOIN_POLL_RATE=440) -f "D:\Texas               #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\Tools\CC2530DB\f8wZCL.cfg" "D:\Texas             #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Components\stack\zcl\zcl.c" -D               #
#                          FEATURE_GREEN_POWER -D SECURE=1 -D                 #
#                          TC_LINKKEY_JOIN -D ZDSECMGR_TC_DEVICE_MAX=2 -D     #
#                          NV_RESTORE -D HOLD_AUTO_START -D INTER_PAN -D      #
#                          LCD_SUPPORTED=DEBUG -D ZCL_BASIC -D ZCL_READ -D    #
#                          ZCL_WRITE -D ZCL_IDENTIFY -D ZCL_ON_OFF -D         #
#                          ZCL_SCENES -D ZCL_GROUPS -D                        #
#                          ZCL_LIGHT_LINK_ENHANCE -D ZCL_LEVEL_CTRL -D        #
#                          ZCL_COLOR_CTRL -D MAX_CHANNELS_24GHZ=0x02108800    #
#                          -D xPWM_ALT2 -D xTHERMAL_SHUTDOWN -D               #
#                          ZLL_1_0_HUB_COMPATIBILITY -D DALI_LIGHT -lC        #
#                          "D:\Texas Instruments\Z-Stack Lighting             #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\Zlight  #
#                          - Router\List\" -lA "D:\Texas Instruments\Z-Stack  #
#                          Lighting 1.0.2\Projects\zstack\ZLL\SampleApp\CC253 #
#                          x\Zlight - Router\List\" --diag_suppress           #
#                          Pe001,Pa010 -o "D:\Texas Instruments\Z-Stack       #
#                          Lighting 1.0.2\Projects\zstack\ZLL\SampleApp\CC253 #
#                          x\Zlight - Router\Obj\" -e --debug --core=plain    #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "D:\Texas                  #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\" -I    #
#                          "D:\Texas Instruments\Z-Stack Lighting             #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\Sour #
#                          ce\" -I "D:\Texas Instruments\Z-Stack Lighting     #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\S #
#                          ource\" -I "D:\Texas Instruments\Z-Stack Lighting  #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\HomeAutomation\Source\" -I "D:\Texas             #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\HomeAutomation\SampleLight\Source\" -I           #
#                          "D:\Texas Instruments\Z-Stack Lighting             #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\ZMain\TI2530DB\" -I "D:\Texas                    #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\hal\include\" -I "D:\Texas      #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\hal\target\CC2530PMP4712\" -I   #
#                          "D:\Texas Instruments\Z-Stack Lighting             #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mac\include\" -I "D:\Texas      #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mac\high_level\" -I "D:\Texas   #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mac\low_level\srf04\" -I        #
#                          "D:\Texas Instruments\Z-Stack Lighting             #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mac\low_level\srf04\single_chip #
#                          \" -I "D:\Texas Instruments\Z-Stack Lighting       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mt\" -I "D:\Texas               #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\osal\include\" -I "D:\Texas     #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\services\saddr\" -I "D:\Texas   #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\services\sdata\" -I "D:\Texas   #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\af\" -I "D:\Texas         #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\nwk\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\sapi\" -I "D:\Texas       #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\sec\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\sys\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\zcl\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\zdo\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\zmac\" -I "D:\Texas             #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\zmac\f8w\" -Ohz                 #
#                          --require_prototypes                               #
#    List file          =  D:\Texas Instruments\Z-Stack Lighting              #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\Zlight  #
#                          - Router\List\zcl.lst                              #
#    Object file        =  D:\Texas Instruments\Z-Stack Lighting              #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\Zlight  #
#                          - Router\Obj\zcl.r51                               #
#                                                                             #
#                                                                             #
###############################################################################

D:\Texas Instruments\Z-Stack Lighting 1.0.2\Components\stack\zcl\zcl.c
      1          /**************************************************************************************************
      2            Filename:       zcl.c
      3            Revised:        $Date: 2013-11-22 17:43:52 -0800 (Fri, 22 Nov 2013) $
      4            Revision:       $Revision: 36225 $
      5          
      6            Description:    This file contains the Zigbee Cluster Library Foundation functions.
      7          
      8          
      9            Copyright 2006-2013 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComDef.h"
     44          #include "AF.h"
     45          
     46          #include "zcl.h"
     47          #include "zcl_general.h"
     48          
     49          #if defined ( INTER_PAN )
     50            #include "stub_aps.h"
     51          #endif
     52          
     53          #include "onboard.h"
     54          
     55          /*********************************************************************
     56           * MACROS
     57           */
     58          /*** Frame Control ***/
     59          #define zcl_FCType( a )               ( (a) & ZCL_FRAME_CONTROL_TYPE )
     60          #define zcl_FCManuSpecific( a )       ( (a) & ZCL_FRAME_CONTROL_MANU_SPECIFIC )
     61          #define zcl_FCDirection( a )          ( (a) & ZCL_FRAME_CONTROL_DIRECTION )
     62          #define zcl_FCDisableDefaultRsp( a )  ( (a) & ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RSP )
     63          
     64          /*** Attribute Access Control ***/
     65          #define zcl_AccessCtrlRead( a )       ( (a) & ACCESS_CONTROL_READ )
     66          #define zcl_AccessCtrlWrite( a )      ( (a) & ACCESS_CONTROL_WRITE )
     67          #define zcl_AccessCtrlCmd( a )        ( (a) & ACCESS_CONTROL_CMD )
     68          #define zcl_AccessCtrlAuthRead( a )   ( (a) & ACCESS_CONTROL_AUTH_READ )
     69          #define zcl_AccessCtrlAuthWrite( a )  ( (a) & ACCESS_CONTROL_AUTH_WRITE )
     70          
     71          #define zclParseCmd( a, b )           zclCmdTable[(a)].pfnParseInProfile( (b) )
     72          #define zclProcessCmd( a, b )         zclCmdTable[(a)].pfnProcessInProfile( (b) )
     73          
     74          #define zcl_DefaultRspCmd( zclHdr )   ( zcl_ProfileCmd( (zclHdr).fc.type )     && \
     75                                                  (zclHdr).fc.manuSpecific == 0          && \
     76                                                  (zclHdr).commandID == ZCL_CMD_DEFAULT_RSP )
     77          
     78          // Commands that have corresponding responses
     79          #define CMD_HAS_RSP( cmd )            ( (cmd) == ZCL_CMD_READ                   || \
     80                                                  (cmd) == ZCL_CMD_WRITE                  || \
     81                                                  (cmd) == ZCL_CMD_WRITE_UNDIVIDED        || \
     82                                                  (cmd) == ZCL_CMD_CONFIG_REPORT          || \
     83                                                  (cmd) == ZCL_CMD_READ_REPORT_CFG        || \
     84                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS         || \
     85                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_RECEIVED || \
     86                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_GEN      || \
     87                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS_EXT     || \
     88                                                  (cmd) == ZCL_CMD_DEFAULT_RSP ) // exception
     89          
     90          /*********************************************************************
     91           * CONSTANTS
     92           */
     93          
     94          /*********************************************************************
     95           * TYPEDEFS
     96           */
     97          typedef struct zclLibPlugin
     98          {
     99            struct zclLibPlugin *next;
    100            uint16              startClusterID;    // starting cluster ID
    101            uint16              endClusterID;      // ending cluster ID
    102            zclInHdlr_t         pfnIncomingHdlr;    // function to handle incoming message
    103          } zclLibPlugin_t;
    104          
    105          // Command record list
    106          typedef struct zclCmdRecsList
    107          {
    108            struct zclCmdRecsList *pNext;
    109            uint8                 endpoint;
    110            uint8                 numCommands;
    111            CONST zclCommandRec_t *pCmdRecs;
    112          } zclCmdRecsList_t;
    113          
    114          // Attribute record list item
    115          typedef struct zclAttrRecsList
    116          {
    117            struct zclAttrRecsList *next;
    118            uint8                  endpoint;      // Used to link it into the endpoint descriptor
    119            zclReadWriteCB_t       pfnReadWriteCB;// Read or Write attribute value callback function
    120            zclAuthorizeCB_t       pfnAuthorizeCB;// Authorize Read or Write operation
    121            uint8                  numAttributes; // Number of the following records
    122            CONST zclAttrRec_t     *attrs;        // attribute records
    123          } zclAttrRecsList;
    124          
    125          // Cluster option list item
    126          typedef struct zclClusterOptionList
    127          {
    128            struct zclClusterOptionList *next;
    129            uint8                       endpoint;   // Used to link it into the endpoint descriptor
    130            uint8                       numOptions; // Number of the following records
    131            zclOptionRec_t              *options;   // option records
    132          } zclClusterOptionList;
    133          
    134          typedef void *(*zclParseInProfileCmd_t)( zclParseCmd_t *pCmd );
    135          typedef uint8 (*zclProcessInProfileCmd_t)( zclIncoming_t *pInMsg );
    136          
    137          typedef struct
    138          {
    139            zclParseInProfileCmd_t   pfnParseInProfile;
    140            zclProcessInProfileCmd_t pfnProcessInProfile;
    141          } zclCmdItems_t;
    142          
    143          
    144          /*********************************************************************
    145           * GLOBAL VARIABLES
    146           */
    147          
    148          #if !defined ( ZCL_STANDALONE )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    149            uint8 zcl_TaskID;
   \                     zcl_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    150          
    151            // The task Id of the Application where the unprocessed Foundation
    152            // Command/Response messages will be sent to.

   \                                 In  segment XDATA_I, align 1, keep-with-next
    153            uint8 zcl_RegisteredMsgTaskID = TASK_NO_TASK;
   \                     zcl_RegisteredMsgTaskID:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for zcl_RegisteredMsgTaskID>`
   \   000001                REQUIRE __INIT_XDATA_I
    154          #endif
    155          
    156          // The Application should register its attribute data validation function

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    157          zclValidateAttrData_t zcl_ValidateAttrDataCB = (zclValidateAttrData_t)NULL;
   \                     zcl_ValidateAttrDataCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    158          
    159          // ZCL Sequence number

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    160          uint8 zcl_SeqNum = 0x00;
   \                     zcl_SeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    161          
    162          /*********************************************************************
    163           * EXTERNAL VARIABLES
    164           */
    165          
    166          /*********************************************************************
    167           * EXTERNAL FUNCTIONS
    168           */
    169          
    170          /*********************************************************************
    171           * LOCAL VARIABLES
    172           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    173          static zclLibPlugin_t *plugins = (zclLibPlugin_t *)NULL;
   \                     plugins:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    174          
    175          #if defined ( ZCL_DISCOVER )
    176            static zclCmdRecsList_t *gpCmdList = (zclCmdRecsList_t *)NULL;
    177          #endif
    178          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    179          static zclAttrRecsList *attrList = (zclAttrRecsList *)NULL;
   \                     attrList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    180          static zclClusterOptionList *clusterOptionList = (zclClusterOptionList *)NULL;
   \                     clusterOptionList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    181          static uint8 zcl_TransID = 0;  // This is the unique message ID (counter)
   \                     zcl_TransID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    182          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    183          static afIncomingMSGPacket_t *rawAFMsg = (afIncomingMSGPacket_t *)NULL;
   \                     rawAFMsg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    184          
    185          /*********************************************************************
    186           * LOCAL FUNCTIONS
    187           */
    188          void zcl_ProcessMessageMSG( afIncomingMSGPacket_t *pkt );  // Not static for ZNP build.
    189          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData );
    190          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr );
    191          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID );
    192          
    193          #if defined ( ZCL_DISCOVER )
    194            static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint );
    195          #endif
    196          
    197          static zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint );
    198          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID );
    199          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID );
    200          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable );
    201          
    202          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, uint8 frameType, uint8 cmd, uint16 profileID );
    203          
    204          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
    205          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint );
    206          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint );
    207          #endif // ZCL_READ || ZCL_WRITE
    208          
    209          #ifdef ZCL_READ
    210          ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen );
    211          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterID, uint16 attrId );
    212          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
    213                                                   uint8 *pAttrData, uint16 *pDataLen );
    214          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    215          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd );
    216          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg );
    217          #endif // ZCL_READ
    218          
    219          #ifdef ZCL_WRITE
    220          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
    221                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec );
    222          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
    223                                                    zclAttrRec_t *pAttr, uint8 *pAttrData );
    224          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    225          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd );
    226          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg );
    227          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg );
    228          #endif // ZCL_WRITE
    229          
    230          #ifdef ZCL_REPORT
    231          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd );
    232          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd );
    233          #endif // ZCL_REPORT
    234          
    235          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd );
    236          
    237          #ifdef ZCL_DISCOVER
    238          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID, uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd );
    239          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction, uint16 *attrId, zclAttrRec_t *pAttr );
    240          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd );
    241          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd );
    242          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd );
    243          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg );
    244          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg );
    245          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    246          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    247          #endif // ZCL_DISCOVER
    248          
    249          /*********************************************************************
    250           * Parse Profile Command Function Table
    251           */
    252          

   \                                 In  segment CODE_C, align 1
    253          static CONST zclCmdItems_t zclCmdTable[] =
   \                     zclCmdTable:
   \   000000   ....         DW ??zclParseInReadCmd?relay
   \   000002   ....         DW ??zclProcessInReadCmd?relay
   \   000004   ....         DW ??zclParseInReadRspCmd?relay
   \   000006   ....         DW ??zcl_HandleExternal?relay
   \   000008   ....         DW ??zclParseInWriteCmd?relay
   \   00000A   ....         DW ??zclProcessInWriteCmd?relay
   \   00000C   ....         DW ??zclParseInWriteCmd?relay
   \   00000E   ....         DW ??zclProcessInWriteUndividedCmd?relay
   \   000010   ....         DW ??zclParseInWriteRspCmd?relay
   \   000012   ....         DW ??zcl_HandleExternal?relay
   \   000014   ....         DW ??zclParseInWriteCmd?relay
   \   000016   ....         DW ??zclProcessInWriteCmd?relay
   \   000018   0000         DW 0H
   \   00001A   0000         DW 0H
   \   00001C   0000         DW 0H
   \   00001E   0000         DW 0H
   \   000020   0000         DW 0H
   \   000022   0000         DW 0H
   \   000024   0000         DW 0H
   \   000026   0000         DW 0H
   \   000028   0000         DW 0H
   \   00002A   0000         DW 0H
   \   00002C   ....         DW ??zclParseInDefaultRspCmd?relay
   \   00002E   ....         DW ??zcl_HandleExternal?relay
   \   000030   0000         DW 0H
   \   000032   0000         DW 0H
   \   000034   0000         DW 0H
   \   000036   0000         DW 0H
   \   000038   0000         DW 0H
   \   00003A   0000         DW 0H
   \   00003C   0000         DW 0H
   \   00003E   0000         DW 0H
   \   000040   0000         DW 0H
   \   000042   0000         DW 0H
   \   000044   0000         DW 0H
   \   000046   0000         DW 0H
   \   000048   0000         DW 0H
   \   00004A   0000         DW 0H
   \   00004C   0000         DW 0H
   \   00004E   0000         DW 0H
   \   000050   0000         DW 0H
   \   000052   0000         DW 0H
   \   000054   0000         DW 0H
   \   000056   0000         DW 0H
   \   000058   0000         DW 0H
   \   00005A   0000         DW 0H
    254          {
    255          #ifdef ZCL_READ
    256            /* ZCL_CMD_READ */                { zclParseInReadCmd,             zclProcessInReadCmd             },
    257            /* ZCL_CMD_READ_RSP */            { zclParseInReadRspCmd,          zcl_HandleExternal              },
    258          #else
    259            /* ZCL_CMD_READ */                { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    260            /* ZCL_CMD_READ_RSP */            { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    261          #endif // ZCL_READ
    262          
    263          #ifdef ZCL_WRITE
    264            /* ZCL_CMD_WRITE */               { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    265            /* ZCL_CMD_WRITE_UNDIVIDED */     { zclParseInWriteCmd,            zclProcessInWriteUndividedCmd   },
    266            /* ZCL_CMD_WRITE_RSP */           { zclParseInWriteRspCmd,         zcl_HandleExternal              },
    267            /* ZCL_CMD_WRITE_NO_RSP */        { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    268          #else
    269            /* ZCL_CMD_WRITE */               { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    270            /* ZCL_CMD_WRITE_UNDIVIDED */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    271            /* ZCL_CMD_WRITE_RSP */           { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    272            /* ZCL_CMD_WRITE_NO_RSP */        { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    273          #endif // ZCL_WRITE
    274          
    275          #ifdef ZCL_REPORT
    276            /* ZCL_CMD_CONFIG_REPORT */       { zclParseInConfigReportCmd,     zcl_HandleExternal              },
    277            /* ZCL_CMD_CONFIG_REPORT_RSP */   { zclParseInConfigReportRspCmd,  zcl_HandleExternal              },
    278            /* ZCL_CMD_READ_REPORT_CFG */     { zclParseInReadReportCfgCmd,    zcl_HandleExternal              },
    279            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { zclParseInReadReportCfgRspCmd, zcl_HandleExternal              },
    280            /* ZCL_CMD_REPORT */              { zclParseInReportCmd,           zcl_HandleExternal              },
    281          #else
    282            /* ZCL_CMD_CONFIG_REPORT */       { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    283            /* ZCL_CMD_CONFIG_REPORT_RSP */   { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    284            /* ZCL_CMD_READ_REPORT_CFG */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    285            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    286            /* ZCL_CMD_REPORT */              { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    287          #endif // ZCL_REPORT
    288          
    289            /* ZCL_CMD_DEFAULT_RSP */         { zclParseInDefaultRspCmd,       zcl_HandleExternal              },
    290          
    291          #ifdef ZCL_DISCOVER
    292            /* ZCL_CMD_DISCOVER_ATTRS */                { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    293            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { zclParseInDiscAttrsRspCmd,      zcl_HandleExternal              },
    294            /* *not supported* READ_ATTRS_STRCT */      { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    295            /* *not supported* WRITE_ATTRS_STRCT */     { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    296            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    297            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    298            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    299            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    300            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    301            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    302            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { zclParseInDiscAttrsExtRspCmd,   zcl_HandleExternal              },
    303          #else
    304            /* ZCL_CMD_DISCOVER_ATTRS */                { (zclParseInProfileCmd_t)NULL,    (zclProcessInProfileCmd_t)NULL  },
    305            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    306            /* *not supported* READ_ATTRS_STRCT */      { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    307            /* *not supported* WRITE_ATTRS_STRCT */     { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    308            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    309            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    310            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    311            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    312            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    313            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    314            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    315          #endif // ZCL_DISCOVER
    316          };
    317          
    318          /*********************************************************************
    319           * PUBLIC FUNCTIONS
    320           *********************************************************************/
    321          
    322          #if !defined ( ZCL_STANDALONE )
    323          /*********************************************************************
    324           * @fn          zcl_Init
    325           *
    326           * @brief       Initialization function for the zcl layer.
    327           *
    328           * @param       task_id - ZCL task id
    329           *
    330           * @return      none
    331           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    332          void zcl_Init( uint8 task_id )
   \                     zcl_Init:
    333          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    334            zcl_TaskID = task_id;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#zcl_TaskID
   \   000008   F0           MOVX    @DPTR,A
    335          }
   \   000009   02....       LJMP    ?Subroutine0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    336          #endif
    337          
    338          #if !defined ( ZCL_STANDALONE )
    339          /*********************************************************************
    340           * @fn          zcl_event_loop
    341           *
    342           * @brief       Event Loop Processor for zcl.
    343           *
    344           * @param       task_id - task id
    345           * @param       events - event bitmap
    346           *
    347           * @return      unprocessed events
    348           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    349          uint16 zcl_event_loop( uint8 task_id, uint16 events )
   \                     zcl_event_loop:
    350          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
    351            uint8 *msgPtr;
    352          
    353            (void)task_id;  // Intentionally unreferenced parameter
    354          
    355            if ( events & SYS_EVENT_MSG )
   \   000009   EB           MOV     A,R3
   \   00000A   5480         ANL     A,#0x80
   \   00000C   6048         JZ      ??zcl_event_loop_0
    356            {
    357              msgPtr = osal_msg_receive( zcl_TaskID );
   \   00000E                ; Setup parameters for call to function osal_msg_receive
   \   00000E   800E         SJMP    ??zcl_event_loop_1
    358              while ( msgPtr != NULL )
    359              {
    360                uint8 dealloc = TRUE;
    361          
    362                if ( *msgPtr == AF_INCOMING_MSG_CMD )
    363                {
    364                  zcl_ProcessMessageMSG( (afIncomingMSGPacket_t *)msgPtr );
   \                     ??zcl_event_loop_2:
   \   000010                ; Setup parameters for call to function zcl_ProcessMessageMSG
   \   000010   EE           MOV     A,R6
   \   000011   FA           MOV     R2,A
   \   000012   EF           MOV     A,R7
   \   000013   FB           MOV     R3,A
   \   000014   12....       LCALL   ??zcl_ProcessMessageMSG?relay
    365                }
    366                else if ( zcl_RegisteredMsgTaskID != TASK_NO_TASK )
    367                {
    368                  // send it to another task to process.
    369                  osal_msg_send( zcl_RegisteredMsgTaskID, msgPtr );
    370                  dealloc = FALSE;
    371                }
    372          
    373                // Release the memory
    374                if ( dealloc )
    375                {
    376                  osal_msg_deallocate( msgPtr );
   \                     ??zcl_event_loop_3:
   \   000017                ; Setup parameters for call to function osal_msg_deallocate
   \   000017   EE           MOV     A,R6
   \   000018   FA           MOV     R2,A
   \   000019   EF           MOV     A,R7
   \   00001A   FB           MOV     R3,A
   \   00001B   12....       LCALL   ??osal_msg_deallocate?relay
    377                }
    378          
    379                // Next
    380                msgPtr = osal_msg_receive( zcl_TaskID );
   \                     ??zcl_event_loop_1:
   \   00001E                ; Setup parameters for call to function osal_msg_receive
   \   00001E   90....       MOV     DPTR,#zcl_TaskID
   \   000021   E0           MOVX    A,@DPTR
   \   000022   F9           MOV     R1,A
   \   000023   12....       LCALL   ??osal_msg_receive?relay
   \   000026   8A..         MOV     ?V0 + 2,R2
   \   000028   8B..         MOV     ?V0 + 3,R3
   \   00002A   AE..         MOV     R6,?V0 + 2
   \   00002C   AF..         MOV     R7,?V0 + 3
   \   00002E   EE           MOV     A,R6
   \   00002F   4F           ORL     A,R7
   \   000030   601B         JZ      ??zcl_event_loop_4
   \   000032   8E82         MOV     DPL,R6
   \   000034   8F83         MOV     DPH,R7
   \   000036   E0           MOVX    A,@DPTR
   \   000037   641A         XRL     A,#0x1a
   \   000039   60D5         JZ      ??zcl_event_loop_2
   \   00003B   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   F4           CPL     A
   \   000040   60D5         JZ      ??zcl_event_loop_3
   \   000042                ; Setup parameters for call to function osal_msg_send
   \   000042   EE           MOV     A,R6
   \   000043   FA           MOV     R2,A
   \   000044   EF           MOV     A,R7
   \   000045   FB           MOV     R3,A
   \   000046   E0           MOVX    A,@DPTR
   \   000047   F9           MOV     R1,A
   \   000048   12....       LCALL   ??osal_msg_send?relay
   \   00004B   80D1         SJMP    ??zcl_event_loop_1
    381              }
    382          
    383              // return unprocessed events
    384              return (events ^ SYS_EVENT_MSG);
   \                     ??zcl_event_loop_4:
   \   00004D   AA..         MOV     R2,?V0 + 0
   \   00004F   E5..         MOV     A,?V0 + 1
   \   000051   6480         XRL     A,#0x80
   \   000053   FB           MOV     R3,A
   \   000054   8004         SJMP    ??zcl_event_loop_5
    385            }
    386          
    387            // Discard unknown events
    388            return 0;
   \                     ??zcl_event_loop_0:
   \   000056   7A00         MOV     R2,#0x0
   \   000058   7B00         MOV     R3,#0x0
   \                     ??zcl_event_loop_5:
   \   00005A   02....       LJMP    ?Subroutine1 & 0xFFFF
    389          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    390          #endif
    391          
    392          #if !defined ( ZCL_STANDALONE )
    393          /*********************************************************************
    394           * @fn      zcl_registerForMsg
    395           *
    396           * @brief   The ZCL is setup to send all incoming Foundation Command/Response
    397           *          messages that aren't processed to one task (if a task is
    398           *          registered).
    399           *
    400           * @param   taskId - task Id of the Application where commands will be sent to
    401           *
    402           * @return  TRUE if task registeration successful, FALSE otherwise
    403           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    404          uint8 zcl_registerForMsg( uint8 taskId )
   \                     zcl_registerForMsg:
    405          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
    406            // Allow only the first task
    407            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000006   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F4           CPL     A
   \   00000B   7006         JNZ     ??zcl_registerForMsg_0
    408            {
    409              zcl_RegisteredMsgTaskID = taskId;
   \   00000D   E8           MOV     A,R0
   \   00000E   F0           MOVX    @DPTR,A
    410          
    411              return ( true );
   \   00000F   7901         MOV     R1,#0x1
   \   000011   8002         SJMP    ??zcl_registerForMsg_1
    412            }
    413          
    414            return ( false );
   \                     ??zcl_registerForMsg_0:
   \   000013   7900         MOV     R1,#0x0
   \                     ??zcl_registerForMsg_1:
   \   000015   02....       LJMP    ?Subroutine0 & 0xFFFF
    415          }
    416          #endif
    417          
    418          #if !defined ( ZCL_STANDALONE )
    419          /*********************************************************************
    420           * @fn      zcl_HandleExternal
    421           *
    422           * @brief
    423           *
    424           * @param   pInMsg - incoming message to process
    425           *
    426           * @return  TRUE
    427           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    428          uint8 zcl_HandleExternal( zclIncoming_t *pInMsg )
   \                     zcl_HandleExternal:
    429          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    430            zclIncomingMsg_t *pCmd;
    431          
    432            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000009   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F4           CPL     A
   \   00000E   7003         JNZ     $+5
   \   000010   02....       LJMP    ??zcl_HandleExternal_0 & 0xFFFF
    433            {
    434              return ( TRUE );
    435            }
    436          
    437            pCmd = (zclIncomingMsg_t *)osal_msg_allocate( sizeof ( zclIncomingMsg_t ) );
   \   000013                ; Setup parameters for call to function osal_msg_allocate
   \   000013   7A19         MOV     R2,#0x19
   \   000015   7B00         MOV     R3,#0x0
   \   000017   12....       LCALL   ??osal_msg_allocate?relay
    438            if ( pCmd != NULL )
   \   00001A   EA           MOV     A,R2
   \   00001B   4B           ORL     A,R3
   \   00001C   7003         JNZ     $+5
   \   00001E   02....       LJMP    ??zcl_HandleExternal_0 & 0xFFFF
    439            {
    440              // fill in the message
    441              pCmd->hdr.event = ZCL_INCOMING_MSG;
   \   000021   8A82         MOV     DPL,R2
   \   000023   8B83         MOV     DPH,R3
   \   000025   7434         MOV     A,#0x34
   \   000027   12....       LCALL   ??Subroutine118_0 & 0xFFFF
    442              pCmd->zclHdr    = pInMsg->hdr;
   \                     ??CrossCallReturnLabel_176:
   \   00002A   A3           INC     DPTR
   \   00002B   EA           MOV     A,R2
   \   00002C   2402         ADD     A,#0x2
   \   00002E   FC           MOV     R4,A
   \   00002F   EB           MOV     A,R3
   \   000030   3400         ADDC    A,#0x0
   \   000032   FD           MOV     R5,A
   \   000033   7406         MOV     A,#0x6
   \   000035   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    443              pCmd->clusterId = pInMsg->msg->clusterId;
   \   000038   8E82         MOV     DPL,R6
   \   00003A   8F83         MOV     DPH,R7
   \   00003C   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   00003F   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_329:
   \   000042   8A82         MOV     DPL,R2
   \   000044   8B83         MOV     DPH,R3
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   EC           MOV     A,R4
   \   00004F   F0           MOVX    @DPTR,A
   \   000050   A3           INC     DPTR
   \   000051   ED           MOV     A,R5
   \   000052   12....       LCALL   ?Subroutine21 & 0xFFFF
    444              pCmd->srcAddr   = pInMsg->msg->srcAddr;
   \                     ??CrossCallReturnLabel_18:
   \   000055   A3           INC     DPTR
   \   000056   EA           MOV     A,R2
   \   000057   240A         ADD     A,#0xa
   \   000059   FC           MOV     R4,A
   \   00005A   EB           MOV     A,R3
   \   00005B   3400         ADDC    A,#0x0
   \   00005D   FD           MOV     R5,A
   \   00005E   740C         MOV     A,#0xc
   \   000060   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    445              pCmd->endPoint  = pInMsg->msg->endPoint;
   \   000063   8E82         MOV     DPL,R6
   \   000065   8F83         MOV     DPH,R7
   \   000067   E0           MOVX    A,@DPTR
   \   000068   F8           MOV     R0,A
   \   000069   12....       LCALL   ?Subroutine111 & 0xFFFF
   \                     ??CrossCallReturnLabel_344:
   \   00006C   E8           MOV     A,R0
   \   00006D   12....       LCALL   ??Subroutine117_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_172:
   \   000070   C0E0         PUSH    A
   \   000072   EA           MOV     A,R2
   \   000073   2416         ADD     A,#0x16
   \   000075   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_190:
   \   000078   D0E0         POP     A
   \   00007A   F0           MOVX    @DPTR,A
    446              pCmd->attrCmd   = pInMsg->attrCmd;
   \   00007B   EE           MOV     A,R6
   \   00007C   240C         ADD     A,#0xc
   \   00007E   F8           MOV     R0,A
   \   00007F   EF           MOV     A,R7
   \   000080   12....       LCALL   ??Subroutine115_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_159:
   \   000083   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_322:
   \   000086   EA           MOV     A,R2
   \   000087   2417         ADD     A,#0x17
   \   000089   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_191:
   \   00008C   EC           MOV     A,R4
   \   00008D   F0           MOVX    @DPTR,A
   \   00008E   A3           INC     DPTR
   \   00008F   ED           MOV     A,R5
   \   000090   F0           MOVX    @DPTR,A
    447          
    448              // Application will free the attrCmd buffer
    449              pInMsg->attrCmd = NULL;
   \   000091   8882         MOV     DPL,R0
   \   000093   8983         MOV     DPH,R1
   \   000095   E4           CLR     A
   \   000096   F0           MOVX    @DPTR,A
   \   000097   A3           INC     DPTR
   \   000098   F0           MOVX    @DPTR,A
    450          
    451              /* send message through task message */
    452              osal_msg_send( zcl_RegisteredMsgTaskID, (uint8 *)pCmd );
   \   000099                ; Setup parameters for call to function osal_msg_send
   \   000099   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   00009C   E0           MOVX    A,@DPTR
   \   00009D   F9           MOV     R1,A
   \   00009E   12....       LCALL   ??osal_msg_send?relay
    453            }
    454          
    455            return ( TRUE );
   \                     ??zcl_HandleExternal_0:
   \   0000A1   7901         MOV     R1,#0x1
   \   0000A3   02....       LJMP    ?Subroutine2 & 0xFFFF
    456          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine107:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine87:
   \   000000   12....       LCALL   ?Subroutine107 & 0xFFFF
   \                     ??CrossCallReturnLabel_150:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine115_0:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F9           MOV     R1,A
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_139:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine98:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   8882         MOV     DPL,R0
   \   000007   8983         MOV     DPH,R1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine117_0:
   \   000000   12....       LCALL   ??Subroutine122_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_193:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine118_0:
   \   000000   12....       LCALL   ?Subroutine108 & 0xFFFF
   \                     ??CrossCallReturnLabel_215:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine108:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine103:
   \   000000   F582         MOV     DPL,A
   \   000002   EB           MOV     A,R3
   \   000003                REQUIRE ??Subroutine122_0
   \   000003                ; // Fall through to label ??Subroutine122_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine122_0:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F583         MOV     DPH,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine110:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine142_0
   \   000001                ; // Fall through to label ??Subroutine142_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine142_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine143_0
   \   000001                ; // Fall through to label ??Subroutine143_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine143_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine144_0
   \   000002                ; // Fall through to label ??Subroutine144_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine144_0:
   \   000000   12....       LCALL   ??Subroutine145_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_335:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine145_0:
   \   000000   12....       LCALL   ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_341:
   \   000003   FD           MOV     R5,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine111:
   \   000000   A3           INC     DPTR
   \   000001   E0           MOVX    A,@DPTR
   \   000002   C8           XCH     A,R0
   \   000003                REQUIRE ??Subroutine146_0
   \   000003                ; // Fall through to label ??Subroutine146_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine146_0:
   \   000000   2414         ADD     A,#0x14
   \   000002   F582         MOV     DPL,A
   \   000004   22           RET
    457          #endif
    458          
    459          
    460          /*********************************************************************
    461           * @fn          zcl_getRawAFMsg
    462           *
    463           * @brief       Call to get original unprocessed AF message
    464           *              (not parsed by ZCL).
    465           *
    466           *   NOTE:  This function can only be called during a ZCL callback function
    467           *          and the calling function must NOT change any data in the message.
    468           *
    469           * @param       none
    470           *
    471           * @return      pointer to original AF message, NULL if not processing
    472           *              AF message.
    473           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    474          afIncomingMSGPacket_t *zcl_getRawAFMsg( void )
   \                     zcl_getRawAFMsg:
    475          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    476            return ( rawAFMsg );
   \   000004   90....       MOV     DPTR,#rawAFMsg
   \   000007   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_292:
   \   00000A                REQUIRE ?Subroutine0
   \   00000A                ; // Fall through to label ?Subroutine0
    477          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine140_0:
   \   000000   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_314:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine93:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
    478          
    479          /*********************************************************************
    480           * @fn          zcl_registerPlugin
    481           *
    482           * @brief       Add a Cluster Library handler
    483           *
    484           * @param       startClusterID - starting cluster ID
    485           * @param       endClusterID - ending cluster ID
    486           * @param       pfnHdlr - function pointer to incoming message handler
    487           *
    488           * @return      ZSuccess if OK
    489           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    490          ZStatus_t zcl_registerPlugin( uint16 startClusterID,
   \                     zcl_registerPlugin:
    491                    uint16 endClusterID, zclInHdlr_t pfnIncomingHdlr )
    492          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   8C..         MOV     ?V0 + 2,R4
   \   00000B   8D..         MOV     ?V0 + 3,R5
   \   00000D   740E         MOV     A,#0xe
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   12....       LCALL   ??Subroutine127_0 & 0xFFFF
    493            zclLibPlugin_t *pNewItem;
    494            zclLibPlugin_t *pLoop;
    495          
    496            // Fill in the new profile list
    497            pNewItem = zcl_mem_alloc( sizeof( zclLibPlugin_t ) );
   \                     ??CrossCallReturnLabel_217:
   \   000015                ; Setup parameters for call to function osal_mem_alloc
   \   000015   7A08         MOV     R2,#0x8
   \   000017   7B00         MOV     R3,#0x0
   \   000019   12....       LCALL   ??osal_mem_alloc?relay
   \   00001C   8A..         MOV     ?V0 + 4,R2
   \   00001E   8B..         MOV     ?V0 + 5,R3
   \   000020   A8..         MOV     R0,?V0 + 4
   \   000022   A9..         MOV     R1,?V0 + 5
    498            if ( pNewItem == NULL )
   \   000024   E8           MOV     A,R0
   \   000025   49           ORL     A,R1
   \   000026   7004         JNZ     ??zcl_registerPlugin_0
    499            {
    500              return (ZMemError);
   \   000028   7910         MOV     R1,#0x10
   \   00002A   8040         SJMP    ??CrossCallReturnLabel_22
    501            }
    502          
    503            // Fill in the plugin record.
    504            pNewItem->next = (zclLibPlugin_t *)NULL;
   \                     ??zcl_registerPlugin_0:
   \   00002C   12....       LCALL   ?Subroutine85 & 0xFFFF
    505            pNewItem->startClusterID = startClusterID;
   \                     ??CrossCallReturnLabel_119:
   \   00002F   A3           INC     DPTR
   \   000030   12....       LCALL   ?Subroutine27 & 0xFFFF
    506            pNewItem->endClusterID = endClusterID;
   \                     ??CrossCallReturnLabel_27:
   \   000033   E5..         MOV     A,?V0 + 2
   \   000035   F0           MOVX    @DPTR,A
   \   000036   A3           INC     DPTR
   \   000037   E5..         MOV     A,?V0 + 3
   \   000039   F0           MOVX    @DPTR,A
    507            pNewItem->pfnIncomingHdlr = pfnIncomingHdlr;
   \   00003A   EE           MOV     A,R6
   \   00003B   FA           MOV     R2,A
   \   00003C   EF           MOV     A,R7
   \   00003D   FB           MOV     R3,A
   \   00003E   8882         MOV     DPL,R0
   \   000040   8983         MOV     DPH,R1
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   EA           MOV     A,R2
   \   000049   F0           MOVX    @DPTR,A
   \   00004A   A3           INC     DPTR
   \   00004B   EB           MOV     A,R3
   \   00004C   F0           MOVX    @DPTR,A
    508          
    509            // Find spot in list
    510            if (  plugins == NULL )
   \   00004D   90....       MOV     DPTR,#plugins
   \   000050   12....       LCALL   ??Subroutine116_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_166:
   \   000053   90....       MOV     DPTR,#plugins
   \   000056   6011         JZ      ??zcl_registerPlugin_1
    511            {
    512              plugins = pNewItem;
    513            }
    514            else
    515            {
    516              // Look for end of list
    517              pLoop = plugins;
   \   000058   12....       LCALL   ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_336:
   \   00005B   8003         SJMP    ??zcl_registerPlugin_2
    518              while ( pLoop->next != NULL )
    519              {
    520                pLoop = pLoop->next;
   \                     ??zcl_registerPlugin_3:
   \   00005D   EA           MOV     A,R2
   \   00005E   FC           MOV     R4,A
   \   00005F   EB           MOV     A,R3
    521              }
   \                     ??zcl_registerPlugin_2:
   \   000060   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_162:
   \   000063   70F8         JNZ     ??zcl_registerPlugin_3
    522          
    523              // Put new item at end of list
    524              pLoop->next = pNewItem;
   \   000065   8C82         MOV     DPL,R4
   \   000067   8D83         MOV     DPH,R5
    525            }
   \                     ??zcl_registerPlugin_1:
   \   000069   12....       LCALL   ?Subroutine23 & 0xFFFF
    526          
    527            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_22:
   \   00006C   02....       LJMP    ?Subroutine3 & 0xFFFF
    528          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   7900         MOV     R1,#0x0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   E5..         MOV     A,?V0 + 1
   \   000002   12....       LCALL   ?Subroutine107 & 0xFFFF
   \                     ??CrossCallReturnLabel_149:
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine85:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   E4           CLR     A
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   F0           MOVX    @DPTR,A
   \   000008   8882         MOV     DPL,R0
   \   00000A   8983         MOV     DPH,R1
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   E5..         MOV     A,?V0 + 0
   \   000010   F0           MOVX    @DPTR,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   FD           MOV     R5,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005                REQUIRE ??Subroutine116_0
   \   000005                ; // Fall through to label ??Subroutine116_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine116_0:
   \   000000   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_312:
   \   000003   EA           MOV     A,R2
   \   000004   4B           ORL     A,R3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F06         MOV     R7,#0x6
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine127_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FE           MOV     R6,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FF           MOV     R7,A
   \   000005   22           RET
    529          
    530          #ifdef ZCL_DISCOVER
    531          /*********************************************************************
    532           * @fn          zcl_registerCmdList
    533           *
    534           * @brief       Register a Command List with ZCL Foundation
    535           *
    536           * @param       endpoint - endpoint the attribute list belongs to
    537           * @param       newCmdList - array of command records
    538           *
    539           * @return      ZSuccess if OK
    540           */
    541          ZStatus_t zcl_registerCmdList( uint8 endpoint, CONST uint8 numAttrs, CONST zclCommandRec_t zclTestApp_Cmds[] );
    542          ZStatus_t zcl_registerCmdList( uint8 endpoint, uint8 zclCmdsArraySize, CONST zclCommandRec_t newCmdList[] )
    543          {
    544            zclCmdRecsList_t *pNewItem;
    545            zclCmdRecsList_t *pLoop;
    546          
    547            // Fill in the new profile list
    548            pNewItem = zcl_mem_alloc( sizeof( zclCmdRecsList_t ) );
    549            if ( pNewItem == NULL )
    550            {
    551              return (ZMemError);
    552            }
    553          
    554            pNewItem->pNext = (zclCmdRecsList_t *)NULL;
    555            pNewItem->endpoint = endpoint;
    556            pNewItem->numCommands = zclCmdsArraySize;
    557            pNewItem->pCmdRecs = newCmdList;
    558          
    559            // Find spot in list
    560            if ( gpCmdList == NULL )
    561            {
    562              gpCmdList = pNewItem;
    563            }
    564            else
    565            {
    566              // Look for end of list
    567              pLoop = gpCmdList;
    568              while ( pLoop->pNext != NULL )
    569              {
    570                pLoop = pLoop->pNext;
    571              }
    572          
    573              // Put new item at end of list
    574              pLoop->pNext = pNewItem;
    575            }
    576          
    577            return ( ZSuccess );
    578          }
    579          #endif  // ZCL_DISCOVER
    580          
    581          /*********************************************************************
    582           * @fn          zcl_registerAttrList
    583           *
    584           * @brief       Register an Attribute List with ZCL Foundation
    585           *
    586           * @param       endpoint - endpoint the attribute list belongs to
    587           * @param       numAttr - number of attributes in list
    588           * @param       newAttrList - array of Attribute records.
    589           *                            NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE IN
    590           *                            ASCENDING ORDER. OTHERWISE, THE DISCOVERY RESPONSE
    591           *                            COMMAND WILL NOT HAVE THE RIGHT ATTRIBUTE INFO
    592           *
    593           * @return      ZSuccess if OK
    594           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    595          ZStatus_t zcl_registerAttrList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t newAttrList[] )
   \                     zcl_registerAttrList:
    596          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   8A..         MOV     ?V0 + 1,R2
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    597            zclAttrRecsList *pNewItem;
    598            zclAttrRecsList *pLoop;
    599          
    600            // Fill in the new profile list
    601            pNewItem = zcl_mem_alloc( sizeof( zclAttrRecsList ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A0A         MOV     R2,#0xa
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   ??osal_mem_alloc?relay
   \   000014   8A..         MOV     ?V0 + 2,R2
   \   000016   8B..         MOV     ?V0 + 3,R3
   \   000018   A8..         MOV     R0,?V0 + 2
   \   00001A   A9..         MOV     R1,?V0 + 3
    602            if ( pNewItem == NULL )
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7004         JNZ     ??zcl_registerAttrList_0
    603            {
    604              return (ZMemError);
   \   000020   7910         MOV     R1,#0x10
   \   000022   8033         SJMP    ??CrossCallReturnLabel_23
    605            }
    606          
    607            pNewItem->next = (zclAttrRecsList *)NULL;
   \                     ??zcl_registerAttrList_0:
   \   000024   12....       LCALL   ?Subroutine10 & 0xFFFF
    608            pNewItem->endpoint = endpoint;
    609            pNewItem->pfnReadWriteCB = NULL;
   \                     ??CrossCallReturnLabel_0:
   \   000027   E4           CLR     A
   \   000028   F0           MOVX    @DPTR,A
   \   000029   A3           INC     DPTR
   \   00002A   12....       LCALL   ?Subroutine14 & 0xFFFF
    610            pNewItem->numAttributes = numAttr;
   \                     ??CrossCallReturnLabel_8:
   \   00002D   E5..         MOV     A,?V0 + 1
   \   00002F   12....       LCALL   ?Subroutine14 & 0xFFFF
    611            pNewItem->attrs = newAttrList;
   \                     ??CrossCallReturnLabel_9:
   \   000032   A3           INC     DPTR
   \   000033   EE           MOV     A,R6
   \   000034   F0           MOVX    @DPTR,A
   \   000035   A3           INC     DPTR
   \   000036   EF           MOV     A,R7
   \   000037   F0           MOVX    @DPTR,A
    612          
    613            // Find spot in list
    614            if ( attrList == NULL )
   \   000038   90....       MOV     DPTR,#attrList
   \   00003B   12....       LCALL   ??Subroutine116_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_167:
   \   00003E   90....       MOV     DPTR,#attrList
   \   000041   6011         JZ      ??zcl_registerAttrList_1
    615            {
    616              attrList = pNewItem;
    617            }
    618            else
    619            {
    620              // Look for end of list
    621              pLoop = attrList;
   \   000043   12....       LCALL   ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_337:
   \   000046   8003         SJMP    ??zcl_registerAttrList_2
    622              while ( pLoop->next != NULL )
    623              {
    624                pLoop = pLoop->next;
   \                     ??zcl_registerAttrList_3:
   \   000048   EA           MOV     A,R2
   \   000049   FC           MOV     R4,A
   \   00004A   EB           MOV     A,R3
    625              }
   \                     ??zcl_registerAttrList_2:
   \   00004B   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_163:
   \   00004E   70F8         JNZ     ??zcl_registerAttrList_3
    626          
    627              // Put new item at end of list
    628              pLoop->next = pNewItem;
   \   000050   8C82         MOV     DPL,R4
   \   000052   8D83         MOV     DPH,R5
    629            }
   \                     ??zcl_registerAttrList_1:
   \   000054   12....       LCALL   ?Subroutine23 & 0xFFFF
    630          
    631            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_23:
   \   000057   80..         SJMP    ?Subroutine1
    632          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_123:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   22           RET
    633          
    634          /*********************************************************************
    635           * @fn          zcl_registerClusterOptionList
    636           *
    637           * @brief       Register a Cluster Option List with ZCL Foundation
    638           *
    639           * @param       endpoint - endpoint the option list belongs to
    640           * @param       numOption - number of options in list
    641           * @param       optionList - array of cluster option records.
    642           *
    643           *              NOTE: This API should be called to enable 'Application
    644           *                    Link Key' security and/or 'APS ACK' for a specific
    645           *                    Cluster. The 'Application Link Key' is discarded
    646           *                    if security isn't enabled on the device.
    647           *                    The default behavior is 'Network Key' when security
    648           *                    is enabled and no 'APS ACK' for the ZCL messages.
    649           *
    650           * @return      ZSuccess if OK
    651           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    652          ZStatus_t zcl_registerClusterOptionList( uint8 endpoint, uint8 numOption, zclOptionRec_t optionList[] )
   \                     zcl_registerClusterOptionList:
    653          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   8A..         MOV     ?V0 + 1,R2
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    654            zclClusterOptionList *pNewItem;
    655            zclClusterOptionList *pLoop;
    656          
    657            // Fill in the new profile list
    658            pNewItem = zcl_mem_alloc( sizeof( zclClusterOptionList ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A06         MOV     R2,#0x6
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   ??osal_mem_alloc?relay
   \   000014   8A..         MOV     ?V0 + 2,R2
   \   000016   8B..         MOV     ?V0 + 3,R3
   \   000018   A8..         MOV     R0,?V0 + 2
   \   00001A   A9..         MOV     R1,?V0 + 3
    659            if ( pNewItem == NULL )
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7004         JNZ     ??zcl_registerClusterOptionList_0
    660            {
    661              return (ZMemError);
   \   000020   7910         MOV     R1,#0x10
   \   000022   802A         SJMP    ??CrossCallReturnLabel_24
    662            }
    663          
    664            pNewItem->next = (zclClusterOptionList *)NULL;
   \                     ??zcl_registerClusterOptionList_0:
   \   000024   12....       LCALL   ?Subroutine10 & 0xFFFF
    665            pNewItem->endpoint = endpoint;
    666            pNewItem->numOptions = numOption;
   \                     ??CrossCallReturnLabel_1:
   \   000027   12....       LCALL   ?Subroutine27 & 0xFFFF
    667            pNewItem->options = optionList;
   \                     ??CrossCallReturnLabel_28:
   \   00002A   EE           MOV     A,R6
   \   00002B   F0           MOVX    @DPTR,A
   \   00002C   A3           INC     DPTR
   \   00002D   EF           MOV     A,R7
   \   00002E   F0           MOVX    @DPTR,A
    668          
    669            // Find spot in list
    670            if ( clusterOptionList == NULL )
   \   00002F   90....       MOV     DPTR,#clusterOptionList
   \   000032   12....       LCALL   ??Subroutine116_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_168:
   \   000035   90....       MOV     DPTR,#clusterOptionList
   \   000038   6011         JZ      ??zcl_registerClusterOptionList_1
    671            {
    672              clusterOptionList = pNewItem;
    673            }
    674            else
    675            {
    676              // Look for end of list
    677              pLoop = clusterOptionList;
   \   00003A   12....       LCALL   ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_338:
   \   00003D   8003         SJMP    ??zcl_registerClusterOptionList_2
    678              while ( pLoop->next != NULL )
    679              {
    680                pLoop = pLoop->next;
   \                     ??zcl_registerClusterOptionList_3:
   \   00003F   EA           MOV     A,R2
   \   000040   FC           MOV     R4,A
   \   000041   EB           MOV     A,R3
    681              }
   \                     ??zcl_registerClusterOptionList_2:
   \   000042   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_164:
   \   000045   70F8         JNZ     ??zcl_registerClusterOptionList_3
    682          
    683              // Put new item at end of list
    684              pLoop->next = pNewItem;
   \   000047   8C82         MOV     DPL,R4
   \   000049   8D83         MOV     DPH,R5
    685            }
   \                     ??zcl_registerClusterOptionList_1:
   \   00004B   12....       LCALL   ?Subroutine23 & 0xFFFF
    686          
    687            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_24:
   \   00004E                REQUIRE ?Subroutine1
   \   00004E                ; // Fall through to label ?Subroutine1
    688          }
    689          
    690          /*********************************************************************
    691           * @fn          zcl_registerValidateAttrData
    692           *
    693           * @brief       Add a validation function for attribute data
    694           *
    695           * @param       pfnValidateAttrData - function pointer to validate routine
    696           *
    697           * @return      ZSuccess if OK
    698           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    699          ZStatus_t zcl_registerValidateAttrData( zclValidateAttrData_t pfnValidateAttrData )
   \                     zcl_registerValidateAttrData:
    700          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    701            zcl_ValidateAttrDataCB = pfnValidateAttrData;
   \   000004   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   000007   EA           MOV     A,R2
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   EB           MOV     A,R3
   \   00000B   F0           MOVX    @DPTR,A
    702          
    703            return ( ZSuccess );
   \   00000C   7900         MOV     R1,#0x0
   \   00000E   02....       LJMP    ?Subroutine0 & 0xFFFF
    704          }
    705          
    706          /*********************************************************************
    707           * @fn          zcl_registerReadWriteCB
    708           *
    709           * @brief       Register the application's callback function to read/write
    710           *              attribute data, and authorize read/write operation.
    711           *
    712           *              Note: The pfnReadWriteCB callback function is only required
    713           *                    when the attribute data format is unknown to ZCL. The
    714           *                    callback function gets called when the pointer 'dataPtr'
    715           *                    to the attribute value is NULL in the attribute database
    716           *                    registered with the ZCL.
    717           *
    718           *              Note: The pfnAuthorizeCB callback function is only required
    719           *                    when the Read/Write operation on an attribute requires
    720           *                    authorization (i.e., attributes with ACCESS_CONTROL_AUTH_READ
    721           *                    or ACCESS_CONTROL_AUTH_WRITE access permissions).
    722           *
    723           * @param       endpoint - application's endpoint
    724           * @param       pfnReadWriteCB - function pointer to read/write routine
    725           * @param       pfnAuthorizeCB - function pointer to authorize read/write operation
    726           *
    727           * @return      ZSuccess if successful. ZFailure, otherwise.
    728           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    729          ZStatus_t zcl_registerReadWriteCB( uint8 endpoint, zclReadWriteCB_t pfnReadWriteCB,
   \                     zcl_registerReadWriteCB:
    730                                             zclAuthorizeCB_t pfnAuthorizeCB )
    731          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
    732            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   00000D                ; Setup parameters for call to function zclFindAttrRecsList
   \   00000D   12....       LCALL   ??zclFindAttrRecsList?relay
   \   000010   8A..         MOV     ?V0 + 4,R2
   \   000012   8B..         MOV     ?V0 + 5,R3
   \   000014   A8..         MOV     R0,?V0 + 4
   \   000016   A9..         MOV     R1,?V0 + 5
    733          
    734            if ( pRec != NULL )
   \   000018   E8           MOV     A,R0
   \   000019   49           ORL     A,R1
   \   00001A   6019         JZ      ??zcl_registerReadWriteCB_0
    735            {
    736              pRec->pfnReadWriteCB = pfnReadWriteCB;
   \   00001C   8882         MOV     DPL,R0
   \   00001E   8983         MOV     DPH,R1
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   EE           MOV     A,R6
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   EF           MOV     A,R7
   \   000027   12....       LCALL   ?Subroutine21 & 0xFFFF
    737              pRec->pfnAuthorizeCB = pfnAuthorizeCB;
   \                     ??CrossCallReturnLabel_19:
   \   00002A   E5..         MOV     A,?V0 + 0
   \   00002C   F0           MOVX    @DPTR,A
   \   00002D   A3           INC     DPTR
   \   00002E   E5..         MOV     A,?V0 + 1
   \   000030   F0           MOVX    @DPTR,A
    738          
    739              return ( ZSuccess );
   \   000031   7900         MOV     R1,#0x0
   \   000033   8002         SJMP    ??zcl_registerReadWriteCB_1
    740            }
    741          
    742            return ( ZFailure );
   \                     ??zcl_registerReadWriteCB_0:
   \   000035   7901         MOV     R1,#0x1
   \                     ??zcl_registerReadWriteCB_1:
   \   000037   02....       LJMP    ?Subroutine3 & 0xFFFF
    743          }
    744          
    745          /*********************************************************************
    746           * @fn      zcl_DeviceOperational
    747           *
    748           * @brief   Used to see whether or not the device can send or respond
    749           *          to application level commands.
    750           *
    751           * @param   srcEP - source endpoint
    752           * @param   clusterID - cluster ID
    753           * @param   frameType - command type
    754           * @param   cmd - command ID
    755           *
    756           * @return  TRUE if device is operational, FALSE otherwise
    757           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    758          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID,
   \                     zcl_DeviceOperational:
    759                                              uint8 frameType, uint8 cmd, uint16 profileID )
    760          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FF           MOV     R7,A
    761            zclAttrRec_t attrRec;
    762            uint8 deviceEnabled = DEVICE_ENABLED; // default value
   \   00000C   85..82       MOV     DPL,?XSP + 0
   \   00000F   85..83       MOV     DPH,?XSP + 1
   \   000012   7401         MOV     A,#0x1
   \   000014   F0           MOVX    @DPTR,A
    763          
    764            (void)profileID;  // Intentionally unreferenced parameter
    765          
    766            // If the device is Disabled (DeviceEnabled attribute is set to Disabled), it
    767            // cannot send or respond to application level commands, other than commands
    768            // to read or write attributes. Note that the Identify cluster cannot be
    769            // disabled, and remains functional regardless of this setting.
    770            if ( zcl_ProfileCmd( frameType ) && cmd <= ZCL_CMD_WRITE_NO_RSP )
   \   000015   EF           MOV     A,R7
   \   000016   7006         JNZ     ??zcl_DeviceOperational_0
   \   000018   ED           MOV     A,R5
   \   000019   C3           CLR     C
   \   00001A   9406         SUBB    A,#0x6
   \   00001C   405A         JC      ??zcl_DeviceOperational_1
    771            {
    772              return ( TRUE );
    773            }
    774          
    775            if ( clusterID == ZCL_CLUSTER_ID_GEN_IDENTIFY )
   \                     ??zcl_DeviceOperational_0:
   \   00001E   7403         MOV     A,#0x3
   \   000020   6A           XRL     A,R2
   \   000021   7001         JNZ     ??zcl_DeviceOperational_2
   \   000023   EB           MOV     A,R3
   \                     ??zcl_DeviceOperational_2:
   \   000024   6052         JZ      ??zcl_DeviceOperational_1
    776            {
    777              return ( TRUE );
    778            }
    779          
    780            // Is device enabled?
    781            if ( zclFindAttrRec( srcEP, ZCL_CLUSTER_ID_GEN_BASIC,
    782                                 ATTRID_BASIC_DEVICE_ENABLED, &attrRec ) )
   \   000026                ; Setup parameters for call to function zclFindAttrRec
   \   000026   7401         MOV     A,#0x1
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   8582..       MOV     ?V0 + 0,DPL
   \   00002E   8583..       MOV     ?V0 + 1,DPH
   \   000031   78..         MOV     R0,#?V0 + 0
   \   000033   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000036   7C12         MOV     R4,#0x12
   \   000038   7D00         MOV     R5,#0x0
   \   00003A   7A00         MOV     R2,#0x0
   \   00003C   7B00         MOV     R3,#0x0
   \   00003E   12....       LCALL   ??zclFindAttrRec?relay
   \   000041   7402         MOV     A,#0x2
   \   000043   12....       LCALL   ?DEALLOC_XSTACK8
   \   000046   E9           MOV     A,R1
   \   000047   6024         JZ      ??zcl_DeviceOperational_3
    783            {
    784          #ifdef ZCL_READ
    785              zclReadAttrData( &deviceEnabled, &attrRec, NULL );
   \   000049                ; Setup parameters for call to function zclReadAttrData
   \   000049   E4           CLR     A
   \   00004A   F5..         MOV     ?V0 + 0,A
   \   00004C   F5..         MOV     ?V0 + 1,A
   \   00004E   78..         MOV     R0,#?V0 + 0
   \   000050   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000053   7403         MOV     A,#0x3
   \   000055   12....       LCALL   ?XSTACK_DISP0_8
   \   000058   AC82         MOV     R4,DPL
   \   00005A   AD83         MOV     R5,DPH
   \   00005C   7402         MOV     A,#0x2
   \   00005E   12....       LCALL   ?XSTACK_DISP0_8
   \   000061   AA82         MOV     R2,DPL
   \   000063   AB83         MOV     R3,DPH
   \   000065   12....       LCALL   ??zclReadAttrData?relay
   \   000068   7402         MOV     A,#0x2
   \   00006A   12....       LCALL   ?DEALLOC_XSTACK8
    786          #endif
    787            }
    788          
    789            return ( deviceEnabled == DEVICE_ENABLED ? TRUE : FALSE );
   \                     ??zcl_DeviceOperational_3:
   \   00006D   85..82       MOV     DPL,?XSP + 0
   \   000070   85..83       MOV     DPH,?XSP + 1
   \   000073   E0           MOVX    A,@DPTR
   \   000074   6401         XRL     A,#0x1
   \   000076   7004         JNZ     ??zcl_DeviceOperational_4
   \                     ??zcl_DeviceOperational_1:
   \   000078   7901         MOV     R1,#0x1
   \   00007A   8002         SJMP    ??zcl_DeviceOperational_5
   \                     ??zcl_DeviceOperational_4:
   \   00007C   7900         MOV     R1,#0x0
   \                     ??zcl_DeviceOperational_5:
   \   00007E   7409         MOV     A,#0x9
   \   000080   12....       LCALL   ?DEALLOC_XSTACK8
   \   000083   7F03         MOV     R7,#0x3
   \   000085   02....       LJMP    ?BANKED_LEAVE_XDATA
    790          }
    791          
    792          /*********************************************************************
    793           * @fn      zcl_SendCommand
    794           *
    795           * @brief   Used to send Profile and Cluster Specific Command messages.
    796           *
    797           *          NOTE: The calling application is responsible for incrementing
    798           *                the Sequence Number.
    799           *
    800           * @param   srcEp - source endpoint
    801           * @param   destAddr - destination address
    802           * @param   clusterID - cluster ID
    803           * @param   cmd - command ID
    804           * @param   specific - whether the command is Cluster Specific
    805           * @param   direction - client/server direction of the command
    806           * @param   disableDefaultRsp - disable Default Response command
    807           * @param   manuCode - manufacturer code for proprietary extensions to a profile
    808           * @param   seqNumber - identification number for the transaction
    809           * @param   cmdFormatLen - length of the command to be sent
    810           * @param   cmdFormat - command to be sent
    811           *
    812           * @return  ZSuccess if OK
    813           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    814          ZStatus_t zcl_SendCommand( uint8 srcEP, afAddrType_t *destAddr,
   \                     zcl_SendCommand:
    815                                     uint16 clusterID, uint8 cmd, uint8 specific, uint8 direction,
    816                                     uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum,
    817                                     uint16 cmdFormatLen, uint8 *cmdFormat )
    818          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V0 + 5,R1
   \   00000C   8A..         MOV     ?V0 + 14,R2
   \   00000E   8B..         MOV     ?V0 + 15,R3
   \   000010   8C..         MOV     ?V0 + 2,R4
   \   000012   8D..         MOV     ?V0 + 3,R5
   \   000014   741F         MOV     A,#0x1f
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   F5..         MOV     ?V0 + 0,A
   \   00001C   7420         MOV     A,#0x20
   \   00001E   12....       LCALL   ?XSTACK_DISP0_8
   \   000021   E0           MOVX    A,@DPTR
   \   000022   F5..         MOV     ?V0 + 1,A
   \   000024   7421         MOV     A,#0x21
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   FF           MOV     R7,A
   \   00002B   7424         MOV     A,#0x24
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   E0           MOVX    A,@DPTR
   \   000031   FE           MOV     R6,A
   \   000032   7427         MOV     A,#0x27
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   E0           MOVX    A,@DPTR
   \   000038   F5..         MOV     ?V0 + 10,A
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   F5..         MOV     ?V0 + 11,A
    819            endPointDesc_t *epDesc;
    820            zclFrameHdr_t hdr;
    821            uint8 *msgBuf;
    822            uint16 msgLen;
    823            uint8 *pBuf;
    824            uint8 options;
    825            ZStatus_t status;
    826          
    827            epDesc = afFindEndPointDesc( srcEP );
   \   00003E                ; Setup parameters for call to function afFindEndPointDesc
   \   00003E   12....       LCALL   ??afFindEndPointDesc?relay
   \   000041   8A..         MOV     ?V0 + 12,R2
   \   000043   8B..         MOV     ?V0 + 13,R3
    828            if ( epDesc == NULL )
   \   000045   EA           MOV     A,R2
   \   000046   45..         ORL     A,?V0 + 13
   \   000048   7005         JNZ     ??zcl_SendCommand_0
    829            {
    830              return ( ZInvalidParameter ); // EMBEDDED RETURN
   \   00004A   7902         MOV     R1,#0x2
   \   00004C   02....       LJMP    ??zcl_SendCommand_1 & 0xFFFF
    831            }
    832          
    833          #if defined ( INTER_PAN )
    834            if ( StubAPS_InterPan( destAddr->panId, destAddr->endPoint ) )
   \                     ??zcl_SendCommand_0:
   \   00004F                ; Setup parameters for call to function StubAPS_InterPan
   \   00004F   85..82       MOV     DPL,?V0 + 14
   \   000052   85..83       MOV     DPH,?V0 + 15
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   F9           MOV     R1,A
   \   000060   85..82       MOV     DPL,?V0 + 14
   \   000063   85..83       MOV     DPH,?V0 + 15
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_304:
   \   00006F   12....       LCALL   ??StubAPS_InterPan?relay
   \   000072   E9           MOV     A,R1
   \   000073   6005         JZ      ??zcl_SendCommand_2
    835            {
    836              options = AF_TX_OPTIONS_NONE;
   \   000075   75..00       MOV     ?V0 + 4,#0x0
   \   000078   803E         SJMP    ??zcl_SendCommand_3
    837            }
    838            else
    839          #endif
    840            {
    841              options = zclGetClusterOption( srcEP, clusterID );
   \                     ??zcl_SendCommand_2:
   \   00007A                ; Setup parameters for call to function zclFindClusterOption
   \   00007A   AA..         MOV     R2,?V0 + 2
   \   00007C   AB..         MOV     R3,?V0 + 3
   \   00007E   A9..         MOV     R1,?V0 + 5
   \   000080   12....       LCALL   ??zclFindClusterOption?relay
   \   000083   8A82         MOV     DPL,R2
   \   000085   8B83         MOV     DPH,R3
   \   000087   E582         MOV     A,DPL
   \   000089   4583         ORL     A,DPH
   \   00008B   6007         JZ      ??zcl_SendCommand_4
   \   00008D   A3           INC     DPTR
   \   00008E   A3           INC     DPTR
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   F5..         MOV     ?V0 + 4,A
   \   000092   8003         SJMP    ??zcl_SendCommand_5
   \                     ??zcl_SendCommand_4:
   \   000094   75..00       MOV     ?V0 + 4,#0x0
    842          
    843              // The cluster might not have been defined to use security but if this message
    844              // is in response to another message that was using APS security this message
    845              // will be sent with APS security
    846              if ( !( options & AF_EN_SECURITY ) )
   \                     ??zcl_SendCommand_5:
   \   000097   E5..         MOV     A,?V0 + 4
   \   000099   A2E6         MOV     C,0xE0 /* A   */.6
   \   00009B   401B         JC      ??zcl_SendCommand_3
    847              {
    848                afIncomingMSGPacket_t *origPkt = zcl_getRawAFMsg();
   \   00009D   90....       MOV     DPTR,#rawAFMsg
   \   0000A0   12....       LCALL   ??Subroutine124_0 & 0xFFFF
    849          
    850                if ( ( origPkt != NULL ) && ( origPkt->SecurityUse == TRUE ) )
   \                     ??CrossCallReturnLabel_194:
   \   0000A3   6013         JZ      ??zcl_SendCommand_3
   \   0000A5   E8           MOV     A,R0
   \   0000A6   2419         ADD     A,#0x19
   \   0000A8   F582         MOV     DPL,A
   \   0000AA   E9           MOV     A,R1
   \   0000AB   12....       LCALL   ??Subroutine117_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_173:
   \   0000AE   6401         XRL     A,#0x1
   \   0000B0   7006         JNZ     ??zcl_SendCommand_3
    851                {
    852                  options |= AF_EN_SECURITY;
   \   0000B2   E5..         MOV     A,?V0 + 4
   \   0000B4   D2E6         SETB    0xE0 /* A   */.6
   \   0000B6   F5..         MOV     ?V0 + 4,A
    853                }
    854              }
    855            }
    856          
    857            zcl_memset( &hdr, 0, sizeof( zclFrameHdr_t ) );
   \                     ??zcl_SendCommand_3:
   \   0000B8                ; Setup parameters for call to function osal_memset
   \   0000B8   7C06         MOV     R4,#0x6
   \   0000BA   7D00         MOV     R5,#0x0
   \   0000BC   7900         MOV     R1,#0x0
   \   0000BE   85..82       MOV     DPL,?XSP + 0
   \   0000C1   85..83       MOV     DPH,?XSP + 1
   \   0000C4   AA82         MOV     R2,DPL
   \   0000C6   AB83         MOV     R3,DPH
   \   0000C8   12....       LCALL   ??osal_memset?relay
    858          
    859            // Not Profile wide command (like READ, WRITE)
    860            if ( specific )
   \   0000CB   E5..         MOV     A,?V0 + 0
   \   0000CD   85..82       MOV     DPL,?XSP + 0
   \   0000D0   85..83       MOV     DPH,?XSP + 1
   \   0000D3   6015         JZ      ??zcl_SendCommand_6
    861            {
    862              hdr.fc.type = ZCL_FRAME_TYPE_SPECIFIC_CMD;
   \   0000D5   E0           MOVX    A,@DPTR
   \   0000D6   54FC         ANL     A,#0xfc
   \   0000D8   F8           MOV     R0,A
   \   0000D9   A3           INC     DPTR
   \   0000DA   E0           MOVX    A,@DPTR
   \   0000DB   F9           MOV     R1,A
   \   0000DC   E8           MOV     A,R0
   \   0000DD   4401         ORL     A,#0x1
   \   0000DF   85..82       MOV     DPL,?XSP + 0
   \   0000E2   85..83       MOV     DPH,?XSP + 1
   \   0000E5   F0           MOVX    @DPTR,A
   \   0000E6   A3           INC     DPTR
   \   0000E7   E9           MOV     A,R1
   \   0000E8   8003         SJMP    ??zcl_SendCommand_7
    863            }
    864            else
    865            {
    866              hdr.fc.type = ZCL_FRAME_TYPE_PROFILE_CMD;
   \                     ??zcl_SendCommand_6:
   \   0000EA   E0           MOVX    A,@DPTR
   \   0000EB   54FC         ANL     A,#0xfc
    867            }
   \                     ??zcl_SendCommand_7:
   \   0000ED   12....       LCALL   ?Subroutine22 & 0xFFFF
    868          
    869            if ( ( epDesc->simpleDesc == NULL ) ||
    870                 ( zcl_DeviceOperational( srcEP, clusterID, hdr.fc.type,
    871                                          cmd, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \                     ??CrossCallReturnLabel_20:
   \   0000F0   12....       LCALL   ??Subroutine124_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_197:
   \   0000F3   602C         JZ      ??zcl_SendCommand_8
   \   0000F5   741E         MOV     A,#0x1e
   \   0000F7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FA   E0           MOVX    A,@DPTR
   \   0000FB   F5..         MOV     ?V0 + 0,A
   \   0000FD                ; Setup parameters for call to function zcl_DeviceOperational
   \   0000FD   8882         MOV     DPL,R0
   \   0000FF   8983         MOV     DPH,R1
   \   000101   A3           INC     DPTR
   \   000102   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000105   AD..         MOV     R5,?V0 + 0
   \   000107   7402         MOV     A,#0x2
   \   000109   12....       LCALL   ?XSTACK_DISP0_8
   \   00010C   E0           MOVX    A,@DPTR
   \   00010D   5403         ANL     A,#0x3
   \   00010F   FC           MOV     R4,A
   \   000110   AA..         MOV     R2,?V0 + 2
   \   000112   AB..         MOV     R3,?V0 + 3
   \   000114   A9..         MOV     R1,?V0 + 5
   \   000116   12....       LCALL   ??zcl_DeviceOperational?relay
   \   000119   7402         MOV     A,#0x2
   \   00011B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00011E   E9           MOV     A,R1
   \   00011F   7005         JNZ     ??zcl_SendCommand_9
    872            {
    873              return ( ZFailure ); // EMBEDDED RETURN
   \                     ??zcl_SendCommand_8:
   \   000121   7901         MOV     R1,#0x1
   \   000123   02....       LJMP    ??zcl_SendCommand_1 & 0xFFFF
    874            }
   \                     ??zcl_SendCommand_9:
   \   000126   7422         MOV     A,#0x22
   \   000128   12....       LCALL   ?XSTACK_DISP0_8
   \   00012B   12....       LCALL   ??Subroutine124_0 & 0xFFFF
    875          
    876            // Fill in the Maufacturer Code
    877            if ( manuCode != 0 )
   \                     ??CrossCallReturnLabel_195:
   \   00012E   6012         JZ      ??CrossCallReturnLabel_241
    878            {
    879              hdr.fc.manuSpecific = 1;
   \   000130   85..82       MOV     DPL,?XSP + 0
   \   000133   85..83       MOV     DPH,?XSP + 1
   \   000136   E0           MOVX    A,@DPTR
   \   000137   4404         ORL     A,#0x4
   \   000139   F0           MOVX    @DPTR,A
    880              hdr.manuCode = manuCode;
   \   00013A   7402         MOV     A,#0x2
   \   00013C   12....       LCALL   ?XSTACK_DISP0_8
   \   00013F   12....       LCALL   ??Subroutine130_0 & 0xFFFF
    881            }
    882          
    883            // Set the Command Direction
    884            if ( direction )
   \                     ??CrossCallReturnLabel_241:
   \   000142   E5..         MOV     A,?V0 + 1
   \   000144   85..82       MOV     DPL,?XSP + 0
   \   000147   85..83       MOV     DPH,?XSP + 1
   \   00014A   6005         JZ      ??zcl_SendCommand_10
    885            {
    886              hdr.fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   00014C   E0           MOVX    A,@DPTR
   \   00014D   4408         ORL     A,#0x8
   \   00014F   8003         SJMP    ??zcl_SendCommand_11
    887            }
    888            else
    889            {
    890              hdr.fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zcl_SendCommand_10:
   \   000151   E0           MOVX    A,@DPTR
   \   000152   54F7         ANL     A,#0xf7
   \                     ??zcl_SendCommand_11:
   \   000154   F0           MOVX    @DPTR,A
    891            }
    892          
    893            // Set the Disable Default Response field
    894            if ( disableDefaultRsp )
   \   000155   EF           MOV     A,R7
   \   000156   6005         JZ      ??zcl_SendCommand_12
    895            {
    896              hdr.fc.disableDefaultRsp = 1;
   \   000158   E0           MOVX    A,@DPTR
   \   000159   4410         ORL     A,#0x10
   \   00015B   8003         SJMP    ??zcl_SendCommand_13
    897            }
    898            else
    899            {
    900              hdr.fc.disableDefaultRsp = 0;
   \                     ??zcl_SendCommand_12:
   \   00015D   E0           MOVX    A,@DPTR
   \   00015E   54EF         ANL     A,#0xef
   \                     ??zcl_SendCommand_13:
   \   000160   F0           MOVX    @DPTR,A
    901            }
    902          
    903            // Fill in the Transaction Sequence Number
    904            hdr.transSeqNum = seqNum;
   \   000161   7404         MOV     A,#0x4
   \   000163   12....       LCALL   ?XSTACK_DISP0_8
   \   000166   EE           MOV     A,R6
   \   000167   F0           MOVX    @DPTR,A
    905          
    906            // Fill in the command
    907            hdr.commandID = cmd;
   \   000168   7405         MOV     A,#0x5
   \   00016A   12....       LCALL   ?XSTACK_DISP0_8
   \   00016D   E5..         MOV     A,?V0 + 0
   \   00016F   F0           MOVX    @DPTR,A
    908          
    909            // calculate the needed buffer size
    910            msgLen = zclCalcHdrSize( &hdr );
   \   000170   75..03       MOV     ?V0 + 0,#0x3
   \   000173   85..82       MOV     DPL,?XSP + 0
   \   000176   85..83       MOV     DPH,?XSP + 1
   \   000179   E0           MOVX    A,@DPTR
   \   00017A   5404         ANL     A,#0x4
   \   00017C   6003         JZ      ??zcl_SendCommand_14
   \   00017E   75..05       MOV     ?V0 + 0,#0x5
   \                     ??zcl_SendCommand_14:
   \   000181   7425         MOV     A,#0x25
   \   000183   12....       LCALL   ?XSTACK_DISP0_8
   \   000186   12....       LCALL   ??Subroutine127_0 & 0xFFFF
    911            msgLen += cmdFormatLen;
   \                     ??CrossCallReturnLabel_218:
   \   000189   E5..         MOV     A,?V0 + 0
   \   00018B   2E           ADD     A,R6
   \   00018C   F5..         MOV     ?V0 + 0,A
   \   00018E   E4           CLR     A
   \   00018F   3F           ADDC    A,R7
   \   000190   F5..         MOV     ?V0 + 1,A
    912          
    913            // Allocate the buffer needed
    914            msgBuf = zcl_mem_alloc( msgLen );
   \   000192                ; Setup parameters for call to function osal_mem_alloc
   \   000192   AA..         MOV     R2,?V0 + 0
   \   000194   FB           MOV     R3,A
   \   000195   12....       LCALL   ??osal_mem_alloc?relay
   \   000198   8A..         MOV     ?V0 + 6,R2
   \   00019A   8B..         MOV     ?V0 + 7,R3
    915            if ( msgBuf != NULL )
   \   00019C   EA           MOV     A,R2
   \   00019D   45..         ORL     A,?V0 + 7
   \   00019F   6069         JZ      ??zcl_SendCommand_15
    916            {
    917              // Fill in the ZCL Header
    918              pBuf = zclBuildHdr( &hdr, msgBuf );
    919          
    920              // Fill in the command frame
    921              zcl_memcpy( pBuf, cmdFormat, cmdFormatLen );
   \   0001A1                ; Setup parameters for call to function osal_memcpy
   \   0001A1   85....       MOV     ?V0 + 8,?V0 + 10
   \   0001A4   85....       MOV     ?V0 + 9,?V0 + 11
   \   0001A7   75..00       MOV     ?V0 + 10,#0x0
   \   0001AA   78..         MOV     R0,#?V0 + 8
   \   0001AC   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0001AF                ; Setup parameters for call to function zclBuildHdr
   \   0001AF   AC..         MOV     R4,?V0 + 6
   \   0001B1   AD..         MOV     R5,?V0 + 7
   \   0001B3   7403         MOV     A,#0x3
   \   0001B5   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B8   AA82         MOV     R2,DPL
   \   0001BA   AB83         MOV     R3,DPH
   \   0001BC   12....       LCALL   ??zclBuildHdr?relay
   \   0001BF   EE           MOV     A,R6
   \   0001C0   FC           MOV     R4,A
   \   0001C1   EF           MOV     A,R7
   \   0001C2   FD           MOV     R5,A
   \   0001C3   12....       LCALL   ??osal_memcpy?relay
   \   0001C6   7403         MOV     A,#0x3
   \   0001C8   12....       LCALL   ?DEALLOC_XSTACK8
    922          
    923              status = AF_DataRequest( destAddr, epDesc, clusterID, msgLen, msgBuf,
    924                                       &zcl_TransID, options, AF_DEFAULT_RADIUS );
   \   0001CB                ; Setup parameters for call to function AF_DataRequest
   \   0001CB   75..1E       MOV     ?V0 + 8,#0x1e
   \   0001CE   78..         MOV     R0,#?V0 + 8
   \   0001D0   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001D3   75....       MOV     ?V0 + 8,#zcl_TransID & 0xff
   \   0001D6   75....       MOV     ?V0 + 9,#(zcl_TransID >> 8) & 0xff
   \   0001D9   78..         MOV     R0,#?V0 + 8
   \   0001DB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001DE   78..         MOV     R0,#?V0 + 6
   \   0001E0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001E3   78..         MOV     R0,#?V0 + 0
   \   0001E5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001E8   78..         MOV     R0,#?V0 + 2
   \   0001EA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001ED   A9..         MOV     R1,?V0 + 4
   \   0001EF   AC..         MOV     R4,?V0 + 12
   \   0001F1   AD..         MOV     R5,?V0 + 13
   \   0001F3   AA..         MOV     R2,?V0 + 14
   \   0001F5   AB..         MOV     R3,?V0 + 15
   \   0001F7   12....       LCALL   ??AF_DataRequest?relay
   \   0001FA   7409         MOV     A,#0x9
   \   0001FC   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001FF   E9           MOV     A,R1
   \   000200   FE           MOV     R6,A
    925              zcl_mem_free ( msgBuf );
   \   000201                ; Setup parameters for call to function osal_mem_free
   \   000201   AA..         MOV     R2,?V0 + 6
   \   000203   AB..         MOV     R3,?V0 + 7
   \   000205   12....       LCALL   ??osal_mem_free?relay
   \   000208   8002         SJMP    ??zcl_SendCommand_16
    926            }
    927            else
    928            {
    929              status = ZMemError;
   \                     ??zcl_SendCommand_15:
   \   00020A   7E10         MOV     R6,#0x10
    930            }
    931          
    932            return ( status );
   \                     ??zcl_SendCommand_16:
   \   00020C   EE           MOV     A,R6
   \   00020D   F9           MOV     R1,A
   \                     ??zcl_SendCommand_1:
   \   00020E   7406         MOV     A,#0x6
   \   000210   02....       LJMP    ?Subroutine4 & 0xFFFF
    933          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine124_0:
   \   000000   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_290:
   \   000003   E8           MOV     A,R0
   \   000004   49           ORL     A,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine130_0:
   \   000000   E8           MOV     A,R0
   \   000001                REQUIRE ??Subroutine131_0
   \   000001                ; // Fall through to label ??Subroutine131_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine131_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine132_0
   \   000003                ; // Fall through to label ??Subroutine132_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine132_0:
   \   000000   7F10         MOV     R7,#0x10
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine138_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine139_0
   \   000001                ; // Fall through to label ??Subroutine139_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine139_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine140_0
   \   000003                ; // Fall through to label ??Subroutine140_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V0 + 12
   \   000004   85..83       MOV     DPH,?V0 + 13
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine99:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET
    934          
    935          #ifdef ZCL_READ
    936          /*********************************************************************
    937           * @fn      zcl_SendRead
    938           *
    939           * @brief   Send a Read command
    940           *
    941           * @param   srcEP - Application's endpoint
    942           * @param   dstAddr - destination address
    943           * @param   clusterID - cluster ID
    944           * @param   readCmd - read command to be sent
    945           * @param   direction - direction of the command
    946           * @param   seqNum - transaction sequence number
    947           *
    948           * @return  ZSuccess if OK
    949           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    950          ZStatus_t zcl_SendRead( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendRead:
    951                                  uint16 clusterID, zclReadCmd_t *readCmd,
    952                                  uint8 direction, uint8 disableDefaultRsp, uint8 seqNum)
    953          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 2,R1
   \   000007   8A..         MOV     ?V0 + 12,R2
   \   000009   8B..         MOV     ?V0 + 13,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7418         MOV     A,#0x18
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V0 + 3,A
   \   000017   7419         MOV     A,#0x19
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F5..         MOV     ?V0 + 8,A
   \   00001F   741A         MOV     A,#0x1a
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   E0           MOVX    A,@DPTR
   \   000025   F5..         MOV     ?V0 + 9,A
   \   000027   7416         MOV     A,#0x16
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   12....       LCALL   ?Subroutine51 & 0xFFFF
    954            uint16 dataLen;
    955            uint8 *buf;
    956            uint8 *pBuf;
    957            ZStatus_t status;
    958          
    959            dataLen = readCmd->numAttr * 2; // Attribute ID
   \                     ??CrossCallReturnLabel_59:
   \   00002F   C3           CLR     C
   \   000030   33           RLC     A
   \   000031   F5..         MOV     ?V0 + 6,A
   \   000033   E4           CLR     A
   \   000034   33           RLC     A
   \   000035   F5..         MOV     ?V0 + 7,A
    960          
    961            buf = zcl_mem_alloc( dataLen );
   \   000037                ; Setup parameters for call to function osal_mem_alloc
   \   000037   AA..         MOV     R2,?V0 + 6
   \   000039   FB           MOV     R3,A
   \   00003A   12....       LCALL   ??osal_mem_alloc?relay
   \   00003D   8A..         MOV     ?V0 + 0,R2
   \   00003F   8B..         MOV     ?V0 + 1,R3
    962            if ( buf != NULL )
   \   000041   EA           MOV     A,R2
   \   000042   45..         ORL     A,?V0 + 1
   \   000044   7003         JNZ     $+5
   \   000046   02....       LJMP    ??zcl_SendRead_0 & 0xFFFF
    963            {
    964              uint8 i;
    965          
    966              // Load the buffer - serially
    967              pBuf = buf;
   \   000049   A8..         MOV     R0,?V0 + 0
   \   00004B   A9..         MOV     R1,?V0 + 1
    968              for (i = 0; i < readCmd->numAttr; i++)
   \   00004D   75..00       MOV     ?V0 + 10,#0x0
   \   000050   8023         SJMP    ??zcl_SendRead_1
    969              {
    970                *pBuf++ = LO_UINT16( readCmd->attrID[i] );
   \                     ??zcl_SendRead_2:
   \   000052   E5..         MOV     A,?V0 + 10
   \   000054   C3           CLR     C
   \   000055   33           RLC     A
   \   000056   FA           MOV     R2,A
   \   000057   E4           CLR     A
   \   000058   33           RLC     A
   \   000059   FB           MOV     R3,A
   \   00005A   E5..         MOV     A,?V0 + 4
   \   00005C   2A           ADD     A,R2
   \   00005D   F582         MOV     DPL,A
   \   00005F   E5..         MOV     A,?V0 + 5
   \   000061   3B           ADDC    A,R3
   \   000062   F583         MOV     DPH,A
   \   000064   A3           INC     DPTR
   \   000065   AA82         MOV     R2,DPL
   \   000067   AB83         MOV     R3,DPH
   \   000069   12....       LCALL   ?Subroutine60 & 0xFFFF
    971                *pBuf++ = HI_UINT16( readCmd->attrID[i] );
   \                     ??CrossCallReturnLabel_72:
   \   00006C   8A82         MOV     DPL,R2
   \   00006E   8B83         MOV     DPH,R3
   \   000070   12....       LCALL   ?Subroutine43 & 0xFFFF
    972              }
   \                     ??CrossCallReturnLabel_154:
   \   000073   05..         INC     ?V0 + 10
   \                     ??zcl_SendRead_1:
   \   000075   85..82       MOV     DPL,?V0 + 4
   \   000078   85..83       MOV     DPH,?V0 + 5
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   FA           MOV     R2,A
   \   00007D   E5..         MOV     A,?V0 + 10
   \   00007F   C3           CLR     C
   \   000080   9A           SUBB    A,R2
   \   000081   40CF         JC      ??zcl_SendRead_2
    973          
    974              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ, FALSE,
    975                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000083                ; Setup parameters for call to function zcl_SendCommand
   \   000083   78..         MOV     R0,#?V0 + 0
   \   000085   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000088   78..         MOV     R0,#?V0 + 6
   \   00008A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008D   E5..         MOV     A,?V0 + 9
   \   00008F   F5..         MOV     ?V0 + 4,A
   \   000091   78..         MOV     R0,#?V0 + 4
   \   000093   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000096   E4           CLR     A
   \   000097   F5..         MOV     ?V0 + 4,A
   \   000099   F5..         MOV     ?V0 + 5,A
   \   00009B   78..         MOV     R0,#?V0 + 4
   \   00009D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A0   E5..         MOV     A,?V0 + 8
   \   0000A2   F5..         MOV     ?V0 + 4,A
   \   0000A4   78..         MOV     R0,#?V0 + 4
   \   0000A6   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A9   78..         MOV     R0,#?V0 + 3
   \   0000AB   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AE   75..00       MOV     ?V0 + 3,#0x0
   \   0000B1   78..         MOV     R0,#?V0 + 3
   \   0000B3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B6   78..         MOV     R0,#?V0 + 3
   \   0000B8   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000BB   EE           MOV     A,R6
   \   0000BC   FC           MOV     R4,A
   \   0000BD   EF           MOV     A,R7
   \   0000BE   FD           MOV     R5,A
   \   0000BF   AA..         MOV     R2,?V0 + 12
   \   0000C1   AB..         MOV     R3,?V0 + 13
   \   0000C3   A9..         MOV     R1,?V0 + 2
   \   0000C5   12....       LCALL   ??zcl_SendCommand?relay
   \   0000C8   740B         MOV     A,#0xb
   \   0000CA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000CD   E9           MOV     A,R1
   \   0000CE   FE           MOV     R6,A
    976              zcl_mem_free( buf );
   \   0000CF                ; Setup parameters for call to function osal_mem_free
   \   0000CF   AA..         MOV     R2,?V0 + 0
   \   0000D1   AB..         MOV     R3,?V0 + 1
   \   0000D3   12....       LCALL   ??osal_mem_free?relay
   \   0000D6   8002         SJMP    ??zcl_SendRead_3
    977            }
    978            else
    979            {
    980              status = ZMemError;
   \                     ??zcl_SendRead_0:
   \   0000D8   7E10         MOV     R6,#0x10
    981            }
    982          
    983            return ( status );
   \                     ??zcl_SendRead_3:
   \   0000DA                REQUIRE ?Subroutine9
   \   0000DA                ; // Fall through to label ?Subroutine9
    984          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002   80..         SJMP    ??Subroutine113_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine112_0
   \   000001                ; // Fall through to label ??Subroutine112_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine112_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   08           INC     R0
   \   000008   A983         MOV     R1,DPH
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine113_0:
   \   000000   7F0E         MOV     R7,#0xe
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   A882         MOV     R0,DPL
   \   000009   A983         MOV     R1,DPH
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_129:
   \   000003   85..82       MOV     DPL,?V0 + 4
   \   000006   F583         MOV     DPH,A
   \   000008   E0           MOVX    A,@DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine92:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 5,A
   \   000007   22           RET
    985          
    986          /*********************************************************************
    987           * @fn      zcl_SendReadRsp
    988           *
    989           * @brief   Send a Read Response command.
    990           *
    991           * @param   srcEP - Application's endpoint
    992           * @param   dstAddr - destination address
    993           * @param   clusterID - cluster ID
    994           * @param   readRspCmd - read response command to be sent
    995           * @param   direction - direction of the command
    996           * @param   seqNum - transaction sequence number
    997           *
    998           * @return  ZSuccess if OK
    999           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1000          ZStatus_t zcl_SendReadRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadRsp:
   1001                                     uint16 clusterID, zclReadRspCmd_t *readRspCmd,
   1002                                     uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1003          {
   \   000000   74E9         MOV     A,#-0x17
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 23
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
   \   000014   89..         MOV     ?V0 + 3,R1
   \   000016   8C..         MOV     ?V0 + 6,R4
   \   000018   8D..         MOV     ?V0 + 7,R5
   \   00001A   741D         MOV     A,#0x1d
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F5..         MOV     ?V0 + 14,A
   \   000022   741E         MOV     A,#0x1e
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   E0           MOVX    A,@DPTR
   \   000028   F5..         MOV     ?V0 + 13,A
   \   00002A   741F         MOV     A,#0x1f
   \   00002C   12....       LCALL   ?XSTACK_DISP0_8
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   F5..         MOV     ?V0 + 12,A
   1004            uint8 *buf;
   1005            uint16 len = 0;
   \   000032   7E00         MOV     R6,#0x0
   \   000034   7F00         MOV     R7,#0x0
   1006            ZStatus_t status;
   1007            uint8 i;
   1008          
   1009            // calculate the size of the command
   1010            for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   000036   8E..         MOV     ?V0 + 2,R6
   \   000038   741B         MOV     A,#0x1b
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_315:
   \   000040   800B         SJMP    ??zcl_SendReadRsp_0
   1011            {
   1012              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   1013          
   1014              len += 2 + 1; // Attribute ID + Status
   1015          
   1016              if ( statusRec->status == ZCL_STATUS_SUCCESS )
   1017              {
   1018                len++; // Attribute Data Type length
   1019          
   1020                // Attribute Data length
   1021                if ( statusRec->data != NULL )
   1022                {
   1023                  len += zclGetAttrDataLength( statusRec->dataType, statusRec->data );
   1024                }
   1025                else
   1026                {
   1027                  len += zclGetAttrDataLengthUsingCB( srcEP, clusterID, statusRec->attrID );
   \                     ??zcl_SendReadRsp_1:
   \   000042                ; Setup parameters for call to function zclGetAttrDataLengthUsingCB
   \   000042   12....       LCALL   ?Subroutine55 & 0xFFFF
   1028                }
   \                     ??CrossCallReturnLabel_65:
   \   000045   12....       LCALL   ??zclGetAttrDataLengthUsingCB?relay
   \                     ??zcl_SendReadRsp_2:
   \   000048   12....       LCALL   ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_158:
   \   00004B   05..         INC     ?V0 + 2
   \                     ??zcl_SendReadRsp_0:
   \   00004D   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_238:
   \   000050   5043         JNC     ??zcl_SendReadRsp_3
   \   000052   E5..         MOV     A,?V0 + 2
   \   000054   75F006       MOV     B,#0x6
   \   000057   A4           MUL     AB
   \   000058   F8           MOV     R0,A
   \   000059   A9F0         MOV     R1,B
   \   00005B   E5..         MOV     A,?V0 + 8
   \   00005D   28           ADD     A,R0
   \   00005E   F582         MOV     DPL,A
   \   000060   E5..         MOV     A,?V0 + 9
   \   000062   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_109:
   \   000065   EE           MOV     A,R6
   \   000066   2403         ADD     A,#0x3
   \   000068   FE           MOV     R6,A
   \   000069   EF           MOV     A,R7
   \   00006A   3400         ADDC    A,#0x0
   \   00006C   FF           MOV     R7,A
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   70D9         JNZ     ??CrossCallReturnLabel_158
   \   000072   EE           MOV     A,R6
   \   000073   2401         ADD     A,#0x1
   \   000075   0E           INC     R6
   \   000076   EF           MOV     A,R7
   \   000077   3400         ADDC    A,#0x0
   \   000079   FF           MOV     R7,A
   \   00007A   8882         MOV     DPL,R0
   \   00007C   8983         MOV     DPH,R1
   \   00007E   A3           INC     DPTR
   \   00007F   A3           INC     DPTR
   \   000080   A3           INC     DPTR
   \   000081   A3           INC     DPTR
   \   000082   12....       LCALL   ??Subroutine116_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_169:
   \   000085   8882         MOV     DPL,R0
   \   000087   8983         MOV     DPH,R1
   \   000089   60B7         JZ      ??zcl_SendReadRsp_1
   \   00008B                ; Setup parameters for call to function zclGetAttrDataLength
   \   00008B   A3           INC     DPTR
   \   00008C   A3           INC     DPTR
   \   00008D   A3           INC     DPTR
   \   00008E   E0           MOVX    A,@DPTR
   \   00008F   F9           MOV     R1,A
   \   000090   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000093   80B3         SJMP    ??zcl_SendReadRsp_2
   1029              }
   1030            }
   1031          
   1032            buf = zcl_mem_alloc( len );
   \                     ??zcl_SendReadRsp_3:
   \   000095                ; Setup parameters for call to function osal_mem_alloc
   \   000095   EE           MOV     A,R6
   \   000096   FA           MOV     R2,A
   \   000097   EF           MOV     A,R7
   \   000098   FB           MOV     R3,A
   \   000099   12....       LCALL   ??osal_mem_alloc?relay
   \   00009C   8A..         MOV     ?V0 + 0,R2
   \   00009E   8B..         MOV     ?V0 + 1,R3
   \   0000A0   8A..         MOV     ?V0 + 4,R2
   \   0000A2   8B..         MOV     ?V0 + 5,R3
   1033            if ( buf != NULL )
   \   0000A4   EA           MOV     A,R2
   \   0000A5   45..         ORL     A,?V0 + 5
   \   0000A7   7003         JNZ     $+5
   \   0000A9   02....       LJMP    ??zcl_SendReadRsp_4 & 0xFFFF
   1034            {
   1035              // Load the buffer - serially
   1036              uint8 *pBuf = buf;
   1037          
   1038              for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   0000AC   75..00       MOV     ?V0 + 2,#0x0
   \   0000AF   803A         SJMP    ??zcl_SendReadRsp_5
   1039              {
   1040                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   1041          
   1042                *pBuf++ = LO_UINT16( statusRec->attrID );
   1043                *pBuf++ = HI_UINT16( statusRec->attrID );
   1044                *pBuf++ = statusRec->status;
   1045          
   1046                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   1047                {
   1048                  *pBuf++ = statusRec->dataType;
   1049          
   1050                  if ( statusRec->data != NULL )
   1051                  {
   1052                    // Copy attribute data to the buffer to be sent out
   1053                    pBuf = zclSerializeData( statusRec->dataType, statusRec->data, pBuf );
   1054                  }
   1055                  else
   1056                  {
   1057                    uint16 dataLen;
   1058          
   1059                    // Read attribute data directly into the buffer to be sent out
   1060                    zclReadAttrDataUsingCB( srcEP, clusterID, statusRec->attrID, pBuf, &dataLen );
   \                     ??zcl_SendReadRsp_6:
   \   0000B1                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   0000B1   85..82       MOV     DPL,?XSP + 0
   \   0000B4   85..83       MOV     DPH,?XSP + 1
   \   0000B7   8582..       MOV     ?V0 + 10,DPL
   \   0000BA   8583..       MOV     ?V0 + 11,DPH
   \   0000BD   78..         MOV     R0,#?V0 + 10
   \   0000BF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C2   78..         MOV     R0,#?V0 + 0
   \   0000C4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C7   8A82         MOV     DPL,R2
   \   0000C9   8B83         MOV     DPH,R3
   \   0000CB   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   0000CE   12....       LCALL   ??zclReadAttrDataUsingCB?relay
   \   0000D1   7404         MOV     A,#0x4
   \   0000D3   12....       LCALL   ?DEALLOC_XSTACK8
   1061                    pBuf += dataLen;
   \   0000D6   85..82       MOV     DPL,?XSP + 0
   \   0000D9   85..83       MOV     DPH,?XSP + 1
   \   0000DC   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   1062                  }
   \                     ??CrossCallReturnLabel_277:
   \   0000DF   E5..         MOV     A,?V0 + 0
   \   0000E1   28           ADD     A,R0
   \   0000E2   F5..         MOV     ?V0 + 0,A
   \   0000E4   E5..         MOV     A,?V0 + 1
   \   0000E6   39           ADDC    A,R1
   \   0000E7   F5..         MOV     ?V0 + 1,A
   \                     ??zcl_SendReadRsp_7:
   \   0000E9   05..         INC     ?V0 + 2
   \                     ??zcl_SendReadRsp_5:
   \   0000EB   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_239:
   \   0000EE   5058         JNC     ??zcl_SendReadRsp_8
   \   0000F0   E5..         MOV     A,?V0 + 2
   \   0000F2   75F006       MOV     B,#0x6
   \   0000F5   A4           MUL     AB
   \   0000F6   F8           MOV     R0,A
   \   0000F7   A9F0         MOV     R1,B
   \   0000F9   E5..         MOV     A,?V0 + 8
   \   0000FB   28           ADD     A,R0
   \   0000FC   F582         MOV     DPL,A
   \   0000FE   E5..         MOV     A,?V0 + 9
   \   000100   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   000103   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000106   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   000109   EA           MOV     A,R2
   \   00010A   2402         ADD     A,#0x2
   \   00010C   F8           MOV     R0,A
   \   00010D   12....       LCALL   ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_160:
   \   000110   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   000113   8882         MOV     DPL,R0
   \   000115   8983         MOV     DPH,R1
   \   000117   E0           MOVX    A,@DPTR
   \   000118   70CF         JNZ     ??zcl_SendReadRsp_7
   \   00011A   EA           MOV     A,R2
   \   00011B   2403         ADD     A,#0x3
   \   00011D   08           INC     R0
   \   00011E   12....       LCALL   ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_161:
   \   000121   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000124   12....       LCALL   ??Subroutine142_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_328:
   \   000127   8C82         MOV     DPL,R4
   \   000129   8D83         MOV     DPH,R5
   \   00012B   E582         MOV     A,DPL
   \   00012D   4583         ORL     A,DPH
   \   00012F   6080         JZ      ??zcl_SendReadRsp_6
   \   000131                ; Setup parameters for call to function zclSerializeData
   \   000131   AC..         MOV     R4,?V0 + 0
   \   000133   AD..         MOV     R5,?V0 + 1
   \   000135   AA82         MOV     R2,DPL
   \   000137   AB83         MOV     R3,DPH
   \   000139   8882         MOV     DPL,R0
   \   00013B   8983         MOV     DPH,R1
   \   00013D   E0           MOVX    A,@DPTR
   \   00013E   F9           MOV     R1,A
   \   00013F   12....       LCALL   ??zclSerializeData?relay
   \   000142   8A..         MOV     ?V0 + 0,R2
   \   000144   8B..         MOV     ?V0 + 1,R3
   \   000146   80A1         SJMP    ??zcl_SendReadRsp_7
   1063                }
   1064              } // for loop
   1065          
   1066              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_RSP, FALSE,
   1067                                        direction, disableDefaultRsp, 0, seqNum, len, buf );
   \                     ??zcl_SendReadRsp_8:
   \   000148                ; Setup parameters for call to function zcl_SendCommand
   \   000148   78..         MOV     R0,#?V0 + 4
   \   00014A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00014D   8E..         MOV     ?V0 + 0,R6
   \   00014F   8F..         MOV     ?V0 + 1,R7
   \   000151   78..         MOV     R0,#?V0 + 0
   \   000153   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000156   E5..         MOV     A,?V0 + 12
   \   000158   F5..         MOV     ?V0 + 0,A
   \   00015A   78..         MOV     R0,#?V0 + 0
   \   00015C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00015F   E4           CLR     A
   \   000160   F5..         MOV     ?V0 + 0,A
   \   000162   F5..         MOV     ?V0 + 1,A
   \   000164   78..         MOV     R0,#?V0 + 0
   \   000166   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000169   E5..         MOV     A,?V0 + 13
   \   00016B   F5..         MOV     ?V0 + 0,A
   \   00016D   78..         MOV     R0,#?V0 + 0
   \   00016F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000172   E5..         MOV     A,?V0 + 14
   \   000174   F5..         MOV     ?V0 + 0,A
   \   000176   78..         MOV     R0,#?V0 + 0
   \   000178   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00017B   75..00       MOV     ?V0 + 0,#0x0
   \   00017E   78..         MOV     R0,#?V0 + 0
   \   000180   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000183   75..01       MOV     ?V0 + 0,#0x1
   \   000186   78..         MOV     R0,#?V0 + 0
   \   000188   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00018B   AC..         MOV     R4,?V0 + 6
   \   00018D   AD..         MOV     R5,?V0 + 7
   \   00018F   740D         MOV     A,#0xd
   \   000191   12....       LCALL   ?XSTACK_DISP0_8
   \   000194   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_293:
   \   000197   A9..         MOV     R1,?V0 + 3
   \   000199   12....       LCALL   ??zcl_SendCommand?relay
   \   00019C   740B         MOV     A,#0xb
   \   00019E   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001A1   E9           MOV     A,R1
   \   0001A2   FE           MOV     R6,A
   1068              zcl_mem_free( buf );
   \   0001A3                ; Setup parameters for call to function osal_mem_free
   \   0001A3   AA..         MOV     R2,?V0 + 4
   \   0001A5   AB..         MOV     R3,?V0 + 5
   \   0001A7   12....       LCALL   ??osal_mem_free?relay
   \   0001AA   8002         SJMP    ??zcl_SendReadRsp_9
   1069            }
   1070            else
   1071            {
   1072              status = ZMemError;
   \                     ??zcl_SendReadRsp_4:
   \   0001AC   7E10         MOV     R6,#0x10
   1073            }
   1074          
   1075            return ( status );
   \                     ??zcl_SendReadRsp_9:
   \   0001AE   EE           MOV     A,R6
   \   0001AF   F9           MOV     R1,A
   \   0001B0   7404         MOV     A,#0x4
   \   0001B2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001B5   7F0F         MOV     R7,#0xf
   \   0001B7   02....       LJMP    ?BANKED_LEAVE_XDATA
   1076          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine105:
   \   000000   8A..         MOV     ?V0 + 0,R2
   \   000002   8B..         MOV     ?V0 + 1,R3
   \   000004                REQUIRE ??Subroutine114_0
   \   000004                ; // Fall through to label ??Subroutine114_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine114_0:
   \   000000   EE           MOV     A,R6
   \   000001   25..         ADD     A,?V0 + 0
   \   000003   FE           MOV     R6,A
   \   000004   EF           MOV     A,R7
   \   000005   35..         ADDC    A,?V0 + 1
   \   000007   FF           MOV     R7,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000   EB           MOV     A,R3
   \   000001                REQUIRE ??Subroutine115_0
   \   000001                ; // Fall through to label ??Subroutine115_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   12....       LCALL   ??Subroutine145_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_331:
   \   000003   AA..         MOV     R2,?V0 + 6
   \   000005   AB..         MOV     R3,?V0 + 7
   \   000007   A9..         MOV     R1,?V0 + 3
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_126:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine89:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V0 + 0
   \   000004   85..83       MOV     DPH,?V0 + 1
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   8582..       MOV     ?V0 + 0,DPL
   \   00000C   8583..       MOV     ?V0 + 1,DPH
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_125:
   \   000003   8A82         MOV     DPL,R2
   \   000005   8B83         MOV     DPH,R3
   \   000007   A3           INC     DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine80:
   \   000000   39           ADDC    A,R1
   \   000001   F583         MOV     DPH,A
   \   000003   A3           INC     DPTR
   \   000004   A882         MOV     R0,DPL
   \   000006   A983         MOV     R1,DPH
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine78:
   \   000000   39           ADDC    A,R1
   \   000001   F583         MOV     DPH,A
   \   000003   A3           INC     DPTR
   \   000004   AA82         MOV     R2,DPL
   \   000006   AB83         MOV     R3,DPH
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   85..82       MOV     DPL,?V0 + 8
   \   000003   85..83       MOV     DPH,?V0 + 9
   \   000006                REQUIRE ??Subroutine129_0
   \   000006                ; // Fall through to label ??Subroutine129_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine129_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   E5..         MOV     A,?V0 + 2
   \   000004   C3           CLR     C
   \   000005   98           SUBB    A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine137_0:
   \   000000   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_291:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine141_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 8,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 9,A
   \   000007   22           RET
   1077          #endif // ZCL_READ
   1078          
   1079          #ifdef ZCL_WRITE
   1080          /*********************************************************************
   1081           * @fn      sendWriteRequest
   1082           *
   1083           * @brief   Send a Write command
   1084           *
   1085           * @param   dstAddr - destination address
   1086           * @param   clusterID - cluster ID
   1087           * @param   writeCmd - write command to be sent
   1088           * @param   cmd - ZCL_CMD_WRITE, ZCL_CMD_WRITE_UNDIVIDED or ZCL_CMD_WRITE_NO_RSP
   1089           * @param   direction - direction of the command
   1090           * @param   seqNum - transaction sequence number
   1091           *
   1092           * @return  ZSuccess if OK
   1093           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1094          ZStatus_t zcl_SendWriteRequest( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendWriteRequest:
   1095                                          zclWriteCmd_t *writeCmd, uint8 cmd, uint8 direction,
   1096                                          uint8 disableDefaultRsp, uint8 seqNum )
   1097          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 11,R1
   \   000007   8A..         MOV     ?V0 + 14,R2
   \   000009   8B..         MOV     ?V0 + 15,R3
   \   00000B   8C..         MOV     ?V0 + 12,R4
   \   00000D   8D..         MOV     ?V0 + 13,R5
   \   00000F   741A         MOV     A,#0x1a
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V0 + 10,A
   \   000017   741B         MOV     A,#0x1b
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F5..         MOV     ?V0 + 7,A
   \   00001F   741C         MOV     A,#0x1c
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   E0           MOVX    A,@DPTR
   \   000025   F5..         MOV     ?V0 + 6,A
   \   000027   741D         MOV     A,#0x1d
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F5..         MOV     ?V0 + 3,A
   1098            uint8 *buf;
   1099            uint16 dataLen = 0;
   \   00002F   7E00         MOV     R6,#0x0
   \   000031   7F00         MOV     R7,#0x0
   1100            ZStatus_t status;
   1101            uint8 i;
   1102          
   1103            for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000033   8E..         MOV     ?V0 + 2,R6
   \   000035   7418         MOV     A,#0x18
   \   000037   12....       LCALL   ?XSTACK_DISP0_8
   \   00003A   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   00003D   802E         SJMP    ??zcl_SendWriteRequest_0
   1104            {
   1105              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_1:
   \   00003F   E5..         MOV     A,?V0 + 2
   \   000041   75F005       MOV     B,#0x5
   \   000044   A4           MUL     AB
   \   000045   F8           MOV     R0,A
   \   000046   A9F0         MOV     R1,B
   \   000048   E5..         MOV     A,?V0 + 4
   \   00004A   28           ADD     A,R0
   \   00004B   F582         MOV     DPL,A
   \   00004D   E5..         MOV     A,?V0 + 5
   \   00004F   12....       LCALL   ?Subroutine80 & 0xFFFF
   1106          
   1107              dataLen += 2 + 1; // Attribute ID + Attribute Type
   1108          
   1109              // Attribute Data
   1110              dataLen += zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
   \                     ??CrossCallReturnLabel_110:
   \   000052                ; Setup parameters for call to function zclGetAttrDataLength
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   12....       LCALL   ?Subroutine57 & 0xFFFF
   1111            }
   \                     ??CrossCallReturnLabel_67:
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F9           MOV     R1,A
   \   00005A   12....       LCALL   ??zclGetAttrDataLength?relay
   \   00005D   EA           MOV     A,R2
   \   00005E   2403         ADD     A,#0x3
   \   000060   F8           MOV     R0,A
   \   000061   EB           MOV     A,R3
   \   000062   3400         ADDC    A,#0x0
   \   000064   F9           MOV     R1,A
   \   000065   EE           MOV     A,R6
   \   000066   28           ADD     A,R0
   \   000067   FE           MOV     R6,A
   \   000068   EF           MOV     A,R7
   \   000069   39           ADDC    A,R1
   \   00006A   FF           MOV     R7,A
   \   00006B   05..         INC     ?V0 + 2
   \                     ??zcl_SendWriteRequest_0:
   \   00006D   85..82       MOV     DPL,?V0 + 4
   \   000070   85..83       MOV     DPH,?V0 + 5
   \   000073   12....       LCALL   ??Subroutine129_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_235:
   \   000076   40C7         JC      ??zcl_SendWriteRequest_1
   1112          
   1113            buf = zcl_mem_alloc( dataLen );
   \   000078                ; Setup parameters for call to function osal_mem_alloc
   \   000078   EE           MOV     A,R6
   \   000079   FA           MOV     R2,A
   \   00007A   EF           MOV     A,R7
   \   00007B   FB           MOV     R3,A
   \   00007C   12....       LCALL   ??osal_mem_alloc?relay
   \   00007F   8A..         MOV     ?V0 + 0,R2
   \   000081   8B..         MOV     ?V0 + 1,R3
   1114            if ( buf != NULL )
   \   000083   EA           MOV     A,R2
   \   000084   45..         ORL     A,?V0 + 1
   \   000086   7003         JNZ     $+5
   \   000088   02....       LJMP    ??zcl_SendWriteRequest_2 & 0xFFFF
   1115            {
   1116              // Load the buffer - serially
   1117              uint8 *pBuf = buf;
   \   00008B   AC..         MOV     R4,?V0 + 0
   \   00008D   AD..         MOV     R5,?V0 + 1
   1118              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   00008F   75..00       MOV     ?V0 + 2,#0x0
   \   000092   8036         SJMP    ??zcl_SendWriteRequest_3
   1119              {
   1120                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_4:
   \   000094   E5..         MOV     A,?V0 + 2
   \   000096   75F005       MOV     B,#0x5
   \   000099   A4           MUL     AB
   \   00009A   F8           MOV     R0,A
   \   00009B   A9F0         MOV     R1,B
   \   00009D   E5..         MOV     A,?V0 + 4
   \   00009F   28           ADD     A,R0
   \   0000A0   F582         MOV     DPL,A
   \   0000A2   E5..         MOV     A,?V0 + 5
   \   0000A4   12....       LCALL   ?Subroutine78 & 0xFFFF
   1121          
   1122                *pBuf++ = LO_UINT16( statusRec->attrID );
   \                     ??CrossCallReturnLabel_105:
   \   0000A7   12....       LCALL   ?Subroutine19 & 0xFFFF
   1123                *pBuf++ = HI_UINT16( statusRec->attrID );
   \                     ??CrossCallReturnLabel_14:
   \   0000AA   12....       LCALL   ??Subroutine120_0 & 0xFFFF
   1124                *pBuf++ = statusRec->dataType;
   \                     ??CrossCallReturnLabel_183:
   \   0000AD   12....       LCALL   ?Subroutine26 & 0xFFFF
   1125          
   1126                pBuf = zclSerializeData( statusRec->dataType, statusRec->attrData, pBuf );
   \                     ??CrossCallReturnLabel_185:
   \   0000B0                ; Setup parameters for call to function zclSerializeData
   \   0000B0   8A82         MOV     DPL,R2
   \   0000B2   8B83         MOV     DPH,R3
   \   0000B4   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   1127              }
   \                     ??CrossCallReturnLabel_302:
   \   0000B7   8882         MOV     DPL,R0
   \   0000B9   8983         MOV     DPH,R1
   \   0000BB   E0           MOVX    A,@DPTR
   \   0000BC   F9           MOV     R1,A
   \   0000BD   12....       LCALL   ??zclSerializeData?relay
   \   0000C0   8A..         MOV     ?V0 + 8,R2
   \   0000C2   8B..         MOV     ?V0 + 9,R3
   \   0000C4   AC..         MOV     R4,?V0 + 8
   \   0000C6   AD..         MOV     R5,?V0 + 9
   \   0000C8   05..         INC     ?V0 + 2
   \                     ??zcl_SendWriteRequest_3:
   \   0000CA   85..82       MOV     DPL,?V0 + 4
   \   0000CD   85..83       MOV     DPH,?V0 + 5
   \   0000D0   12....       LCALL   ??Subroutine129_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_236:
   \   0000D3   40BF         JC      ??zcl_SendWriteRequest_4
   1128          
   1129              status = zcl_SendCommand( srcEP, dstAddr, clusterID, cmd, FALSE,
   1130                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   0000D5                ; Setup parameters for call to function zcl_SendCommand
   \   0000D5   78..         MOV     R0,#?V0 + 0
   \   0000D7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000DA   8E..         MOV     ?V0 + 4,R6
   \   0000DC   8F..         MOV     ?V0 + 5,R7
   \   0000DE   78..         MOV     R0,#?V0 + 4
   \   0000E0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000E3   E5..         MOV     A,?V0 + 3
   \   0000E5   F5..         MOV     ?V0 + 2,A
   \   0000E7   78..         MOV     R0,#?V0 + 2
   \   0000E9   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000EC   E4           CLR     A
   \   0000ED   F5..         MOV     ?V0 + 2,A
   \   0000EF   F5..         MOV     ?V0 + 3,A
   \   0000F1   78..         MOV     R0,#?V0 + 2
   \   0000F3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F6   E5..         MOV     A,?V0 + 6
   \   0000F8   F5..         MOV     ?V0 + 2,A
   \   0000FA   78..         MOV     R0,#?V0 + 2
   \   0000FC   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000FF   E5..         MOV     A,?V0 + 7
   \   000101   F5..         MOV     ?V0 + 2,A
   \   000103   78..         MOV     R0,#?V0 + 2
   \   000105   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000108   75..00       MOV     ?V0 + 2,#0x0
   \   00010B   78..         MOV     R0,#?V0 + 2
   \   00010D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000110   E5..         MOV     A,?V0 + 10
   \   000112   F5..         MOV     ?V0 + 2,A
   \   000114   78..         MOV     R0,#?V0 + 2
   \   000116   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000119   AC..         MOV     R4,?V0 + 12
   \   00011B   AD..         MOV     R5,?V0 + 13
   \   00011D   AA..         MOV     R2,?V0 + 14
   \   00011F   AB..         MOV     R3,?V0 + 15
   \   000121   A9..         MOV     R1,?V0 + 11
   \   000123   12....       LCALL   ??zcl_SendCommand?relay
   \   000126   740B         MOV     A,#0xb
   \   000128   12....       LCALL   ?DEALLOC_XSTACK8
   \   00012B   E9           MOV     A,R1
   \   00012C   FE           MOV     R6,A
   1131              zcl_mem_free( buf );
   \   00012D                ; Setup parameters for call to function osal_mem_free
   \   00012D   AA..         MOV     R2,?V0 + 0
   \   00012F   AB..         MOV     R3,?V0 + 1
   \   000131   12....       LCALL   ??osal_mem_free?relay
   \   000134   8002         SJMP    ??zcl_SendWriteRequest_5
   1132            }
   1133            else
   1134            {
   1135              status = ZMemError;
   \                     ??zcl_SendWriteRequest_2:
   \   000136   7E10         MOV     R6,#0x10
   1136            }
   1137          
   1138            return ( status);
   \                     ??zcl_SendWriteRequest_5:
   \   000138   EE           MOV     A,R6
   \   000139   F9           MOV     R1,A
   \   00013A   02....       LJMP    ??Subroutine132_0 & 0xFFFF
   1139          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   EA           MOV     A,R2
   \   000001   2402         ADD     A,#0x2
   \   000003   F8           MOV     R0,A
   \   000004   EB           MOV     A,R3
   \   000005   3400         ADDC    A,#0x0
   \   000007   F9           MOV     R1,A
   \   000008   8882         MOV     DPL,R0
   \   00000A   8983         MOV     DPH,R1
   \   00000C                REQUIRE ??Subroutine120_0
   \   00000C                ; // Fall through to label ??Subroutine120_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine120_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   0C           INC     R4
   \   000008   AD83         MOV     R5,DPH
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine86:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   AC82         MOV     R4,DPL
   \   000004   AD83         MOV     R5,DPH
   \   000006   8A82         MOV     DPL,R2
   \   000008   8B83         MOV     DPH,R3
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_131:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_311:
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET
   1140          
   1141          /*********************************************************************
   1142           * @fn      zcl_SendWriteRsp
   1143           *
   1144           * @brief   Send a Write Response command
   1145           *
   1146           * @param   dstAddr - destination address
   1147           * @param   clusterID - cluster ID
   1148           * @param   wrtieRspCmd - write response command to be sent
   1149           * @param   direction - direction of the command
   1150           * @param   seqNum - transaction sequence number
   1151           *
   1152           * @return  ZSuccess if OK
   1153           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1154          ZStatus_t zcl_SendWriteRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendWriteRsp:
   1155                                      uint16 clusterID, zclWriteRspCmd_t *writeRspCmd,
   1156                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1157          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 2,R1
   \   000007   8A..         MOV     ?V0 + 12,R2
   \   000009   8B..         MOV     ?V0 + 13,R3
   \   00000B   8C..         MOV     ?V0 + 10,R4
   \   00000D   8D..         MOV     ?V0 + 11,R5
   \   00000F   7418         MOV     A,#0x18
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V0 + 3,A
   \   000017   7419         MOV     A,#0x19
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F5..         MOV     ?V0 + 6,A
   \   00001F   741A         MOV     A,#0x1a
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   E0           MOVX    A,@DPTR
   \   000025   F5..         MOV     ?V0 + 7,A
   \   000027   7416         MOV     A,#0x16
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   12....       LCALL   ?Subroutine51 & 0xFFFF
   1158            uint16 dataLen;
   1159            uint8 *buf;
   1160            ZStatus_t status;
   1161          
   1162            dataLen = writeRspCmd->numAttr * ( 1 + 2 ); // status + attribute id
   \                     ??CrossCallReturnLabel_60:
   \   00002F   75F003       MOV     B,#0x3
   \   000032   A4           MUL     AB
   \   000033   FE           MOV     R6,A
   \   000034   AFF0         MOV     R7,B
   1163          
   1164            buf = zcl_mem_alloc( dataLen );
   \   000036                ; Setup parameters for call to function osal_mem_alloc
   \   000036   FA           MOV     R2,A
   \   000037   EF           MOV     A,R7
   \   000038   FB           MOV     R3,A
   \   000039   12....       LCALL   ??osal_mem_alloc?relay
   \   00003C   8A..         MOV     ?V0 + 0,R2
   \   00003E   8B..         MOV     ?V0 + 1,R3
   1165            if ( buf != NULL )
   \   000040   EA           MOV     A,R2
   \   000041   45..         ORL     A,?V0 + 1
   \   000043   7003         JNZ     $+5
   \   000045   02....       LJMP    ??zcl_SendWriteRsp_0 & 0xFFFF
   1166            {
   1167              // Load the buffer - serially
   1168              uint8 i;
   1169              uint8 *pBuf = buf;
   \   000048   A8..         MOV     R0,?V0 + 0
   \   00004A   A9..         MOV     R1,?V0 + 1
   1170              for ( i = 0; i < writeRspCmd->numAttr; i++ )
   \   00004C   75..00       MOV     ?V0 + 8,#0x0
   \   00004F   8031         SJMP    ??zcl_SendWriteRsp_1
   1171              {
   1172                *pBuf++ = writeRspCmd->attrList[i].status;
   \                     ??zcl_SendWriteRsp_2:
   \   000051   E5..         MOV     A,?V0 + 8
   \   000053   75F003       MOV     B,#0x3
   \   000056   A4           MUL     AB
   \   000057   FA           MOV     R2,A
   \   000058   ABF0         MOV     R3,B
   \   00005A   E5..         MOV     A,?V0 + 4
   \   00005C   2A           ADD     A,R2
   \   00005D   FA           MOV     R2,A
   \   00005E   E5..         MOV     A,?V0 + 5
   \   000060   3B           ADDC    A,R3
   \   000061   FB           MOV     R3,A
   \   000062   8A82         MOV     DPL,R2
   \   000064   8B83         MOV     DPH,R3
   \   000066   A3           INC     DPTR
   \   000067   12....       LCALL   ?Subroutine60 & 0xFFFF
   1173                *pBuf++ = LO_UINT16( writeRspCmd->attrList[i].attrID );
   \                     ??CrossCallReturnLabel_73:
   \   00006A   EA           MOV     A,R2
   \   00006B   2402         ADD     A,#0x2
   \   00006D   FC           MOV     R4,A
   \   00006E   EB           MOV     A,R3
   \   00006F   3400         ADDC    A,#0x0
   \   000071   FD           MOV     R5,A
   \   000072   8C82         MOV     DPL,R4
   \   000074   8D83         MOV     DPH,R5
   \   000076   12....       LCALL   ??Subroutine112_0 & 0xFFFF
   1174                *pBuf++ = HI_UINT16( writeRspCmd->attrList[i].attrID );
   \                     ??CrossCallReturnLabel_153:
   \   000079   8C82         MOV     DPL,R4
   \   00007B   8D83         MOV     DPH,R5
   \   00007D   12....       LCALL   ?Subroutine43 & 0xFFFF
   1175              }
   \                     ??CrossCallReturnLabel_155:
   \   000080   05..         INC     ?V0 + 8
   \                     ??zcl_SendWriteRsp_1:
   \   000082   85..82       MOV     DPL,?V0 + 4
   \   000085   85..83       MOV     DPH,?V0 + 5
   \   000088   E0           MOVX    A,@DPTR
   \   000089   FA           MOV     R2,A
   \   00008A   E5..         MOV     A,?V0 + 8
   \   00008C   C3           CLR     C
   \   00008D   9A           SUBB    A,R2
   \   00008E   40C1         JC      ??zcl_SendWriteRsp_2
   1176          
   1177              // If there's only a single status record and its status field is set to
   1178              // SUCCESS then omit the attribute ID field.
   1179              if ( writeRspCmd->numAttr == 1 && writeRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   000090   7401         MOV     A,#0x1
   \   000092   6A           XRL     A,R2
   \   000093   7008         JNZ     ??zcl_SendWriteRsp_3
   \   000095   A3           INC     DPTR
   \   000096   E0           MOVX    A,@DPTR
   \   000097   7004         JNZ     ??zcl_SendWriteRsp_3
   1180              {
   1181                dataLen = 1;
   \   000099   7E01         MOV     R6,#0x1
   \   00009B   7F00         MOV     R7,#0x0
   1182              }
   1183          
   1184              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_WRITE_RSP, FALSE,
   1185                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendWriteRsp_3:
   \   00009D                ; Setup parameters for call to function zcl_SendCommand
   \   00009D   78..         MOV     R0,#?V0 + 0
   \   00009F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A2   8E..         MOV     ?V0 + 4,R6
   \   0000A4   8F..         MOV     ?V0 + 5,R7
   \   0000A6   78..         MOV     R0,#?V0 + 4
   \   0000A8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AB   E5..         MOV     A,?V0 + 7
   \   0000AD   F5..         MOV     ?V0 + 4,A
   \   0000AF   78..         MOV     R0,#?V0 + 4
   \   0000B1   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B4   E4           CLR     A
   \   0000B5   F5..         MOV     ?V0 + 4,A
   \   0000B7   F5..         MOV     ?V0 + 5,A
   \   0000B9   78..         MOV     R0,#?V0 + 4
   \   0000BB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000BE   E5..         MOV     A,?V0 + 6
   \   0000C0   F5..         MOV     ?V0 + 4,A
   \   0000C2   78..         MOV     R0,#?V0 + 4
   \   0000C4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C7   78..         MOV     R0,#?V0 + 3
   \   0000C9   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000CC   75..00       MOV     ?V0 + 3,#0x0
   \   0000CF   78..         MOV     R0,#?V0 + 3
   \   0000D1   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D4   75..04       MOV     ?V0 + 3,#0x4
   \   0000D7   78..         MOV     R0,#?V0 + 3
   \   0000D9   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000DC   AC..         MOV     R4,?V0 + 10
   \   0000DE   AD..         MOV     R5,?V0 + 11
   \   0000E0   AA..         MOV     R2,?V0 + 12
   \   0000E2   AB..         MOV     R3,?V0 + 13
   \   0000E4   A9..         MOV     R1,?V0 + 2
   \   0000E6   12....       LCALL   ??zcl_SendCommand?relay
   \   0000E9   740B         MOV     A,#0xb
   \   0000EB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000EE   E9           MOV     A,R1
   \   0000EF   FE           MOV     R6,A
   1186              zcl_mem_free( buf );
   \   0000F0                ; Setup parameters for call to function osal_mem_free
   \   0000F0   AA..         MOV     R2,?V0 + 0
   \   0000F2   AB..         MOV     R3,?V0 + 1
   \   0000F4   12....       LCALL   ??osal_mem_free?relay
   \   0000F7   8002         SJMP    ??zcl_SendWriteRsp_4
   1187            }
   1188            else
   1189            {
   1190              status = ZMemError;
   \                     ??zcl_SendWriteRsp_0:
   \   0000F9   7E10         MOV     R6,#0x10
   1191            }
   1192          
   1193            return ( status );
   \                     ??zcl_SendWriteRsp_4:
   \   0000FB   02....       LJMP    ?Subroutine9 & 0xFFFF
   1194          }
   1195          #endif // ZCL_WRITE
   1196          
   1197          #ifdef ZCL_REPORT
   1198          /*********************************************************************
   1199           * @fn      zcl_SendConfigReportCmd
   1200           *
   1201           * @brief   Send a Configure Reporting command
   1202           *
   1203           * @param   dstAddr - destination address
   1204           * @param   clusterID - cluster ID
   1205           * @param   cfgReportCmd - configure reporting command to be sent
   1206           * @param   direction - direction of the command
   1207           * @param   seqNum - transaction sequence number
   1208           *
   1209           * @return  ZSuccess if OK
   1210           */
   1211          ZStatus_t zcl_SendConfigReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1212                                    uint16 clusterID, zclCfgReportCmd_t *cfgReportCmd,
   1213                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1214          {
   1215            uint8 *buf;
   1216            uint16 dataLen = 0;
   1217            ZStatus_t status;
   1218            uint8 i;
   1219          
   1220            // Find out the data length
   1221            for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   1222            {
   1223              zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1224          
   1225              dataLen += 1 + 2; // Direction + Attribute ID
   1226          
   1227              if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1228              {
   1229                dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1230          
   1231                // Find out the size of the Reportable Change field (for Analog data types)
   1232                if ( zclAnalogDataType( reportRec->dataType ) )
   1233                {
   1234                  dataLen += zclGetDataTypeLength( reportRec->dataType );
   1235                }
   1236              }
   1237              else
   1238              {
   1239                dataLen += 2; // Timeout Period
   1240              }
   1241            }
   1242          
   1243            buf = zcl_mem_alloc( dataLen );
   1244            if ( buf != NULL )
   1245            {
   1246              // Load the buffer - serially
   1247              uint8 *pBuf = buf;
   1248          
   1249              for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   1250              {
   1251                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1252          
   1253                *pBuf++ = reportRec->direction;
   1254                *pBuf++ = LO_UINT16( reportRec->attrID );
   1255                *pBuf++ = HI_UINT16( reportRec->attrID );
   1256          
   1257                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1258                {
   1259                  *pBuf++ = reportRec->dataType;
   1260                  *pBuf++ = LO_UINT16( reportRec->minReportInt );
   1261                  *pBuf++ = HI_UINT16( reportRec->minReportInt );
   1262                  *pBuf++ = LO_UINT16( reportRec->maxReportInt );
   1263                  *pBuf++ = HI_UINT16( reportRec->maxReportInt );
   1264          
   1265                  if ( zclAnalogDataType( reportRec->dataType ) )
   1266                  {
   1267                    pBuf = zclSerializeData( reportRec->dataType, reportRec->reportableChange, pBuf );
   1268                  }
   1269                }
   1270                else
   1271                {
   1272                  *pBuf++ = LO_UINT16( reportRec->timeoutPeriod );
   1273                  *pBuf++ = HI_UINT16( reportRec->timeoutPeriod );
   1274                }
   1275              } // for loop
   1276          
   1277              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_CONFIG_REPORT, FALSE,
   1278                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1279              zcl_mem_free( buf );
   1280            }
   1281            else
   1282            {
   1283              status = ZMemError;
   1284            }
   1285          
   1286            return ( status );
   1287          }
   1288          
   1289          /*********************************************************************
   1290           * @fn      zcl_SendConfigReportRspCmd
   1291           *
   1292           * @brief   Send a Configure Reporting Response command
   1293           *
   1294           * @param   dstAddr - destination address
   1295           * @param   clusterID - cluster ID
   1296           * @param   cfgReportRspCmd - configure reporting response command to be sent
   1297           * @param   direction - direction of the command
   1298           * @param   seqNum - transaction sequence number
   1299           *
   1300           * @return  ZSuccess if OK
   1301           */
   1302          ZStatus_t zcl_SendConfigReportRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1303                              uint16 clusterID, zclCfgReportRspCmd_t *cfgReportRspCmd,
   1304                              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1305          {
   1306            uint16 dataLen;
   1307            uint8 *buf;
   1308            ZStatus_t status;
   1309          
   1310            // Atrribute list (Status, Direction and Attribute ID)
   1311            dataLen = cfgReportRspCmd->numAttr * ( 1 + 1 + 2 );
   1312          
   1313            buf = zcl_mem_alloc( dataLen );
   1314            if ( buf != NULL )
   1315            {
   1316              // Load the buffer - serially
   1317              uint8 *pBuf = buf;
   1318              uint8 i;
   1319          
   1320              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   1321              {
   1322                *pBuf++ = cfgReportRspCmd->attrList[i].status;
   1323                *pBuf++ = cfgReportRspCmd->attrList[i].direction;
   1324                *pBuf++ = LO_UINT16( cfgReportRspCmd->attrList[i].attrID );
   1325                *pBuf++ = HI_UINT16( cfgReportRspCmd->attrList[i].attrID );
   1326              }
   1327          
   1328              // If there's only a single status record and its status field is set to
   1329              // SUCCESS then omit the attribute ID field.
   1330              if ( cfgReportRspCmd->numAttr == 1 && cfgReportRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   1331              {
   1332                dataLen = 1;
   1333              }
   1334          
   1335              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1336                                        ZCL_CMD_CONFIG_REPORT_RSP, FALSE, direction,
   1337                                        disableDefaultRsp, 0, seqNum, dataLen, buf );
   1338              zcl_mem_free( buf );
   1339            }
   1340            else
   1341            {
   1342              status = ZMemError;
   1343            }
   1344          
   1345            return ( status );
   1346          }
   1347          
   1348          /*********************************************************************
   1349           * @fn      zcl_SendReadReportCfgCmd
   1350           *
   1351           * @brief   Send a Read Reporting Configuration command
   1352           *
   1353           * @param   dstAddr - destination address
   1354           * @param   clusterID - cluster ID
   1355           * @param   readReportCfgCmd - read reporting configuration command to be sent
   1356           * @param   direction - direction of the command
   1357           * @param   seqNum - transaction sequence number
   1358           *
   1359           * @return  ZSuccess if OK
   1360           */
   1361          ZStatus_t zcl_SendReadReportCfgCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1362                            uint16 clusterID, zclReadReportCfgCmd_t *readReportCfgCmd,
   1363                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1364          {
   1365            uint16 dataLen;
   1366            uint8 *buf;
   1367            ZStatus_t status;
   1368          
   1369            dataLen = readReportCfgCmd->numAttr * ( 1 + 2 ); // Direction + Atrribute ID
   1370          
   1371            buf = zcl_mem_alloc( dataLen );
   1372            if ( buf != NULL )
   1373            {
   1374              // Load the buffer - serially
   1375              uint8 *pBuf = buf;
   1376              uint8 i;
   1377          
   1378              for ( i = 0; i < readReportCfgCmd->numAttr; i++ )
   1379              {
   1380                *pBuf++ = readReportCfgCmd->attrList[i].direction;
   1381                *pBuf++ = LO_UINT16( readReportCfgCmd->attrList[i].attrID );
   1382                *pBuf++ = HI_UINT16( readReportCfgCmd->attrList[i].attrID );
   1383              }
   1384          
   1385              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_REPORT_CFG, FALSE,
   1386                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1387              zcl_mem_free( buf );
   1388            }
   1389            else
   1390            {
   1391              status = ZMemError;
   1392            }
   1393          
   1394            return ( status );
   1395          }
   1396          
   1397          /*********************************************************************
   1398           * @fn      zcl_SendReadReportCfgRspCmd
   1399           *
   1400           * @brief   Send a Read Reporting Configuration Response command
   1401           *
   1402           * @param   dstAddr - destination address
   1403           * @param   clusterID - cluster ID
   1404           * @param   readReportCfgRspCmd - read reporting configuration response command to be sent
   1405           * @param   direction - direction of the command
   1406           * @param   seqNum - transaction sequence number
   1407           *
   1408           * @return  ZSuccess if OK
   1409           */
   1410          ZStatus_t zcl_SendReadReportCfgRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1411                       uint16 clusterID, zclReadReportCfgRspCmd_t *readReportCfgRspCmd,
   1412                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1413          {
   1414            uint8 *buf;
   1415            uint16 dataLen = 0;
   1416            ZStatus_t status;
   1417            uint8 i;
   1418          
   1419            // Find out the data length
   1420            for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   1421            {
   1422              zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1423          
   1424              dataLen += 1 + 1 + 2 ; // Status, Direction and Atrribute ID
   1425          
   1426              if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1427              {
   1428                if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1429                {
   1430                  dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1431          
   1432                  // Find out the size of the Reportable Change field (for Analog data types)
   1433                  if ( zclAnalogDataType( reportRspRec->dataType ) )
   1434                  {
   1435                    dataLen += zclGetDataTypeLength( reportRspRec->dataType );
   1436                  }
   1437                }
   1438                else
   1439                {
   1440                  dataLen += 2; // Timeout Period
   1441                }
   1442              }
   1443            }
   1444          
   1445            buf = zcl_mem_alloc( dataLen );
   1446            if ( buf != NULL )
   1447            {
   1448              // Load the buffer - serially
   1449              uint8 *pBuf = buf;
   1450          
   1451              for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   1452              {
   1453                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1454          
   1455                *pBuf++ = reportRspRec->status;
   1456                *pBuf++ = reportRspRec->direction;
   1457                *pBuf++ = LO_UINT16( reportRspRec->attrID );
   1458                *pBuf++ = HI_UINT16( reportRspRec->attrID );
   1459          
   1460                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1461                {
   1462                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1463                  {
   1464                    *pBuf++ = reportRspRec->dataType;
   1465                    *pBuf++ = LO_UINT16( reportRspRec->minReportInt );
   1466                    *pBuf++ = HI_UINT16( reportRspRec->minReportInt );
   1467                    *pBuf++ = LO_UINT16( reportRspRec->maxReportInt );
   1468                    *pBuf++ = HI_UINT16( reportRspRec->maxReportInt );
   1469          
   1470                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   1471                    {
   1472                      pBuf = zclSerializeData( reportRspRec->dataType,
   1473                                               reportRspRec->reportableChange, pBuf );
   1474                    }
   1475                  }
   1476                  else
   1477                  {
   1478                    *pBuf++ = LO_UINT16( reportRspRec->timeoutPeriod );
   1479                    *pBuf++ = HI_UINT16( reportRspRec->timeoutPeriod );
   1480                  }
   1481                }
   1482              }
   1483          
   1484              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1485                                        ZCL_CMD_READ_REPORT_CFG_RSP, FALSE,
   1486                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1487              zcl_mem_free( buf );
   1488            }
   1489            else
   1490            {
   1491              status = ZMemError;
   1492            }
   1493          
   1494            return ( status );
   1495          }
   1496          
   1497          /*********************************************************************
   1498           * @fn      zcl_SendReportCmd
   1499           *
   1500           * @brief   Send a Report command
   1501           *
   1502           * @param   dstAddr - destination address
   1503           * @param   clusterID - cluster ID
   1504           * @param   reportCmd - report command to be sent
   1505           * @param   direction - direction of the command
   1506           * @param   seqNum - transaction sequence number
   1507           *
   1508           * @return  ZSuccess if OK
   1509           */
   1510          ZStatus_t zcl_SendReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1511                                       uint16 clusterID, zclReportCmd_t *reportCmd,
   1512                                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1513          {
   1514            uint16 dataLen = 0;
   1515            uint8 *buf;
   1516            ZStatus_t status;
   1517            uint8 i;
   1518          
   1519            // calculate the size of the command
   1520            for ( i = 0; i < reportCmd->numAttr; i++ )
   1521            {
   1522              zclReport_t *reportRec = &(reportCmd->attrList[i]);
   1523          
   1524              dataLen += 2 + 1; // Attribute ID + data type
   1525          
   1526              // Attribute Data
   1527              dataLen += zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
   1528            }
   1529          
   1530            buf = zcl_mem_alloc( dataLen );
   1531            if ( buf != NULL )
   1532            {
   1533              // Load the buffer - serially
   1534              uint8 *pBuf = buf;
   1535          
   1536              for ( i = 0; i < reportCmd->numAttr; i++ )
   1537              {
   1538                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   1539          
   1540                *pBuf++ = LO_UINT16( reportRec->attrID );
   1541                *pBuf++ = HI_UINT16( reportRec->attrID );
   1542                *pBuf++ = reportRec->dataType;
   1543          
   1544                pBuf = zclSerializeData( reportRec->dataType, reportRec->attrData, pBuf );
   1545              }
   1546          
   1547              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_REPORT, FALSE,
   1548                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1549              zcl_mem_free( buf );
   1550            }
   1551            else
   1552            {
   1553              status = ZMemError;
   1554            }
   1555          
   1556            return ( status );
   1557          }
   1558          #endif // ZCL_REPORT
   1559          
   1560          /*********************************************************************
   1561           * @fn      zcl_SendDefaultRspCmd
   1562           *
   1563           * @brief   Send a Default Response command
   1564           *
   1565           *          Note: The manufacturer code field should be set if this
   1566           *          command is being sent in response to a manufacturer specific
   1567           *          command.
   1568           *
   1569           * @param   dstAddr - destination address
   1570           * @param   clusterID - cluster ID
   1571           * @param   defaultRspCmd - default response command to be sent
   1572           * @param   direction - direction of the command
   1573           * @param   manuCode - manufacturer code for proprietary extensions to a profile
   1574           * @param   seqNum - transaction sequence number
   1575           *
   1576           * @return  ZSuccess if OK
   1577           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1578          ZStatus_t zcl_SendDefaultRspCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendDefaultRspCmd:
   1579                                           zclDefaultRspCmd_t *defaultRspCmd, uint8 direction,
   1580                                           uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum )
   1581          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   7412         MOV     A,#0x12
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   E0           MOVX    A,@DPTR
   \   000012   FF           MOV     R7,A
   \   000013   7413         MOV     A,#0x13
   \   000015   12....       LCALL   ?XSTACK_DISP0_8
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F5..         MOV     ?V0 + 4,A
   \   00001B   7414         MOV     A,#0x14
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F5..         MOV     ?V0 + 2,A
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   F5..         MOV     ?V0 + 3,A
   \   000027   7416         MOV     A,#0x16
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F5..         MOV     ?V0 + 5,A
   \   00002F   7410         MOV     A,#0x10
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   12....       LCALL   ?Subroutine66 & 0xFFFF
   1582            uint8 buf[2]; // Command ID and Status;
   1583          
   1584            // Load the buffer - serially
   1585            buf[0] = defaultRspCmd->commandID;
   \                     ??CrossCallReturnLabel_85:
   \   000037   12....       LCALL   ?Subroutine100 & 0xFFFF
   1586            buf[1] = defaultRspCmd->statusCode;
   \                     ??CrossCallReturnLabel_141:
   \   00003A   8882         MOV     DPL,R0
   \   00003C   8983         MOV     DPH,R1
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   C0E0         PUSH    A
   \   000042   7401         MOV     A,#0x1
   \   000044   12....       LCALL   ?XSTACK_DISP0_8
   \   000047   D0E0         POP     A
   \   000049   F0           MOVX    @DPTR,A
   1587          
   1588            return ( zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DEFAULT_RSP, FALSE,
   1589                                      direction, disableDefaultRsp, manuCode, seqNum, 2, buf ) );
   \   00004A                ; Setup parameters for call to function zcl_SendCommand
   \   00004A   85..82       MOV     DPL,?XSP + 0
   \   00004D   85..83       MOV     DPH,?XSP + 1
   \   000050   8582..       MOV     ?V0 + 0,DPL
   \   000053   8583..       MOV     ?V0 + 1,DPH
   \   000056   78..         MOV     R0,#?V0 + 0
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005B   75..02       MOV     ?V0 + 0,#0x2
   \   00005E   75..00       MOV     ?V0 + 1,#0x0
   \   000061   78..         MOV     R0,#?V0 + 0
   \   000063   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000066   E5..         MOV     A,?V0 + 5
   \   000068   F5..         MOV     ?V0 + 0,A
   \   00006A   78..         MOV     R0,#?V0 + 0
   \   00006C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00006F   78..         MOV     R0,#?V0 + 2
   \   000071   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000074   E5..         MOV     A,?V0 + 4
   \   000076   F5..         MOV     ?V0 + 0,A
   \   000078   78..         MOV     R0,#?V0 + 0
   \   00007A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00007D   EF           MOV     A,R7
   \   00007E   F5..         MOV     ?V0 + 0,A
   \   000080   78..         MOV     R0,#?V0 + 0
   \   000082   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000085   75..00       MOV     ?V0 + 0,#0x0
   \   000088   78..         MOV     R0,#?V0 + 0
   \   00008A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00008D   75..0B       MOV     ?V0 + 0,#0xb
   \   000090   78..         MOV     R0,#?V0 + 0
   \   000092   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000095   EE           MOV     A,R6
   \   000096   F9           MOV     R1,A
   \   000097   12....       LCALL   ??zcl_SendCommand?relay
   \   00009A   740B         MOV     A,#0xb
   \   00009C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00009F   7402         MOV     A,#0x2
   \   0000A1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A4                REQUIRE ?Subroutine3
   \   0000A4                ; // Fall through to label ?Subroutine3
   1590          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine100:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   F0           MOVX    @DPTR,A
   \   000008   22           RET
   1591          
   1592          #ifdef ZCL_DISCOVER
   1593          /*********************************************************************
   1594           * @fn      zcl_SendDiscoverCmdsCmd
   1595           *
   1596           * @brief   Send a Discover Commands command
   1597           *
   1598           * @param   dstAddr - destination address
   1599           * @param   clusterID - cluster ID
   1600           * @param   cmdType - requesting command ID
   1601           * @param   pDiscoverCmd - discover command to be sent
   1602           * @param   direction - direction of the command
   1603           * @param   seqNum - transaction sequence number
   1604           *
   1605           * @return  ZSuccess if OK
   1606           */
   1607          ZStatus_t zcl_SendDiscoverCmdsCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   1608                                            uint8 cmdType, zclDiscoverCmdsCmd_t *pDiscoverCmd,
   1609                                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1610          {
   1611            uint8 payload[2]; // size of startCmdID and maxCmdID
   1612            ZStatus_t status;
   1613          
   1614            payload[0] = pDiscoverCmd->startCmdID;
   1615            payload[1] = pDiscoverCmd->maxCmdID;
   1616          
   1617            // Send message for either commands received or generated
   1618            if ( cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   1619            {
   1620              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED, FALSE,
   1621                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   1622            }
   1623            else  // generated
   1624            {
   1625              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN, FALSE,
   1626                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   1627            }
   1628          
   1629            return ( status );
   1630          }
   1631          
   1632          /*********************************************************************
   1633           * @fn      zcl_SendDiscoverCmdsRspCmd
   1634           *
   1635           * @brief   Send a Discover Commands Response command
   1636           *
   1637           * @param   dstAddr - destination address
   1638           * @param   clusterID - cluster ID
   1639           * @param   pDiscoverRspCmd - response command to be sent
   1640           * @param   direction - direction of the command
   1641           * @param   seqNum - transaction sequence number
   1642           *
   1643           * @return  ZSuccess if OK
   1644           */
   1645          ZStatus_t zcl_SendDiscoverCmdsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1646                                                uint16 clusterID, zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd,
   1647                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1648          {
   1649            uint8 payloadSize = ( 1 + pDiscoverRspCmd->numCmd );  // size of discovery complete field plus cmds
   1650            uint8 *pCmdBuf;
   1651            uint8 i;
   1652            ZStatus_t status = ZSuccess;
   1653          
   1654            // allocate memory
   1655            pCmdBuf = zcl_mem_alloc( payloadSize );
   1656            if ( pCmdBuf != NULL )
   1657            {
   1658              uint8 *pBuf = pCmdBuf;
   1659          
   1660              // Load the buffer - serially
   1661              *pBuf++ = pDiscoverRspCmd->discComplete;
   1662              for ( i = 0; i < pDiscoverRspCmd->numCmd; i++ )
   1663              {
   1664                *pBuf++ = pDiscoverRspCmd->pCmdID[i];
   1665              }
   1666          
   1667              // Send response message for either commands received or generated
   1668              if( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   1669              {
   1670                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP, FALSE,
   1671                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   1672              }
   1673              else if ( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_GEN )
   1674              {
   1675                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN_RSP, FALSE,
   1676                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   1677              }
   1678          
   1679              zcl_mem_free( pCmdBuf );
   1680            }
   1681            else
   1682            {
   1683              status = ZMemError;
   1684            }
   1685          
   1686            return ( status );
   1687          }
   1688          
   1689          /*********************************************************************
   1690           * @fn      zcl_SendDiscoverAttrsCmd
   1691           *
   1692           * @brief   Send a Discover Attributes command
   1693           *
   1694           * @param   dstAddr - destination address
   1695           * @param   clusterID - cluster ID
   1696           * @param   pDiscoverCmd - discover command to be sent
   1697           * @param   direction - direction of the command
   1698           * @param   seqNum - transaction sequence number
   1699           *
   1700           * @return  ZSuccess if OK
   1701           */
   1702          ZStatus_t zcl_SendDiscoverAttrsCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1703                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverCmd,
   1704                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1705          {
   1706            uint8 dataLen = 2 + 1; // Start Attribute ID and Max Attribute IDs
   1707            uint8 *buf;
   1708            ZStatus_t status;
   1709          
   1710            buf = zcl_mem_alloc( dataLen );
   1711            if ( buf != NULL )
   1712            {
   1713              // Load the buffer - serially
   1714              uint8 *pBuf = buf;
   1715              *pBuf++ = LO_UINT16(pDiscoverCmd->startAttr);
   1716              *pBuf++ = HI_UINT16(pDiscoverCmd->startAttr);
   1717              *pBuf++ = pDiscoverCmd->maxAttrIDs;
   1718          
   1719              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS, FALSE,
   1720                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1721              zcl_mem_free( buf );
   1722            }
   1723            else
   1724            {
   1725              status = ZMemError;
   1726            }
   1727          
   1728            return ( status );
   1729          }
   1730          
   1731          /*********************************************************************
   1732           * @fn      zcl_SendDiscoverAttrsRspCmd
   1733           *
   1734           * @brief   Send a Discover Attributes Response command
   1735           *
   1736           * @param   dstAddr - destination address
   1737           * @param   clusterID - cluster ID
   1738           * @param   reportRspCmd - report response command to be sent
   1739           * @param   direction - direction of the command
   1740           * @param   seqNum - transaction sequence number
   1741           *
   1742           * @return  ZSuccess if OK
   1743           */
   1744          ZStatus_t zcl_SendDiscoverAttrsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1745                                    uint16 clusterID, zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd,
   1746                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1747          {
   1748            uint16 dataLen = 1; // Discovery complete
   1749            uint8 *buf;
   1750            ZStatus_t status;
   1751          
   1752            // calculate the size of the command
   1753            dataLen += pDiscoverRspCmd->numAttr * (2 + 1); // Attribute ID and Data Type
   1754          
   1755            buf = zcl_mem_alloc( dataLen );
   1756            if ( buf != NULL )
   1757            {
   1758              // Load the buffer - serially
   1759              uint8 i;
   1760              uint8 *pBuf = buf;
   1761          
   1762              *pBuf++ = pDiscoverRspCmd->discComplete;
   1763          
   1764              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   1765              {
   1766                *pBuf++ = LO_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   1767                *pBuf++ = HI_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   1768                *pBuf++ = pDiscoverRspCmd->attrList[i].dataType;
   1769              }
   1770          
   1771              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_RSP, FALSE,
   1772                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1773              zcl_mem_free( buf );
   1774            }
   1775            else
   1776            {
   1777              status = ZMemError;
   1778            }
   1779          
   1780            return ( status );
   1781          }
   1782          
   1783          /*********************************************************************
   1784           * @fn      zcl_SendDiscoverAttrsExt
   1785           *
   1786           * @brief   Send a Discover Attributes Extended command
   1787           *
   1788           * @param   dstAddr - destination address
   1789           * @param   clusterID - cluster ID
   1790           * @param   pDiscoverAttrsExt:
   1791           *            - startAttrID: the first attribute to be selected
   1792           *            - maxAttrIDs: maximum number of returned attributes
   1793           * @param   direction - direction of the command
   1794           * @param   seqNum - transaction sequence number
   1795           *
   1796           * @return  ZSuccess if OK
   1797           */
   1798          ZStatus_t zcl_SendDiscoverAttrsExt( uint8 srcEP, afAddrType_t *dstAddr,
   1799                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverAttrsExt,
   1800                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1801          {
   1802            uint8 buf[3];  // Buffer size equal to Start Attribute ID and Max Attribute IDs
   1803            ZStatus_t status;
   1804          
   1805            // Load the buffer - serially
   1806            buf[0] = LO_UINT16(pDiscoverAttrsExt->startAttr);
   1807            buf[1] = HI_UINT16(pDiscoverAttrsExt->startAttr);
   1808            buf[2] = pDiscoverAttrsExt->maxAttrIDs;
   1809          
   1810            status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT, FALSE,
   1811                                      direction, disableDefaultRsp, 0, seqNum, sizeof( buf ), buf );
   1812          
   1813            return ( status );
   1814          }
   1815          
   1816          /*********************************************************************
   1817           * @fn      zcl_SendDiscoverAttrsExtRsp
   1818           *
   1819           * @brief   Send a Discover Attributes Extended Response command
   1820           *
   1821           * @param   dstAddr - destination address
   1822           * @param   clusterID - cluster ID
   1823           * @param   pDiscoverRspCmd:
   1824           *            - discComplete: indicates whether all requested attributes returned
   1825           *            - attrID: attribute ID
   1826           *            - attrDataType: data type of the given attribute
   1827           *            - attrAccessControl: access control of the given attribute
   1828           * @param   direction - direction of the command
   1829           * @param   seqNum - transaction sequence number
   1830           *
   1831           * @return  ZSuccess if OK
   1832           */
   1833          ZStatus_t zcl_SendDiscoverAttrsExtRsp( uint8 srcEP, afAddrType_t *dstAddr,
   1834                                                uint16 clusterID, zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd,
   1835                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1836          {
   1837            uint8 *buf;
   1838            uint8 i;
   1839            uint16 dataLen = 1; // Discovery complete
   1840            ZStatus_t status;
   1841          
   1842            // calculate the size of the command
   1843            dataLen += pDiscoverRspCmd->numAttr * (2 + 1 + 1); // Attribute ID, Data Type, and Access Control
   1844          
   1845            buf = zcl_mem_alloc( dataLen );
   1846            if ( buf != NULL )
   1847            {
   1848              // Load the buffer - serially
   1849              uint8 *pBuf = buf;
   1850              *pBuf++ = pDiscoverRspCmd->discComplete;
   1851              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   1852              {
   1853                *pBuf++ = LO_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   1854                *pBuf++ = HI_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   1855                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrDataType;
   1856                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl;
   1857              }
   1858          
   1859              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT_RSP, FALSE,
   1860                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1861              zcl_mem_free( buf );
   1862            }
   1863            else
   1864            {
   1865              status = ZMemError;
   1866            }
   1867          
   1868            return ( status );
   1869          }
   1870          #endif // ZCL_DISCOVER
   1871          
   1872          /*********************************************************************
   1873           * @fn      zcl_ProcessMessageMSG
   1874           *
   1875           * @brief   Data message processor callback.  This function processes
   1876           *          any incoming data - probably from other devices.  So, based
   1877           *          on cluster ID, perform the intended action.
   1878           *
   1879           * @param   pkt - incoming message
   1880           *
   1881           * @return  none
   1882           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1883          void zcl_ProcessMessageMSG( afIncomingMSGPacket_t *pkt )
   \                     zcl_ProcessMessageMSG:
   1884          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 21
   \   000005   74EB         MOV     A,#-0x15
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1885            endPointDesc_t *epDesc;
   1886            zclIncoming_t inMsg;
   1887            zclLibPlugin_t *pInPlugin;
   1888            zclDefaultRspCmd_t defautlRspCmd;
   1889            uint8 options;
   1890            uint8 securityEnable;
   1891            uint8 interPanMsg;
   1892            ZStatus_t status = ZFailure;
   1893          
   1894            if ( pkt->cmd.DataLength == 0 )
   \   00000E   EE           MOV     A,R6
   \   00000F   2420         ADD     A,#0x20
   \   000011   F8           MOV     R0,A
   \   000012   EF           MOV     A,R7
   \   000013   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   000016   12....       LCALL   ??Subroutine124_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_198:
   \   000019   7003         JNZ     $+5
   \   00001B   02....       LJMP    ??zcl_ProcessMessageMSG_0 & 0xFFFF
   1895            {
   1896              return;   // Error, ignore the message
   1897            }
   1898          
   1899            // Initialize
   1900            rawAFMsg = (afIncomingMSGPacket_t *)pkt;
   \   00001E   90....       MOV     DPTR,#rawAFMsg
   \   000021   EE           MOV     A,R6
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   EF           MOV     A,R7
   \   000025   F0           MOVX    @DPTR,A
   1901            inMsg.msg = pkt;
   \   000026   7402         MOV     A,#0x2
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   EE           MOV     A,R6
   \   00002C   F0           MOVX    @DPTR,A
   \   00002D   A3           INC     DPTR
   \   00002E   EF           MOV     A,R7
   \   00002F   F0           MOVX    @DPTR,A
   1902            inMsg.attrCmd = NULL;
   \   000030   740E         MOV     A,#0xe
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   E4           CLR     A
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   F0           MOVX    @DPTR,A
   1903            inMsg.pData = NULL;
   \   000039   740A         MOV     A,#0xa
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   E4           CLR     A
   \   00003F   F0           MOVX    @DPTR,A
   \   000040   A3           INC     DPTR
   \   000041   F0           MOVX    @DPTR,A
   1904            inMsg.pDataLen = 0;
   \   000042   740C         MOV     A,#0xc
   \   000044   12....       LCALL   ?XSTACK_DISP0_8
   \   000047   E4           CLR     A
   \   000048   F0           MOVX    @DPTR,A
   \   000049   A3           INC     DPTR
   \   00004A   F0           MOVX    @DPTR,A
   1905          
   1906            inMsg.pData = zclParseHdr( &(inMsg.hdr), pkt->cmd.Data );
   \   00004B   EE           MOV     A,R6
   \   00004C   2422         ADD     A,#0x22
   \   00004E   F8           MOV     R0,A
   \   00004F   EF           MOV     A,R7
   \   000050   3400         ADDC    A,#0x0
   \   000052   F9           MOV     R1,A
   \   000053   88..         MOV     ?V0 + 2,R0
   \   000055   89..         MOV     ?V0 + 3,R1
   \   000057                ; Setup parameters for call to function zclParseHdr
   \   000057   8882         MOV     DPL,R0
   \   000059   F583         MOV     DPH,A
   \   00005B   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_323:
   \   00005E   7404         MOV     A,#0x4
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   AA82         MOV     R2,DPL
   \   000065   AB83         MOV     R3,DPH
   \   000067   12....       LCALL   ??zclParseHdr?relay
   \   00006A   8A..         MOV     ?V0 + 4,R2
   \   00006C   8B..         MOV     ?V0 + 5,R3
   \   00006E   A8..         MOV     R0,?V0 + 4
   \   000070   A9..         MOV     R1,?V0 + 5
   \   000072   740A         MOV     A,#0xa
   \   000074   12....       LCALL   ?XSTACK_DISP0_8
   \   000077   12....       LCALL   ??Subroutine130_0 & 0xFFFF
   1907            inMsg.pDataLen = pkt->cmd.DataLength;
   1908            inMsg.pDataLen -= (uint16)(inMsg.pData - pkt->cmd.Data);
   \                     ??CrossCallReturnLabel_242:
   \   00007A   85..82       MOV     DPL,?V0 + 0
   \   00007D   85..83       MOV     DPH,?V0 + 1
   \   000080   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_294:
   \   000083   EA           MOV     A,R2
   \   000084   C3           CLR     C
   \   000085   98           SUBB    A,R0
   \   000086   F8           MOV     R0,A
   \   000087   EB           MOV     A,R3
   \   000088   99           SUBB    A,R1
   \   000089   F9           MOV     R1,A
   \   00008A   85..82       MOV     DPL,?V0 + 2
   \   00008D   85..83       MOV     DPH,?V0 + 3
   \   000090   E0           MOVX    A,@DPTR
   \   000091   28           ADD     A,R0
   \   000092   F8           MOV     R0,A
   \   000093   A3           INC     DPTR
   \   000094   E0           MOVX    A,@DPTR
   \   000095   39           ADDC    A,R1
   \   000096   F9           MOV     R1,A
   \   000097   740C         MOV     A,#0xc
   \   000099   12....       LCALL   ?XSTACK_DISP0_8
   \   00009C   12....       LCALL   ??Subroutine130_0 & 0xFFFF
   1909          
   1910            // Find the wanted endpoint
   1911            epDesc = afFindEndPointDesc( pkt->endPoint );
   \                     ??CrossCallReturnLabel_243:
   \   00009F   EE           MOV     A,R6
   \   0000A0   2414         ADD     A,#0x14
   \   0000A2   F5..         MOV     ?V0 + 0,A
   \   0000A4   EF           MOV     A,R7
   \   0000A5   3400         ADDC    A,#0x0
   \   0000A7   F5..         MOV     ?V0 + 1,A
   \   0000A9                ; Setup parameters for call to function afFindEndPointDesc
   \   0000A9   85..82       MOV     DPL,?V0 + 0
   \   0000AC   F583         MOV     DPH,A
   \   0000AE   E0           MOVX    A,@DPTR
   \   0000AF   F9           MOV     R1,A
   \   0000B0   12....       LCALL   ??afFindEndPointDesc?relay
   \   0000B3   8A82         MOV     DPL,R2
   \   0000B5   8B83         MOV     DPH,R3
   1912            if ( epDesc == NULL )
   \   0000B7   E582         MOV     A,DPL
   \   0000B9   4583         ORL     A,DPH
   \   0000BB   7003         JNZ     $+5
   \   0000BD   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1913            {
   1914              rawAFMsg = NULL;
   1915              return;   // Error, ignore the message
   1916            }
   1917          
   1918            if ( ( epDesc->simpleDesc == NULL ) ||
   1919                 ( zcl_DeviceOperational( pkt->endPoint, pkt->clusterId, inMsg.hdr.fc.type,
   1920                                          inMsg.hdr.commandID, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \   0000C0   A3           INC     DPTR
   \   0000C1   A3           INC     DPTR
   \   0000C2   A3           INC     DPTR
   \   0000C3   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   0000C6   7003         JNZ     $+5
   \   0000C8   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   \   0000CB   EE           MOV     A,R6
   \   0000CC   2404         ADD     A,#0x4
   \   0000CE   F5..         MOV     ?V0 + 2,A
   \   0000D0   EF           MOV     A,R7
   \   0000D1   3400         ADDC    A,#0x0
   \   0000D3   F5..         MOV     ?V0 + 3,A
   \   0000D5                ; Setup parameters for call to function zcl_DeviceOperational
   \   0000D5   A3           INC     DPTR
   \   0000D6   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000D9   740B         MOV     A,#0xb
   \   0000DB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DE   E0           MOVX    A,@DPTR
   \   0000DF   FD           MOV     R5,A
   \   0000E0   7406         MOV     A,#0x6
   \   0000E2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E5   E0           MOVX    A,@DPTR
   \   0000E6   5403         ANL     A,#0x3
   \   0000E8   FC           MOV     R4,A
   \   0000E9   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   0000EC   12....       LCALL   ??zcl_DeviceOperational?relay
   \   0000EF   7402         MOV     A,#0x2
   \   0000F1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F4   E9           MOV     A,R1
   \   0000F5   7003         JNZ     $+5
   \   0000F7   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1921            {
   1922              rawAFMsg = NULL;
   1923              return; // Error, ignore the message
   1924            }
   1925          
   1926          #if defined ( INTER_PAN )
   1927            if ( StubAPS_InterPan( pkt->srcAddr.panId, pkt->srcAddr.endPoint ) )
   \   0000FA                ; Setup parameters for call to function StubAPS_InterPan
   \   0000FA   EE           MOV     A,R6
   \   0000FB   240F         ADD     A,#0xf
   \   0000FD   F582         MOV     DPL,A
   \   0000FF   EF           MOV     A,R7
   \   000100   12....       LCALL   ??Subroutine136_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_262:
   \   000103   EE           MOV     A,R6
   \   000104   2410         ADD     A,#0x10
   \   000106   F582         MOV     DPL,A
   \   000108   EF           MOV     A,R7
   \   000109   12....       LCALL   ??Subroutine122_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_187:
   \   00010C   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_295:
   \   00010F   12....       LCALL   ??StubAPS_InterPan?relay
   \   000112   E9           MOV     A,R1
   \   000113   6012         JZ      ??zcl_ProcessMessageMSG_2
   1928            {
   1929              // No foundation command is supported thru Inter-PAN communication.
   1930              // But the Light Link cluster uses a different Frame Control format
   1931              // for it's Inter-PAN messages, where the messages could be confused
   1932              // with the foundation commands.
   1933              if ( zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   \   000115   7404         MOV     A,#0x4
   \   000117   12....       LCALL   ?XSTACK_DISP0_8
   \   00011A   E0           MOVX    A,@DPTR
   \   00011B   5403         ANL     A,#0x3
   \   00011D   7003         JNZ     $+5
   \   00011F   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1934              {
   1935                rawAFMsg = NULL;
   1936                return;
   1937              }
   1938          
   1939              interPanMsg = TRUE;
   \   000122   75..01       MOV     ?V0 + 4,#0x1
   1940              options = AF_TX_OPTIONS_NONE;
   \   000125   801A         SJMP    ??zcl_ProcessMessageMSG_3
   1941            }
   1942            else
   1943          #endif
   1944            {
   1945              interPanMsg = FALSE;
   \                     ??zcl_ProcessMessageMSG_2:
   \   000127   75..00       MOV     ?V0 + 4,#0x0
   1946              options = zclGetClusterOption( pkt->endPoint, pkt->clusterId );
   \   00012A                ; Setup parameters for call to function zclFindClusterOption
   \   00012A   12....       LCALL   ?Subroutine37 & 0xFFFF
   1947            }
   \                     ??CrossCallReturnLabel_38:
   \   00012D   12....       LCALL   ??zclFindClusterOption?relay
   \   000130   8A82         MOV     DPL,R2
   \   000132   8B83         MOV     DPH,R3
   \   000134   E582         MOV     A,DPL
   \   000136   4583         ORL     A,DPH
   \   000138   6007         JZ      ??zcl_ProcessMessageMSG_3
   \   00013A   A3           INC     DPTR
   \   00013B   A3           INC     DPTR
   \   00013C   E0           MOVX    A,@DPTR
   \   00013D   F5..         MOV     ?V0 + 5,A
   \   00013F   8003         SJMP    ??zcl_ProcessMessageMSG_4
   \                     ??zcl_ProcessMessageMSG_3:
   \   000141   75..00       MOV     ?V0 + 5,#0x0
   1948          
   1949            // Find the appropriate plugin
   1950            pInPlugin = zclFindPlugin( pkt->clusterId, epDesc->simpleDesc->AppProfId );
   \                     ??zcl_ProcessMessageMSG_4:
   \   000144   85..82       MOV     DPL,?V0 + 2
   \   000147   85..83       MOV     DPH,?V0 + 3
   \   00014A   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_296:
   \   00014D   EA           MOV     A,R2
   \   00014E   FC           MOV     R4,A
   \   00014F   EB           MOV     A,R3
   \   000150   FD           MOV     R5,A
   \   000151   90....       MOV     DPTR,#plugins
   \   000154   8004         SJMP    ??zcl_ProcessMessageMSG_5
   \                     ??zcl_ProcessMessageMSG_6:
   \   000156   8882         MOV     DPL,R0
   \   000158   8983         MOV     DPH,R1
   \                     ??zcl_ProcessMessageMSG_5:
   \   00015A   12....       LCALL   ??Subroutine124_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_199:
   \   00015D   7003         JNZ     $+5
   \   00015F   02....       LJMP    ??zcl_ProcessMessageMSG_7 & 0xFFFF
   \   000162   8882         MOV     DPL,R0
   \   000164   8983         MOV     DPH,R1
   \   000166   A3           INC     DPTR
   \   000167   A3           INC     DPTR
   \   000168   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   00016B   C3           CLR     C
   \   00016C   EC           MOV     A,R4
   \   00016D   95..         SUBB    A,?V0 + 6
   \   00016F   ED           MOV     A,R5
   \   000170   95..         SUBB    A,?V0 + 7
   \   000172   40E2         JC      ??zcl_ProcessMessageMSG_6
   \   000174   8882         MOV     DPL,R0
   \   000176   8983         MOV     DPH,R1
   \   000178   A3           INC     DPTR
   \   000179   A3           INC     DPTR
   \   00017A   A3           INC     DPTR
   \   00017B   A3           INC     DPTR
   \   00017C   C3           CLR     C
   \   00017D   E0           MOVX    A,@DPTR
   \   00017E   9C           SUBB    A,R4
   \   00017F   A3           INC     DPTR
   \   000180   E0           MOVX    A,@DPTR
   \   000181   9D           SUBB    A,R5
   \   000182   40D2         JC      ??zcl_ProcessMessageMSG_6
   \   000184   E8           MOV     A,R0
   \   000185   FC           MOV     R4,A
   \   000186   E9           MOV     A,R1
   \   000187   FD           MOV     R5,A
   \   000188   7404         MOV     A,#0x4
   \   00018A   12....       LCALL   ?XSTACK_DISP0_8
   \   00018D   E0           MOVX    A,@DPTR
   \   00018E   5407         ANL     A,#0x7
   \   000190   700D         JNZ     ??zcl_ProcessMessageMSG_8
   \   000192   7409         MOV     A,#0x9
   \   000194   12....       LCALL   ?XSTACK_DISP0_8
   \   000197   E0           MOVX    A,@DPTR
   \   000198   640B         XRL     A,#0xb
   \   00019A   7003         JNZ     $+5
   \   00019C   02....       LJMP    ??zcl_ProcessMessageMSG_9 & 0xFFFF
   1951            // Local and remote Security options must match except for Default Response command
   1952            if ( ( pInPlugin != NULL ) && !zcl_DefaultRspCmd( inMsg.hdr ) )
   1953            {
   1954              securityEnable = ( options & AF_EN_SECURITY ) ? TRUE : FALSE;
   1955          
   1956              // Make sure that Clusters specifically defined to use security are received secure,
   1957              // any other cluster that wants to use APS security will be allowed
   1958              if ( ( securityEnable == TRUE ) && ( pkt->SecurityUse == FALSE ) )
   \                     ??zcl_ProcessMessageMSG_8:
   \   00019F   E5..         MOV     A,?V0 + 5
   \   0001A1   A2E6         MOV     C,0xE0 /* A   */.6
   \   0001A3   4003         JC      $+5
   \   0001A5   02....       LJMP    ??zcl_ProcessMessageMSG_9 & 0xFFFF
   \   0001A8   EE           MOV     A,R6
   \   0001A9   2419         ADD     A,#0x19
   \   0001AB   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_174:
   \   0001AE   6003         JZ      $+5
   \   0001B0   02....       LJMP    ??zcl_ProcessMessageMSG_9 & 0xFFFF
   1959              {
   1960                if ( UNICAST_MSG( inMsg.msg ) )
   \   0001B3   7402         MOV     A,#0x2
   \   0001B5   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B8   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   0001BB   6003         JZ      $+5
   \   0001BD   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   \   0001C0   7402         MOV     A,#0x2
   \   0001C2   12....       LCALL   ?XSTACK_DISP0_8
   \   0001C5   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_206:
   \   0001C8   6003         JZ      $+5
   \   0001CA   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1961                {
   1962                  // Send a Default Response command back with no Application Link Key security
   1963                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, FALSE );
   \   0001CD                ; Setup parameters for call to function zclSetSecurityOption
   \   0001CD   7C00         MOV     R4,#0x0
   \   0001CF   85..82       MOV     DPL,?V0 + 0
   \   0001D2   85..83       MOV     DPH,?V0 + 1
   \   0001D5   E0           MOVX    A,@DPTR
   \   0001D6   F9           MOV     R1,A
   \   0001D7   12....       LCALL   ??zclSetSecurityOption?relay
   1964          
   1965                  defautlRspCmd.statusCode = status;
   \   0001DA   7401         MOV     A,#0x1
   \   0001DC   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DF   7401         MOV     A,#0x1
   \   0001E1   F0           MOVX    @DPTR,A
   1966                  defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0001E2   7409         MOV     A,#0x9
   \   0001E4   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E7   12....       LCALL   ?Subroutine64 & 0xFFFF
   1967                  zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   1968                                         inMsg.msg->clusterId, &defautlRspCmd,
   1969                                         !inMsg.hdr.fc.direction, true,
   1970                                         inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_81:
   \   0001EA   12....       LCALL   ?XSTACK_DISP0_8
   \   0001ED   E0           MOVX    A,@DPTR
   \   0001EE   F5..         MOV     ?V0 + 4,A
   \   0001F0   78..         MOV     R0,#?V0 + 4
   \   0001F2   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001F5   7407         MOV     A,#0x7
   \   0001F7   12....       LCALL   ?XSTACK_DISP0_8
   \   0001FA   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0001FD   75..01       MOV     ?V0 + 4,#0x1
   \   000200   78..         MOV     R0,#?V0 + 4
   \   000202   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000205   7408         MOV     A,#0x8
   \   000207   12....       LCALL   ?XSTACK_DISP0_8
   \   00020A   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   00020D   F5..         MOV     ?V0 + 4,A
   \   00020F   78..         MOV     R0,#?V0 + 4
   \   000211   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000214   7405         MOV     A,#0x5
   \   000216   12....       LCALL   ?XSTACK_DISP0_8
   \   000219   8582..       MOV     ?V0 + 4,DPL
   \   00021C   8583..       MOV     ?V0 + 5,DPH
   \   00021F   78..         MOV     R0,#?V0 + 4
   \   000221   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000224   7409         MOV     A,#0x9
   \   000226   12....       LCALL   ?XSTACK_DISP0_8
   \   000229   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   00022C   12....       LCALL   ?XSTACK_DISP0_8
   \   00022F   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   000232   12....       LCALL   ?XSTACK_DISP0_8
   \   000235   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000238   12....       LCALL   ??zcl_SendDefaultRspCmd?relay
   \   00023B   7407         MOV     A,#0x7
   \   00023D   12....       LCALL   ?DEALLOC_XSTACK8
   1971          
   1972                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, TRUE );
   \   000240                ; Setup parameters for call to function zclSetSecurityOption
   \   000240   7C01         MOV     R4,#0x1
   \   000242   12....       LCALL   ?Subroutine37 & 0xFFFF
   1973                }
   1974          
   1975                rawAFMsg = NULL;
   1976                return;   // Error, ignore the message
   1977              }
   1978            }
   \                     ??CrossCallReturnLabel_39:
   \   000245   12....       LCALL   ??zclSetSecurityOption?relay
   \   000248   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   \                     ??zcl_ProcessMessageMSG_7:
   \   00024B   7C00         MOV     R4,#0x0
   \   00024D   7D00         MOV     R5,#0x0
   1979          
   1980            // Is this a foundation type message
   1981            if ( !interPanMsg && zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   \                     ??zcl_ProcessMessageMSG_9:
   \   00024F   E5..         MOV     A,?V0 + 4
   \   000251   A2E0         MOV     C,0xE0 /* A   */.0
   \   000253   5003         JNC     $+5
   \   000255   02....       LJMP    ??zcl_ProcessMessageMSG_10 & 0xFFFF
   \   000258   7404         MOV     A,#0x4
   \   00025A   12....       LCALL   ?XSTACK_DISP0_8
   \   00025D   E0           MOVX    A,@DPTR
   \   00025E   F8           MOV     R0,A
   \   00025F   5403         ANL     A,#0x3
   \   000261   6003         JZ      $+5
   \   000263   02....       LJMP    ??zcl_ProcessMessageMSG_10 & 0xFFFF
   1982            {
   1983              if ( inMsg.hdr.fc.manuSpecific )
   \   000266   E8           MOV     A,R0
   \   000267   5404         ANL     A,#0x4
   \   000269   6005         JZ      ??zcl_ProcessMessageMSG_11
   1984              {
   1985                // We don't support any manufacturer specific command
   1986                status = ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND;
   \   00026B   7A84         MOV     R2,#-0x7c
   \   00026D   02....       LJMP    ??zcl_ProcessMessageMSG_12 & 0xFFFF
   1987              }
   1988              else if ( ( inMsg.hdr.commandID <= ZCL_CMD_MAX ) &&
   1989                        ( zclCmdTable[inMsg.hdr.commandID].pfnParseInProfile != NULL ) )
   \                     ??zcl_ProcessMessageMSG_11:
   \   000270   7409         MOV     A,#0x9
   \   000272   12....       LCALL   ?XSTACK_DISP0_8
   \   000275   E0           MOVX    A,@DPTR
   \   000276   F5..         MOV     ?V0 + 2,A
   \   000278   C3           CLR     C
   \   000279   9417         SUBB    A,#0x17
   \   00027B   4003         JC      $+5
   \   00027D   02....       LJMP    ??zcl_ProcessMessageMSG_13 & 0xFFFF
   \   000280   75..00       MOV     ?V0 + 3,#0x0
   \   000283   7402         MOV     A,#0x2
   \   000285   78..         MOV     R0,#?V0 + 2
   \   000287   12....       LCALL   ?S_SHL
   \   00028A   74..         MOV     A,#zclCmdTable & 0xff
   \   00028C   25..         ADD     A,?V0 + 2
   \   00028E   F582         MOV     DPL,A
   \   000290   74..         MOV     A,#(zclCmdTable >> 8) & 0xff
   \   000292   35..         ADDC    A,?V0 + 3
   \   000294   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_117:
   \   000297   7003         JNZ     $+5
   \   000299   02....       LJMP    ??zcl_ProcessMessageMSG_13 & 0xFFFF
   1990              {
   1991                zclParseCmd_t parseCmd;
   1992          
   1993                parseCmd.endpoint = pkt->endPoint;
   \   00029C   85..82       MOV     DPL,?V0 + 0
   \   00029F   85..83       MOV     DPH,?V0 + 1
   \   0002A2   E0           MOVX    A,@DPTR
   \   0002A3   C0E0         PUSH    A
   \   0002A5   7410         MOV     A,#0x10
   \   0002A7   12....       LCALL   ?XSTACK_DISP0_8
   \   0002AA   D0E0         POP     A
   \   0002AC   F0           MOVX    @DPTR,A
   1994                parseCmd.dataLen = inMsg.pDataLen;
   \   0002AD   740C         MOV     A,#0xc
   \   0002AF   12....       LCALL   ?XSTACK_DISP0_8
   \   0002B2   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_278:
   \   0002B5   7411         MOV     A,#0x11
   \   0002B7   12....       LCALL   ?XSTACK_DISP0_8
   \   0002BA   12....       LCALL   ??Subroutine130_0 & 0xFFFF
   1995                parseCmd.pData = inMsg.pData;
   \                     ??CrossCallReturnLabel_244:
   \   0002BD   740A         MOV     A,#0xa
   \   0002BF   12....       LCALL   ?XSTACK_DISP0_8
   \   0002C2   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_279:
   \   0002C5   7413         MOV     A,#0x13
   \   0002C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0002CA   12....       LCALL   ??Subroutine130_0 & 0xFFFF
   1996          
   1997                // Parse the command, remember that the return value is a pointer to allocated memory
   1998                inMsg.attrCmd = zclParseCmd( inMsg.hdr.commandID, &parseCmd );
   \                     ??CrossCallReturnLabel_245:
   \   0002CD                ; Setup parameters for indirect call
   \   0002CD   7410         MOV     A,#0x10
   \   0002CF   12....       LCALL   ?XSTACK_DISP0_8
   \   0002D2   AA82         MOV     R2,DPL
   \   0002D4   AB83         MOV     R3,DPH
   \   0002D6   7409         MOV     A,#0x9
   \   0002D8   12....       LCALL   ?XSTACK_DISP0_8
   \   0002DB   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   0002DE   12....       LCALL   ?S_SHL
   \   0002E1   74..         MOV     A,#zclCmdTable & 0xff
   \   0002E3   25..         ADD     A,?V0 + 0
   \   0002E5   F582         MOV     DPL,A
   \   0002E7   74..         MOV     A,#(zclCmdTable >> 8) & 0xff
   \   0002E9   35..         ADDC    A,?V0 + 1
   \   0002EB   F583         MOV     DPH,A
   \   0002ED   E4           CLR     A
   \   0002EE   93           MOVC    A,@A+DPTR
   \   0002EF   C0E0         PUSH    A
   \   0002F1   7401         MOV     A,#0x1
   \   0002F3   93           MOVC    A,@A+DPTR
   \   0002F4   F583         MOV     DPH,A
   \   0002F6   D082         POP     DPL
   \   0002F8   12....       LCALL   ?CALL_IND
   \   0002FB   8A..         MOV     ?V0 + 0,R2
   \   0002FD   8B..         MOV     ?V0 + 1,R3
   \   0002FF   A8..         MOV     R0,?V0 + 0
   \   000301   A9..         MOV     R1,?V0 + 1
   \   000303   740E         MOV     A,#0xe
   \   000305   12....       LCALL   ?XSTACK_DISP0_8
   \   000308   12....       LCALL   ??Subroutine130_0 & 0xFFFF
   1999                if ( (inMsg.attrCmd != NULL) && (zclCmdTable[inMsg.hdr.commandID].pfnProcessInProfile != NULL) )
   \                     ??CrossCallReturnLabel_246:
   \   00030B   E8           MOV     A,R0
   \   00030C   49           ORL     A,R1
   \   00030D   603F         JZ      ??zcl_ProcessMessageMSG_14
   \   00030F   7409         MOV     A,#0x9
   \   000311   12....       LCALL   ?XSTACK_DISP0_8
   \   000314   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   000317   12....       LCALL   ?S_SHL
   \   00031A   74..         MOV     A,#(zclCmdTable + 2) & 0xff
   \   00031C   25..         ADD     A,?V0 + 0
   \   00031E   F582         MOV     DPL,A
   \   000320   74..         MOV     A,#((zclCmdTable + 2) >> 8) & 0xff
   \   000322   35..         ADDC    A,?V0 + 1
   \   000324   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   000327   601A         JZ      ??zcl_ProcessMessageMSG_15
   2000                {
   2001                  // Process the command
   2002                  if ( zclProcessCmd( inMsg.hdr.commandID, &inMsg ) == FALSE )
   \   000329                ; Setup parameters for indirect call
   \   000329   7402         MOV     A,#0x2
   \   00032B   12....       LCALL   ?XSTACK_DISP0_8
   \   00032E   AA82         MOV     R2,DPL
   \   000330   AB83         MOV     R3,DPH
   \   000332   8882         MOV     DPL,R0
   \   000334   8983         MOV     DPH,R1
   \   000336   12....       LCALL   ?CALL_IND
   2003                  {
   2004                    // Couldn't find attribute in the table.
   2005                  }
   2006                }
   2007          
   2008                // Free the buffer
   2009                if ( inMsg.attrCmd )
   \   000339   740E         MOV     A,#0xe
   \   00033B   12....       LCALL   ?XSTACK_DISP0_8
   \   00033E   12....       LCALL   ??Subroutine124_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_200:
   \   000341   600B         JZ      ??zcl_ProcessMessageMSG_14
   2010                {
   2011                  zcl_mem_free( inMsg.attrCmd );
   \                     ??zcl_ProcessMessageMSG_15:
   \   000343                ; Setup parameters for call to function osal_mem_free
   \   000343   740E         MOV     A,#0xe
   \   000345   12....       LCALL   ?XSTACK_DISP0_8
   \   000348   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   2012                }
   \                     ??CrossCallReturnLabel_297:
   \   00034B   12....       LCALL   ??osal_mem_free?relay
   2013          
   2014                if ( CMD_HAS_RSP( inMsg.hdr.commandID ) )
   \                     ??zcl_ProcessMessageMSG_14:
   \   00034E   7409         MOV     A,#0x9
   \   000350   12....       LCALL   ?XSTACK_DISP0_8
   \   000353   E0           MOVX    A,@DPTR
   \   000354   F8           MOV     R0,A
   \   000355   7003         JNZ     $+5
   \   000357   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   \   00035A   7402         MOV     A,#0x2
   \   00035C   68           XRL     A,R0
   \   00035D   7003         JNZ     $+5
   \   00035F   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   \   000362   7403         MOV     A,#0x3
   \   000364   68           XRL     A,R0
   \   000365   7003         JNZ     $+5
   \   000367   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   \   00036A   7406         MOV     A,#0x6
   \   00036C   68           XRL     A,R0
   \   00036D   7003         JNZ     $+5
   \   00036F   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   \   000372   7408         MOV     A,#0x8
   \   000374   68           XRL     A,R0
   \   000375   7003         JNZ     $+5
   \   000377   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   \   00037A   740C         MOV     A,#0xc
   \   00037C   68           XRL     A,R0
   \   00037D   7003         JNZ     $+5
   \   00037F   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   \   000382   7411         MOV     A,#0x11
   \   000384   68           XRL     A,R0
   \   000385   7003         JNZ     $+5
   \   000387   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   \   00038A   7413         MOV     A,#0x13
   \   00038C   68           XRL     A,R0
   \   00038D   7003         JNZ     $+5
   \   00038F   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   \   000392   7415         MOV     A,#0x15
   \   000394   68           XRL     A,R0
   \   000395   7003         JNZ     $+5
   \   000397   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   \   00039A   740B         MOV     A,#0xb
   \   00039C   68           XRL     A,R0
   \   00039D   7003         JNZ     $+5
   \   00039F   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2015                {
   2016                  rawAFMsg = NULL;
   2017                  return; // We're done
   2018                }
   2019          
   2020                status = ZSuccess;
   \   0003A2   7A00         MOV     R2,#0x0
   \   0003A4   8050         SJMP    ??zcl_ProcessMessageMSG_12
   2021              }
   2022              else
   2023              {
   2024                // Unsupported message
   2025                status = ZCL_STATUS_UNSUP_GENERAL_COMMAND;
   \                     ??zcl_ProcessMessageMSG_13:
   \   0003A6   7A82         MOV     R2,#-0x7e
   \   0003A8   804C         SJMP    ??zcl_ProcessMessageMSG_12
   2026              }
   2027            }
   2028            else  // Not a foundation type message, so it must be specific to the cluster ID.
   2029            {
   2030              if ( pInPlugin && pInPlugin->pfnIncomingHdlr )
   \                     ??zcl_ProcessMessageMSG_10:
   \   0003AA   EC           MOV     A,R4
   \   0003AB   4D           ORL     A,R5
   \   0003AC   6038         JZ      ??zcl_ProcessMessageMSG_16
   \   0003AE   8C82         MOV     DPL,R4
   \   0003B0   8D83         MOV     DPH,R5
   \   0003B2   A3           INC     DPTR
   \   0003B3   A3           INC     DPTR
   \   0003B4   A3           INC     DPTR
   \   0003B5   A3           INC     DPTR
   \   0003B6   12....       LCALL   ??Subroutine123_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_205:
   \   0003B9   602B         JZ      ??zcl_ProcessMessageMSG_16
   2031              {
   2032                // The return value of the plugin function will be
   2033                //  ZSuccess - Supported and need default response
   2034                //  ZFailure - Unsupported
   2035                //  ZCL_STATUS_CMD_HAS_RSP - Supported and do not need default rsp
   2036                //  ZCL_STATUS_INVALID_FIELD - Supported, but the incoming msg is wrong formatted
   2037                //  ZCL_STATUS_INVALID_VALUE - Supported, but the request not achievable by the h/w
   2038                //  ZCL_STATUS_SOFTWARE_FAILURE - Supported but ZStack memory allocation fails
   2039                status = pInPlugin->pfnIncomingHdlr( &inMsg );
   \   0003BB                ; Setup parameters for indirect call
   \   0003BB   7402         MOV     A,#0x2
   \   0003BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0003C0   AA82         MOV     R2,DPL
   \   0003C2   AB83         MOV     R3,DPH
   \   0003C4   8882         MOV     DPL,R0
   \   0003C6   8983         MOV     DPH,R1
   \   0003C8   12....       LCALL   ?CALL_IND
   \   0003CB   E9           MOV     A,R1
   \   0003CC   FA           MOV     R2,A
   2040                if ( status == ZCL_STATUS_CMD_HAS_RSP || ( interPanMsg && status == ZSuccess ) )
   \   0003CD   74FF         MOV     A,#-0x1
   \   0003CF   6A           XRL     A,R2
   \   0003D0   7003         JNZ     $+5
   \   0003D2   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   \   0003D5   E5..         MOV     A,?V0 + 4
   \   0003D7   A2E0         MOV     C,0xE0 /* A   */.0
   \   0003D9   5006         JNC     ??zcl_ProcessMessageMSG_17
   \   0003DB   EA           MOV     A,R2
   \   0003DC   7003         JNZ     $+5
   \   0003DE   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2041                {
   2042                  rawAFMsg = NULL;
   2043                  return; // We're done
   2044                }
   2045              }
   2046          
   2047              if ( status == ZFailure )
   \                     ??zcl_ProcessMessageMSG_17:
   \   0003E1   7401         MOV     A,#0x1
   \   0003E3   6A           XRL     A,R2
   \   0003E4   7010         JNZ     ??zcl_ProcessMessageMSG_12
   2048              {
   2049                // Unsupported message
   2050                if ( inMsg.hdr.fc.manuSpecific )
   \                     ??zcl_ProcessMessageMSG_16:
   \   0003E6   7404         MOV     A,#0x4
   \   0003E8   12....       LCALL   ?XSTACK_DISP0_8
   \   0003EB   E0           MOVX    A,@DPTR
   \   0003EC   5404         ANL     A,#0x4
   \   0003EE   6004         JZ      ??zcl_ProcessMessageMSG_18
   2051                {
   2052                  status = ZCL_STATUS_UNSUP_MANU_CLUSTER_COMMAND;
   \   0003F0   7A83         MOV     R2,#-0x7d
   \   0003F2   8002         SJMP    ??zcl_ProcessMessageMSG_12
   2053                }
   2054                else
   2055                {
   2056                  status = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   \                     ??zcl_ProcessMessageMSG_18:
   \   0003F4   7A81         MOV     R2,#-0x7f
   2057                }
   2058              }
   2059            }
   2060          
   2061            if ( UNICAST_MSG( inMsg.msg ) && inMsg.hdr.fc.disableDefaultRsp == 0 )
   \                     ??zcl_ProcessMessageMSG_12:
   \   0003F6   7402         MOV     A,#0x2
   \   0003F8   12....       LCALL   ?XSTACK_DISP0_8
   \   0003FB   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   0003FE   7079         JNZ     ??zcl_ProcessMessageMSG_1
   \   000400   7402         MOV     A,#0x2
   \   000402   12....       LCALL   ?XSTACK_DISP0_8
   \   000405   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_207:
   \   000408   706F         JNZ     ??zcl_ProcessMessageMSG_1
   \   00040A   7404         MOV     A,#0x4
   \   00040C   12....       LCALL   ?XSTACK_DISP0_8
   \   00040F   E0           MOVX    A,@DPTR
   \   000410   5410         ANL     A,#0x10
   \   000412   7065         JNZ     ??zcl_ProcessMessageMSG_1
   2062            {
   2063              // Send a Default Response command back
   2064              defautlRspCmd.statusCode = status;
   \   000414   7401         MOV     A,#0x1
   \   000416   12....       LCALL   ?XSTACK_DISP0_8
   \   000419   EA           MOV     A,R2
   \   00041A   F0           MOVX    @DPTR,A
   2065              defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   00041B   7409         MOV     A,#0x9
   \   00041D   12....       LCALL   ?XSTACK_DISP0_8
   \   000420   12....       LCALL   ?Subroutine64 & 0xFFFF
   2066              zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   2067                                     inMsg.msg->clusterId, &defautlRspCmd,
   2068                                     !inMsg.hdr.fc.direction, true,
   2069                                     inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   2070            }
   \                     ??CrossCallReturnLabel_82:
   \   000423   12....       LCALL   ?XSTACK_DISP0_8
   \   000426   E0           MOVX    A,@DPTR
   \   000427   F5..         MOV     ?V0 + 0,A
   \   000429   78..         MOV     R0,#?V0 + 0
   \   00042B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00042E   7407         MOV     A,#0x7
   \   000430   12....       LCALL   ?XSTACK_DISP0_8
   \   000433   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000436   75..01       MOV     ?V0 + 0,#0x1
   \   000439   78..         MOV     R0,#?V0 + 0
   \   00043B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00043E   7408         MOV     A,#0x8
   \   000440   12....       LCALL   ?XSTACK_DISP0_8
   \   000443   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   000446   F5..         MOV     ?V0 + 0,A
   \   000448   78..         MOV     R0,#?V0 + 0
   \   00044A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00044D   7405         MOV     A,#0x5
   \   00044F   12....       LCALL   ?XSTACK_DISP0_8
   \   000452   8582..       MOV     ?V0 + 0,DPL
   \   000455   8583..       MOV     ?V0 + 1,DPH
   \   000458   78..         MOV     R0,#?V0 + 0
   \   00045A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00045D   7409         MOV     A,#0x9
   \   00045F   12....       LCALL   ?XSTACK_DISP0_8
   \   000462   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000465   12....       LCALL   ?XSTACK_DISP0_8
   \   000468   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   00046B   12....       LCALL   ?XSTACK_DISP0_8
   \   00046E   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000471   12....       LCALL   ??zcl_SendDefaultRspCmd?relay
   \   000474   7407         MOV     A,#0x7
   \   000476   12....       LCALL   ?DEALLOC_XSTACK8
   2071          
   2072            rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_1:
   \   000479   90....       MOV     DPTR,#rawAFMsg
   \   00047C   E4           CLR     A
   \   00047D   F0           MOVX    @DPTR,A
   \   00047E   A3           INC     DPTR
   \   00047F   F0           MOVX    @DPTR,A
   2073          }
   \                     ??zcl_ProcessMessageMSG_0:
   \   000480   7415         MOV     A,#0x15
   \   000482   02....       LJMP    ?Subroutine6 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine84:
   \   000000   F583         MOV     DPH,A
   \   000002   E4           CLR     A
   \   000003   93           MOVC    A,@A+DPTR
   \   000004   F8           MOV     R0,A
   \   000005   7401         MOV     A,#0x1
   \   000007   93           MOVC    A,@A+DPTR
   \   000008   F9           MOV     R1,A
   \   000009   E8           MOV     A,R0
   \   00000A   49           ORL     A,R1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine77:
   \   000000   F582         MOV     DPL,A
   \   000002   EF           MOV     A,R7
   \   000003                REQUIRE ??Subroutine117_0
   \   000003                ; // Fall through to label ??Subroutine117_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_256:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine97:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   13           RRC     A
   \   000002   13           RRC     A
   \   000003   13           RRC     A
   \   000004   541F         ANL     A,#0x1f
   \   000006   6401         XRL     A,#0x1
   \   000008   5401         ANL     A,#0x1
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_142:
   \   000003                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000003                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000003   7408         MOV     A,#0x8
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 0,A
   \   000003   75..00       MOV     ?V0 + 1,#0x0
   \   000006   7402         MOV     A,#0x2
   \   000008   78..         MOV     R0,#?V0 + 0
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2406         ADD     A,#0x6
   \   000003   FA           MOV     R2,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   3400         ADDC    A,#0x0
   \   000008   FB           MOV     R3,A
   \   000009   7409         MOV     A,#0x9
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   12....       LCALL   ?Subroutine111 & 0xFFFF
   \                     ??CrossCallReturnLabel_345:
   \   000003   E8           MOV     A,R0
   \   000004   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_272:
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   C8           XCH     A,R0
   \   000005   2415         ADD     A,#0x15
   \   000007   F582         MOV     DPL,A
   \   000009   E8           MOV     A,R0
   \   00000A   12....       LCALL   ??Subroutine122_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_189:
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_138:
   \   000003   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_333:
   \   000006   7409         MOV     A,#0x9
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   85..82       MOV     DPL,?V0 + 2
   \   000003   85..83       MOV     DPH,?V0 + 3
   \   000006   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_310:
   \   000009   85..82       MOV     DPL,?V0 + 0
   \   00000C   85..83       MOV     DPH,?V0 + 1
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F9           MOV     R1,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine121_0
   \   000003                ; // Fall through to label ??Subroutine121_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine121_0:
   \   000000   7F08         MOV     R7,#0x8
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F9           MOV     R1,A
   \   000003   88..         MOV     ?V0 + 0,R0
   \   000005   89..         MOV     ?V0 + 1,R1
   \   000007                ; Setup parameters for call to function zclGetAttrDataLength
   \   000007   8882         MOV     DPL,R0
   \   000009   F583         MOV     DPH,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_140:
   \   000003   E582         MOV     A,DPL
   \   000005   4583         ORL     A,DPH
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 6,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 7,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_136:
   \   000003                REQUIRE ??Subroutine123_0
   \   000003                ; // Fall through to label ??Subroutine123_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine123_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine124_0
   \   000002                ; // Fall through to label ??Subroutine124_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine96:
   \   000000   12....       LCALL   ?Subroutine109 & 0xFFFF
   \                     ??CrossCallReturnLabel_152:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine109:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine136_0:
   \   000000   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_274:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine102:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F583         MOV     DPH,A
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F9           MOV     R1,A
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine91:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004                REQUIRE ??Subroutine145_0
   \   000004                ; // Fall through to label ??Subroutine145_0
   2074          
   2075          /*********************************************************************
   2076           * PRIVATE FUNCTIONS
   2077           *********************************************************************/
   2078          
   2079          /*********************************************************************
   2080           * @fn      zclParseHdr
   2081           *
   2082           * @brief   Parse header of the ZCL format
   2083           *
   2084           * @param   hdr - place to put the frame control information
   2085           * @param   pData - incoming buffer to parse
   2086           *
   2087           * @return  pointer past the header
   2088           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2089          uint8 *zclParseHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclParseHdr:
   2090          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   2091            // Clear the header
   2092            zcl_memset( (uint8 *)hdr, 0, sizeof ( zclFrameHdr_t ) );
   \   00000D                ; Setup parameters for call to function osal_memset
   \   00000D   7C06         MOV     R4,#0x6
   \   00000F   7D00         MOV     R5,#0x0
   \   000011   7900         MOV     R1,#0x0
   \   000013   12....       LCALL   ??osal_memset?relay
   2093          
   2094            // Parse the Frame Control
   2095            hdr->fc.type = zcl_FCType( *pData );
   \   000016   85..82       MOV     DPL,?V0 + 0
   \   000019   85..83       MOV     DPH,?V0 + 1
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   54FC         ANL     A,#0xfc
   \   00001F   F8           MOV     R0,A
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   F9           MOV     R1,A
   \   000023   8E82         MOV     DPL,R6
   \   000025   8F83         MOV     DPH,R7
   \   000027   E0           MOVX    A,@DPTR
   \   000028   5403         ANL     A,#0x3
   \   00002A   FA           MOV     R2,A
   \   00002B   E8           MOV     A,R0
   \   00002C   4A           ORL     A,R2
   \   00002D   F8           MOV     R0,A
   \   00002E   12....       LCALL   ?Subroutine24 & 0xFFFF
   2096            hdr->fc.manuSpecific = zcl_FCManuSpecific( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_25:
   \   000031   A2E2         MOV     C,0xE0 /* A   */.2
   \   000033   5004         JNC     ??zclParseHdr_0
   \   000035   D2F0         SETB    B.0
   \   000037   8002         SJMP    ??zclParseHdr_1
   \                     ??zclParseHdr_0:
   \   000039   C2F0         CLR     B.0
   \                     ??zclParseHdr_1:
   \   00003B   E8           MOV     A,R0
   \   00003C   54FB         ANL     A,#0xfb
   \   00003E   FA           MOV     R2,A
   \   00003F   A2F0         MOV     C,B.0
   \   000041   E4           CLR     A
   \   000042   33           RLC     A
   \   000043   F5..         MOV     ?V0 + 2,A
   \   000045   75..00       MOV     ?V0 + 3,#0x0
   \   000048   7402         MOV     A,#0x2
   \   00004A   78..         MOV     R0,#?V0 + 2
   \   00004C   12....       LCALL   ?S_SHL
   \   00004F   EA           MOV     A,R2
   \   000050   45..         ORL     A,?V0 + 2
   \   000052   12....       LCALL   ?Subroutine24 & 0xFFFF
   2097            if ( zcl_FCDirection( *pData ) )
   \                     ??CrossCallReturnLabel_26:
   \   000055   A2E3         MOV     C,0xE0 /* A   */.3
   \   000057   85..82       MOV     DPL,?V0 + 0
   \   00005A   85..83       MOV     DPH,?V0 + 1
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   5004         JNC     ??zclParseHdr_2
   2098            {
   2099              hdr->fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   000060   4408         ORL     A,#0x8
   \   000062   8002         SJMP    ??zclParseHdr_3
   2100            }
   2101            else
   2102            {
   2103              hdr->fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zclParseHdr_2:
   \   000064   54F7         ANL     A,#0xf7
   2104            }
   \                     ??zclParseHdr_3:
   \   000066   12....       LCALL   ?Subroutine108 & 0xFFFF
   2105          
   2106            hdr->fc.disableDefaultRsp = zcl_FCDisableDefaultRsp( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_213:
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   A2E4         MOV     C,0xE0 /* A   */.4
   \   00006C   5004         JNC     ??zclParseHdr_4
   \   00006E   D2F0         SETB    B.0
   \   000070   8002         SJMP    ??zclParseHdr_5
   \                     ??zclParseHdr_4:
   \   000072   C2F0         CLR     B.0
   \                     ??zclParseHdr_5:
   \   000074   85..82       MOV     DPL,?V0 + 0
   \   000077   85..83       MOV     DPH,?V0 + 1
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   54EF         ANL     A,#0xef
   \   00007D   FA           MOV     R2,A
   \   00007E   A2F0         MOV     C,B.0
   \   000080   E4           CLR     A
   \   000081   33           RLC     A
   \   000082   F5..         MOV     ?V0 + 2,A
   \   000084   7404         MOV     A,#0x4
   \   000086   78..         MOV     R0,#?V0 + 2
   \   000088   12....       LCALL   ?S_SHL
   \   00008B   EA           MOV     A,R2
   \   00008C   45..         ORL     A,?V0 + 2
   \   00008E   F8           MOV     R0,A
   \   00008F   F0           MOVX    @DPTR,A
   \   000090   A3           INC     DPTR
   \   000091   E9           MOV     A,R1
   \   000092   12....       LCALL   ??Subroutine125_0 & 0xFFFF
   2107            pData++;  // move past the frame control field
   2108          
   2109            // parse the manfacturer code
   2110            if ( hdr->fc.manuSpecific )
   \                     ??CrossCallReturnLabel_208:
   \   000095   E8           MOV     A,R0
   \   000096   5404         ANL     A,#0x4
   \   000098   6014         JZ      ??CrossCallReturnLabel_96
   2111            {
   2112              hdr->manuCode = BUILD_UINT16( pData[0], pData[1] );
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   FA           MOV     R2,A
   \   00009C   A3           INC     DPTR
   \   00009D   E0           MOVX    A,@DPTR
   \   00009E   F9           MOV     R1,A
   \   00009F   EA           MOV     A,R2
   \   0000A0   85..82       MOV     DPL,?V0 + 0
   \   0000A3   85..83       MOV     DPH,?V0 + 1
   \   0000A6   A3           INC     DPTR
   \   0000A7   A3           INC     DPTR
   \   0000A8   12....       LCALL   ??Subroutine131_0 & 0xFFFF
   2113              pData += 2;
   \                     ??CrossCallReturnLabel_240:
   \   0000AB   12....       LCALL   ?Subroutine72 & 0xFFFF
   2114            }
   2115          
   2116            // parse the Transaction Sequence Number
   2117            hdr->transSeqNum = *pData++;
   \                     ??CrossCallReturnLabel_96:
   \   0000AE   8E82         MOV     DPL,R6
   \   0000B0   8F83         MOV     DPH,R7
   \   0000B2   E0           MOVX    A,@DPTR
   \   0000B3   85..82       MOV     DPL,?V0 + 0
   \   0000B6   85..83       MOV     DPH,?V0 + 1
   \   0000B9   A3           INC     DPTR
   \   0000BA   A3           INC     DPTR
   \   0000BB   A3           INC     DPTR
   \   0000BC   12....       LCALL   ?Subroutine16 & 0xFFFF
   2118          
   2119            // parse the Cluster's command ID
   2120            hdr->commandID = *pData++;
   \                     ??CrossCallReturnLabel_12:
   \   0000BF   85..82       MOV     DPL,?V0 + 0
   \   0000C2   85..83       MOV     DPH,?V0 + 1
   \   0000C5   A3           INC     DPTR
   \   0000C6   A3           INC     DPTR
   \   0000C7   12....       LCALL   ?Subroutine18 & 0xFFFF
   2121          
   2122            // Should point to the frame payload
   2123            return ( pData );
   \                     ??CrossCallReturnLabel_178:
   \   0000CA   AA82         MOV     R2,DPL
   \   0000CC   AB83         MOV     R3,DPH
   \   0000CE   02....       LJMP    ?Subroutine1 & 0xFFFF
   2124          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   85..82       MOV     DPL,?V0 + 0
   \   000003   85..83       MOV     DPH,?V0 + 1
   \   000006   F0           MOVX    @DPTR,A
   \   000007   A3           INC     DPTR
   \   000008   E9           MOV     A,R1
   \   000009   12....       LCALL   ?Subroutine108 & 0xFFFF
   \                     ??CrossCallReturnLabel_214:
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine118_0
   \   000003                ; // Fall through to label ??Subroutine118_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   EE           MOV     A,R6
   \   000001   2402         ADD     A,#0x2
   \   000003   FE           MOV     R6,A
   \   000004   EF           MOV     A,R7
   \   000005   3400         ADDC    A,#0x0
   \   000007   FF           MOV     R7,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine125_0:
   \   000000   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_211:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine88:
   \   000000   12....       LCALL   ?Subroutine108 & 0xFFFF
   \                     ??CrossCallReturnLabel_216:
   \   000003   A3           INC     DPTR
   \   000004   AE82         MOV     R6,DPL
   \   000006   AF83         MOV     R7,DPH
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   A3           INC     DPTR
   \   000001   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_212:
   \   000004   E0           MOVX    A,@DPTR
   \   000005   22           RET
   2125          
   2126          /*********************************************************************
   2127           * @fn      zclBuildHdr
   2128           *
   2129           * @brief   Build header of the ZCL format
   2130           *
   2131           * @param   hdr - outgoing header information
   2132           * @param   pData - outgoing header space
   2133           *
   2134           * @return  pointer past the header
   2135           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2136          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclBuildHdr:
   2137          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   2138            // Build the Frame Control byte
   2139            *pData = hdr->fc.type;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   5403         ANL     A,#0x3
   \   00000C   8C82         MOV     DPL,R4
   \   00000E   8D83         MOV     DPH,R5
   \   000010   12....       LCALL   ??Subroutine119_0 & 0xFFFF
   2140            *pData |= hdr->fc.manuSpecific << 2;
   \                     ??CrossCallReturnLabel_182:
   \   000013   5404         ANL     A,#0x4
   \   000015   12....       LCALL   ?Subroutine28 & 0xFFFF
   2141            *pData |= hdr->fc.direction << 3;
   \                     ??CrossCallReturnLabel_180:
   \   000018   5408         ANL     A,#0x8
   \   00001A   12....       LCALL   ?Subroutine28 & 0xFFFF
   2142            *pData |= hdr->fc.disableDefaultRsp << 4;
   \                     ??CrossCallReturnLabel_181:
   \   00001D   5410         ANL     A,#0x10
   \   00001F   F8           MOV     R0,A
   \   000020   8C82         MOV     DPL,R4
   \   000022   8D83         MOV     DPH,R5
   \   000024   E0           MOVX    A,@DPTR
   \   000025   48           ORL     A,R0
   \   000026   12....       LCALL   ?Subroutine86 & 0xFFFF
   2143            pData++;  // move past the frame control field
   2144          
   2145            // Add the manfacturer code
   2146            if ( hdr->fc.manuSpecific )
   \                     ??CrossCallReturnLabel_121:
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   5404         ANL     A,#0x4
   \   00002C   600B         JZ      ??CrossCallReturnLabel_184
   2147            {
   2148              *pData++ = LO_UINT16( hdr->manuCode );
   \   00002E   12....       LCALL   ?Subroutine26 & 0xFFFF
   2149              *pData++ = HI_UINT16( hdr->manuCode );
   \                     ??CrossCallReturnLabel_186:
   \   000031   8882         MOV     DPL,R0
   \   000033   8983         MOV     DPH,R1
   \   000035   A3           INC     DPTR
   \   000036   12....       LCALL   ??Subroutine120_0 & 0xFFFF
   2150            }
   2151          
   2152            // Add the Transaction Sequence Number
   2153            *pData++ = hdr->transSeqNum;
   \                     ??CrossCallReturnLabel_184:
   \   000039   8A82         MOV     DPL,R2
   \   00003B   8B83         MOV     DPH,R3
   \   00003D   A3           INC     DPTR
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   12....       LCALL   ?Subroutine19 & 0xFFFF
   2154          
   2155            // Add the Cluster's command ID
   2156            *pData++ = hdr->commandID;
   \                     ??CrossCallReturnLabel_15:
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   E0           MOVX    A,@DPTR
   \   000049   8C82         MOV     DPL,R4
   \   00004B   8D83         MOV     DPH,R5
   \   00004D   F0           MOVX    @DPTR,A
   \   00004E   A3           INC     DPTR
   2157          
   2158            // Should point to the frame payload
   2159            return ( pData );
   \   00004F   AA82         MOV     R2,DPL
   \   000051   AB83         MOV     R3,DPH
   \   000053                REQUIRE ?Subroutine7
   \   000053                ; // Fall through to label ?Subroutine7
   2160          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   F8           MOV     R0,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   E0           MOVX    A,@DPTR
   \   000006   48           ORL     A,R0
   \   000007                REQUIRE ??Subroutine119_0
   \   000007                ; // Fall through to label ??Subroutine119_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine119_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   E0           MOVX    A,@DPTR
   \   000006   22           RET
   2161          
   2162          /*********************************************************************
   2163           * @fn      zclCalcHdrSize
   2164           *
   2165           * @brief   Calculate the number of bytes needed for an outgoing
   2166           *          ZCL header.
   2167           *
   2168           * @param   hdr - outgoing header information
   2169           *
   2170           * @return  returns the number of bytes needed
   2171           */
   2172          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr )
   2173          {
   2174            uint8 needed = (1 + 1 + 1); // frame control + transaction seq num + cmd ID
   2175          
   2176            // Add the manfacturer code
   2177            if ( hdr->fc.manuSpecific )
   2178            {
   2179              needed += 2;
   2180            }
   2181          
   2182            return ( needed );
   2183          }
   2184          
   2185          /*********************************************************************
   2186           * @fn      zclFindPlugin
   2187           *
   2188           * @brief   Find the right plugin for a cluster ID
   2189           *
   2190           * @param   clusterID - cluster ID to look for
   2191           * @param   profileID - profile ID
   2192           *
   2193           * @return  pointer to plugin, NULL if not found
   2194           */
   2195          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID )
   2196          {
   2197            zclLibPlugin_t *pLoop = plugins;
   2198          
   2199            (void)profileID;  // Intentionally unreferenced parameter
   2200          
   2201            while ( pLoop != NULL )
   2202            {
   2203              if ( ( clusterID >= pLoop->startClusterID ) && ( clusterID <= pLoop->endClusterID ) )
   2204              {
   2205                return ( pLoop );
   2206              }
   2207          
   2208              pLoop = pLoop->next;
   2209            }
   2210          
   2211            return ( (zclLibPlugin_t *)NULL );
   2212          }
   2213          
   2214          #ifdef ZCL_DISCOVER
   2215          /*********************************************************************
   2216           * @fn      zclFindCmdRecsList
   2217           *
   2218           * @brief   Find the right command record list for an endpoint
   2219           *
   2220           * @param   endpoint - endpoint to look for
   2221           *
   2222           * @return  pointer to record list, NULL if not found
   2223           */
   2224          static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint )
   2225          {
   2226            zclCmdRecsList_t *pLoop = gpCmdList;
   2227          
   2228            while ( pLoop != NULL )
   2229            {
   2230              if ( pLoop->endpoint == endpoint )
   2231              {
   2232                return ( pLoop );
   2233              }
   2234          
   2235              pLoop = pLoop->pNext;
   2236            }
   2237          
   2238            return ( NULL );
   2239          }
   2240          
   2241          /*********************************************************************
   2242           * @fn      zclFindCmdRec
   2243           *
   2244           * @brief   Find the command record that matchs the parameters
   2245           *
   2246           * @param   endpoint - Application's endpoint
   2247           * @param   clusterID - cluster ID
   2248           * @param   attrId - attribute looking for
   2249           * @param   pAttr - attribute record to be returned
   2250           *
   2251           * @return  TRUE if record found. FALSE, otherwise.
   2252           */
   2253          uint8 zclFindCmdRec( uint8 endpoint, uint16 clusterID, uint8 cmdID, zclCommandRec_t *pCmd )
   2254          {
   2255            uint8 i;
   2256            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   2257          
   2258            if ( pRec != NULL )
   2259            {
   2260              for ( i = 0; i < pRec->numCommands; i++ )
   2261              {
   2262                if ( pRec->pCmdRecs[i].clusterID == clusterID && pRec->pCmdRecs[i].cmdID == cmdID )
   2263                {
   2264                  *pCmd = pRec->pCmdRecs[i];
   2265          
   2266                  return ( TRUE ); // EMBEDDED RETURN
   2267                }
   2268              }
   2269            }
   2270          
   2271            return ( FALSE );
   2272          }
   2273          #endif // ZCL_DISCOVER
   2274          
   2275          /*********************************************************************
   2276           * @fn      zclFindAttrRecsList
   2277           *
   2278           * @brief   Find the right attribute record list for an endpoint
   2279           *
   2280           * @param   clusterID - endpointto look for
   2281           *
   2282           * @return  pointer to record list, NULL if not found
   2283           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2284          static zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint )
   \                     zclFindAttrRecsList:
   2285          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2286            zclAttrRecsList *pLoop = attrList;
   \   000004   90....       MOV     DPTR,#attrList
   \   000007   8004         SJMP    ??zclFindAttrRecsList_0
   2287          
   2288            while ( pLoop != NULL )
   2289            {
   2290              if ( pLoop->endpoint == endpoint )
   2291              {
   2292                return ( pLoop );
   2293              }
   2294          
   2295              pLoop = pLoop->next;
   \                     ??zclFindAttrRecsList_1:
   \   000009   8A82         MOV     DPL,R2
   \   00000B   8B83         MOV     DPH,R3
   \                     ??zclFindAttrRecsList_0:
   \   00000D   12....       LCALL   ??Subroutine116_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_165:
   \   000010   600C         JZ      ??zclFindAttrRecsList_2
   \   000012   8A82         MOV     DPL,R2
   \   000014   8B83         MOV     DPH,R3
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   69           XRL     A,R1
   \   00001A   70ED         JNZ     ??zclFindAttrRecsList_1
   \   00001C   8004         SJMP    ??zclFindAttrRecsList_3
   2296            }
   2297          
   2298            return ( NULL );
   \                     ??zclFindAttrRecsList_2:
   \   00001E   7A00         MOV     R2,#0x0
   \   000020   7B00         MOV     R3,#0x0
   \                     ??zclFindAttrRecsList_3:
   \   000022   02....       LJMP    ?Subroutine0 & 0xFFFF
   2299          }
   2300          
   2301          /*********************************************************************
   2302           * @fn      zclFindAttrRec
   2303           *
   2304           * @brief   Find the attribute record that matchs the parameters
   2305           *
   2306           * @param   endpoint - Application's endpoint
   2307           * @param   clusterID - cluster ID
   2308           * @param   attrId - attribute looking for
   2309           * @param   pAttr - attribute record to be returned
   2310           *
   2311           * @return  TRUE if record found. FALSE, otherwise.
   2312           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2313          uint8 zclFindAttrRec( uint8 endpoint, uint16 clusterID, uint16 attrId, zclAttrRec_t *pAttr )
   \                     zclFindAttrRec:
   2314          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 2,R2
   \   000007   8B..         MOV     ?V0 + 3,R3
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
   \   00000D   7410         MOV     A,#0x10
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   2315            uint8 x;
   2316            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \                     ??CrossCallReturnLabel_219:
   \   000015                ; Setup parameters for call to function zclFindAttrRecsList
   \   000015   12....       LCALL   ??zclFindAttrRecsList?relay
   \   000018   8A..         MOV     ?V0 + 6,R2
   \   00001A   8B..         MOV     ?V0 + 7,R3
   \   00001C   AC..         MOV     R4,?V0 + 6
   \   00001E   AD..         MOV     R5,?V0 + 7
   2317          
   2318            if ( pRec != NULL )
   \   000020   EC           MOV     A,R4
   \   000021   4D           ORL     A,R5
   \   000022   6075         JZ      ??zclFindAttrRec_0
   2319            {
   2320              for ( x = 0; x < pRec->numAttributes; x++ )
   \   000024   75..00       MOV     ?V0 + 5,#0x0
   \   000027   8002         SJMP    ??zclFindAttrRec_1
   \                     ??zclFindAttrRec_2:
   \   000029   05..         INC     ?V0 + 5
   \                     ??zclFindAttrRec_1:
   \   00002B   8C82         MOV     DPL,R4
   \   00002D   8D83         MOV     DPH,R5
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   A3           INC     DPTR
   \   000034   A3           INC     DPTR
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \   000037   F8           MOV     R0,A
   \   000038   E5..         MOV     A,?V0 + 5
   \   00003A   C3           CLR     C
   \   00003B   98           SUBB    A,R0
   \   00003C   505B         JNC     ??zclFindAttrRec_0
   2321              {
   2322                if ( pRec->attrs[x].clusterID == clusterID && pRec->attrs[x].attr.attrId == attrId )
   \   00003E   85....       MOV     ?V0 + 6,?V0 + 5
   \   000041   75..00       MOV     ?V0 + 7,#0x0
   \   000044   7403         MOV     A,#0x3
   \   000046   78..         MOV     R0,#?V0 + 6
   \   000048   12....       LCALL   ?S_SHL
   \   00004B   8C82         MOV     DPL,R4
   \   00004D   8D83         MOV     DPH,R5
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   25..         ADD     A,?V0 + 6
   \   00005A   F8           MOV     R0,A
   \   00005B   A3           INC     DPTR
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   35..         ADDC    A,?V0 + 7
   \   00005F   F9           MOV     R1,A
   \   000060   8882         MOV     DPL,R0
   \   000062   8983         MOV     DPH,R1
   \   000064   E4           CLR     A
   \   000065   93           MOVC    A,@A+DPTR
   \   000066   FA           MOV     R2,A
   \   000067   7401         MOV     A,#0x1
   \   000069   93           MOVC    A,@A+DPTR
   \   00006A   FB           MOV     R3,A
   \   00006B   E5..         MOV     A,?V0 + 2
   \   00006D   6A           XRL     A,R2
   \   00006E   7003         JNZ     ??zclFindAttrRec_3
   \   000070   E5..         MOV     A,?V0 + 3
   \   000072   6B           XRL     A,R3
   \                     ??zclFindAttrRec_3:
   \   000073   70B4         JNZ     ??zclFindAttrRec_2
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   E4           CLR     A
   \   000078   93           MOVC    A,@A+DPTR
   \   000079   FA           MOV     R2,A
   \   00007A   7401         MOV     A,#0x1
   \   00007C   93           MOVC    A,@A+DPTR
   \   00007D   FB           MOV     R3,A
   \   00007E   E5..         MOV     A,?V0 + 0
   \   000080   6A           XRL     A,R2
   \   000081   7003         JNZ     ??zclFindAttrRec_4
   \   000083   E5..         MOV     A,?V0 + 1
   \   000085   6B           XRL     A,R3
   \                     ??zclFindAttrRec_4:
   \   000086   70A1         JNZ     ??zclFindAttrRec_2
   2323                {
   2324                  *pAttr = pRec->attrs[x];
   \   000088   8882         MOV     DPL,R0
   \   00008A   8983         MOV     DPH,R1
   \   00008C   EE           MOV     A,R6
   \   00008D   FC           MOV     R4,A
   \   00008E   EF           MOV     A,R7
   \   00008F   FD           MOV     R5,A
   \   000090   7408         MOV     A,#0x8
   \   000092   12....       LCALL   ?MOVE_LONG8_XDATA_CODE
   2325          
   2326                  return ( TRUE ); // EMBEDDED RETURN
   \   000095   7901         MOV     R1,#0x1
   \   000097   8002         SJMP    ??zclFindAttrRec_5
   2327                }
   2328              }
   2329            }
   2330          
   2331            return ( FALSE );
   \                     ??zclFindAttrRec_0:
   \   000099   7900         MOV     R1,#0x0
   \                     ??zclFindAttrRec_5:
   \   00009B   80..         SJMP    ??Subroutine121_0
   2332          }
   2333          
   2334          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
   2335          /*********************************************************************
   2336           * @fn      zclGetReadWriteCB
   2337           *
   2338           * @brief   Get the Read/Write callback function pointer for a given endpoint.
   2339           *
   2340           * @param   endpoint - Application's endpoint
   2341           *
   2342           * @return  Read/Write CB, NULL if not found
   2343           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2344          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint )
   \                     zclGetReadWriteCB:
   2345          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2346            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000005                ; Setup parameters for call to function zclFindAttrRecsList
   \   000005   12....       LCALL   ??zclFindAttrRecsList?relay
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   2347          
   2348            if ( pRec != NULL )
   \   00000C   E582         MOV     A,DPL
   \   00000E   4583         ORL     A,DPH
   \   000010   6005         JZ      ??zclGetReadWriteCB_0
   2349            {
   2350              return ( pRec->pfnReadWriteCB );
   \   000012   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   2351            }
   \                     ??CrossCallReturnLabel_303:
   \   000015   8004         SJMP    ??zclGetReadWriteCB_1
   2352          
   2353            return ( NULL );
   \                     ??zclGetReadWriteCB_0:
   \   000017   7A00         MOV     R2,#0x0
   \   000019   7B00         MOV     R3,#0x0
   \                     ??zclGetReadWriteCB_1:
   \   00001B   80..         SJMP    ?Subroutine2
   2354          }
   2355          
   2356          /*********************************************************************
   2357           * @fn      zclGetAuthorizeCB
   2358           *
   2359           * @brief   Get the Read/Write Authorization callback function pointer
   2360           *          for a given endpoint.
   2361           *
   2362           * @param   endpoint - Application's endpoint
   2363           *
   2364           * @return  Authorization CB, NULL if not found
   2365           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2366          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint )
   \                     zclGetAuthorizeCB:
   2367          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2368            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000005                ; Setup parameters for call to function zclFindAttrRecsList
   \   000005   12....       LCALL   ??zclFindAttrRecsList?relay
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   2369          
   2370            if ( pRec != NULL )
   \   00000C   E582         MOV     A,DPL
   \   00000E   4583         ORL     A,DPH
   \   000010   6006         JZ      ??zclGetAuthorizeCB_0
   2371            {
   2372              return ( pRec->pfnAuthorizeCB );
   \   000012   A3           INC     DPTR
   \   000013   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   2373            }
   \                     ??CrossCallReturnLabel_305:
   \   000016   8004         SJMP    ??zclGetAuthorizeCB_1
   2374          
   2375            return ( NULL );
   \                     ??zclGetAuthorizeCB_0:
   \   000018   7A00         MOV     R2,#0x0
   \   00001A   7B00         MOV     R3,#0x0
   \                     ??zclGetAuthorizeCB_1:
   \   00001C                REQUIRE ?Subroutine2
   \   00001C                ; // Fall through to label ?Subroutine2
   2376          }
   2377          #endif // ZCL_READ || ZCL_WRITE
   2378          
   2379          /*********************************************************************
   2380           * @fn      zclFindClusterOption
   2381           *
   2382           * @brief   Find the option record that matchs the cluster id
   2383           *
   2384           * @param   endpoint - Application's endpoint
   2385           * @param   clusterID - cluster ID looking for
   2386           *
   2387           * @return  pointer to clutser option, NULL if not found
   2388           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2389          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclFindClusterOption:
   2390          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   EA           MOV     A,R2
   \   000008   FC           MOV     R4,A
   \   000009   EB           MOV     A,R3
   \   00000A   FD           MOV     R5,A
   2391            zclClusterOptionList *pLoop;
   2392          
   2393            pLoop = clusterOptionList;
   \   00000B   90....       MOV     DPTR,#clusterOptionList
   \   00000E   8004         SJMP    ??zclFindClusterOption_0
   2394            while ( pLoop != NULL )
   2395            {
   2396              if ( pLoop->endpoint == endpoint )
   2397              {
   2398                uint8 x;
   2399                for ( x = 0; x < pLoop->numOptions; x++ )
   2400                {
   2401                  if ( pLoop->options[x].clusterID == clusterID )
   2402                  {
   2403                    return ( &(pLoop->options[x]) ); // EMBEDDED RETURN
   2404                  }
   2405                }
   2406              }
   2407          
   2408              pLoop = pLoop->next;
   \                     ??zclFindClusterOption_1:
   \   000010   8882         MOV     DPL,R0
   \   000012   8983         MOV     DPH,R1
   \                     ??zclFindClusterOption_0:
   \   000014   12....       LCALL   ??Subroutine124_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_196:
   \   000017   6047         JZ      ??zclFindClusterOption_2
   \   000019   8882         MOV     DPL,R0
   \   00001B   8983         MOV     DPH,R1
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6E           XRL     A,R6
   \   000021   70ED         JNZ     ??zclFindClusterOption_1
   \   000023   75..00       MOV     ?V0 + 0,#0x0
   \   000026   8002         SJMP    ??zclFindClusterOption_3
   \                     ??zclFindClusterOption_4:
   \   000028   05..         INC     ?V0 + 0
   \                     ??zclFindClusterOption_3:
   \   00002A   8882         MOV     DPL,R0
   \   00002C   8983         MOV     DPH,R1
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   FA           MOV     R2,A
   \   000033   E5..         MOV     A,?V0 + 0
   \   000035   C3           CLR     C
   \   000036   9A           SUBB    A,R2
   \   000037   50D7         JNC     ??zclFindClusterOption_1
   \   000039   E5..         MOV     A,?V0 + 0
   \   00003B   75F003       MOV     B,#0x3
   \   00003E   A4           MUL     AB
   \   00003F   FA           MOV     R2,A
   \   000040   ABF0         MOV     R3,B
   \   000042   8882         MOV     DPL,R0
   \   000044   8983         MOV     DPH,R1
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   2A           ADD     A,R2
   \   00004C   FA           MOV     R2,A
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   3B           ADDC    A,R3
   \   000050   FB           MOV     R3,A
   \   000051   8A82         MOV     DPL,R2
   \   000053   8B83         MOV     DPH,R3
   \   000055   E0           MOVX    A,@DPTR
   \   000056   6C           XRL     A,R4
   \   000057   7003         JNZ     ??zclFindClusterOption_5
   \   000059   A3           INC     DPTR
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   6D           XRL     A,R5
   \                     ??zclFindClusterOption_5:
   \   00005C   70CA         JNZ     ??zclFindClusterOption_4
   \   00005E   8004         SJMP    ??zclFindClusterOption_6
   2409            }
   2410          
   2411            return ( NULL );
   \                     ??zclFindClusterOption_2:
   \   000060   7A00         MOV     R2,#0x0
   \   000062   7B00         MOV     R3,#0x0
   \                     ??zclFindClusterOption_6:
   \   000064   02....       LJMP    ?Subroutine7 & 0xFFFF
   2412          }
   2413          
   2414          /*********************************************************************
   2415           * @fn      zclGetClusterOption
   2416           *
   2417           * @brief   Get the option record that matchs the cluster id
   2418           *
   2419           * @param   endpoint - Application's endpoint
   2420           * @param   clusterID - cluster ID looking for
   2421           *
   2422           * @return  clutser option, AF_TX_OPTIONS_NONE if not found
   2423           */
   2424          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID )
   2425          {
   2426            uint8 option;
   2427            zclOptionRec_t *pOption;
   2428          
   2429            pOption = zclFindClusterOption( endpoint, clusterID );
   2430            if ( pOption != NULL )
   2431            {
   2432              option = pOption->option;
   2433              if ( !ZG_SECURE_ENABLED )
   2434              {
   2435                option &= (AF_EN_SECURITY ^ 0xFF); // make sure Application Link Key security is off
   2436              }
   2437          
   2438              return ( option ); // EMBEDDED RETURN
   2439            }
   2440          
   2441            return ( AF_TX_OPTIONS_NONE );
   2442          }
   2443          
   2444          /*********************************************************************
   2445           * @fn      zclSetSecurityOption
   2446           *
   2447           * @brief   Set the security option for the cluster id
   2448           *
   2449           * @param   endpoint - Application's endpoint
   2450           * @param   clusterID - cluster ID looking for
   2451           * @param   enable - whether to enable (TRUE) or disable (FALSE) security option
   2452           *
   2453           * @return  none
   2454           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2455          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable )
   \                     zclSetSecurityOption:
   2456          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FF           MOV     R7,A
   2457            zclOptionRec_t *pOption;
   2458          
   2459            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000007                ; Setup parameters for call to function zclFindClusterOption
   \   000007   12....       LCALL   ??zclFindClusterOption?relay
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   A8..         MOV     R0,?V0 + 0
   \   000010   A9..         MOV     R1,?V0 + 1
   2460            if ( pOption != NULL )
   \   000012   E8           MOV     A,R0
   \   000013   49           ORL     A,R1
   \   000014   6015         JZ      ??zclSetSecurityOption_0
   2461            {
   2462              if ( enable )
   \   000016   E8           MOV     A,R0
   \   000017   2402         ADD     A,#0x2
   \   000019   F582         MOV     DPL,A
   \   00001B   E9           MOV     A,R1
   \   00001C   12....       LCALL   ??Subroutine122_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_188:
   \   00001F   EF           MOV     A,R7
   \   000020   6005         JZ      ??zclSetSecurityOption_1
   2463              {
   2464                pOption->option |= AF_EN_SECURITY;
   \   000022   E0           MOVX    A,@DPTR
   \   000023   D2E6         SETB    0xE0 /* A   */.6
   \   000025   8003         SJMP    ??zclSetSecurityOption_2
   2465              }
   2466              else
   2467              {
   2468                pOption->option &= (AF_EN_SECURITY ^ 0xFF);
   \                     ??zclSetSecurityOption_1:
   \   000027   E0           MOVX    A,@DPTR
   \   000028   C2E6         CLR     0xE0 /* A   */.6
   \                     ??zclSetSecurityOption_2:
   \   00002A   F0           MOVX    @DPTR,A
   2469              }
   2470            }
   2471          }
   \                     ??zclSetSecurityOption_0:
   \   00002B   02....       LJMP    ?Subroutine2 & 0xFFFF
   2472          
   2473          #ifdef ZCL_DISCOVER
   2474          /*********************************************************************
   2475           * @fn      zclFindNextCmdRec
   2476           *
   2477           * @brief   Find the command (or next) record that matchs the parameters
   2478           *
   2479           * @param   endpoint - Application's endpoint
   2480           * @param   clusterID - cluster ID
   2481           * @param   commandID - command ID from requesting command
   2482           * @param   direction- direction of received command
   2483           * @param   pCmdID - command looking for
   2484           * @param   pCmd - command information within command record list
   2485           *
   2486           * @return  pointer to command record, NULL no more records of this cluster
   2487           */
   2488          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID,
   2489                                          uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd )
   2490          {
   2491            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   2492            uint8 i;
   2493          
   2494            if ( pRec != NULL )
   2495            {
   2496              for ( i = 0; i < pRec->numCommands; i++ )
   2497              {
   2498                if ( ( pRec->pCmdRecs[i].clusterID == clusterID ) &&
   2499                    ( pRec->pCmdRecs[i].cmdID >= *pCmdID ) )
   2500                {
   2501                  if ( commandID == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   2502                  {
   2503                    if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_RECEIVED ) )
   2504                    {
   2505                      *pCmd = pRec->pCmdRecs[i];
   2506          
   2507                      // Update command ID
   2508                      *pCmdID = pCmd->cmdID;
   2509          
   2510                      return ( TRUE ); // EMBEDDED RETURN
   2511                    }
   2512                    else if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_RECEIVED ) )
   2513                    {
   2514                      *pCmd = pRec->pCmdRecs[i];
   2515          
   2516                      // Update command ID
   2517                      *pCmdID = pCmd->cmdID;
   2518          
   2519                      return ( TRUE ); // EMBEDDED RETURN
   2520                    }
   2521                  }
   2522                  else if ( commandID == ZCL_CMD_DISCOVER_CMDS_GEN )
   2523                  {
   2524                    if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_GENERATED ) )
   2525                    {
   2526                      *pCmd = pRec->pCmdRecs[i];
   2527          
   2528                      // Update command ID
   2529                      *pCmdID = pCmd->cmdID;
   2530          
   2531                      return ( TRUE ); // EMBEDDED RETURN
   2532                    }
   2533                    else if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_GENERATED ) )
   2534                    {
   2535                      *pCmd = pRec->pCmdRecs[i];
   2536          
   2537                      // Update command ID
   2538                      *pCmdID = pCmd->cmdID;
   2539          
   2540                      return ( TRUE ); // EMBEDDED RETURN
   2541                    }
   2542                  }
   2543                  else
   2544                  {
   2545                    return ( FALSE ); // Incorrect Command ID
   2546                  }
   2547                }
   2548              }
   2549            }
   2550          
   2551            return ( FALSE );
   2552          }
   2553          
   2554          /*********************************************************************
   2555           * @fn      zclFindNextAttrRec
   2556           *
   2557           * @brief   Find the attribute (or next) record that matchs the parameters
   2558           *
   2559           * @param   endpoint - Application's endpoint
   2560           * @param   clusterID - cluster ID
   2561           * @param   attr - attribute looking for
   2562           *
   2563           * @return  pointer to attribute record, NULL if not found
   2564           */
   2565          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction,
   2566                                           uint16 *attrId, zclAttrRec_t *pAttr )
   2567          {
   2568            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   2569            uint8 attrDir;
   2570          
   2571            if ( pRec != NULL )
   2572            {
   2573              for ( uint16 x = 0; x < pRec->numAttributes; x++ )
   2574              {
   2575                if ( ( pRec->attrs[x].clusterID == clusterID ) &&
   2576                     ( pRec->attrs[x].attr.attrId >= *attrId ) )
   2577                {
   2578                  // also make sure direction is right
   2579                  attrDir = (pRec->attrs[x].attr.accessControl & ACCESS_CLIENT) ? 1 : 0;
   2580                  if ( attrDir == direction )
   2581                  {
   2582                    // return attribute and found attribute ID
   2583                    *pAttr = pRec->attrs[x];
   2584                    *attrId = pAttr->attr.attrId;
   2585          
   2586                    return ( TRUE ); // EMBEDDED RETURN
   2587                  }
   2588                }
   2589              }
   2590            }
   2591          
   2592            return ( FALSE );
   2593          }
   2594          #endif // ZCL_DISCOVER
   2595          
   2596          /*********************************************************************
   2597           * @fn      zclSerializeData
   2598           *
   2599           * @brief   Builds a buffer from the attribute data to sent out over
   2600           *          the air.
   2601           *          NOTE - Not compatible with application's attributes callbacks.
   2602           *
   2603           * @param   dataType - data types defined in zcl.h
   2604           * @param   attrData - pointer to the attribute data
   2605           * @param   buf - where to put the serialized data
   2606           *
   2607           * @return  pointer to end of destination buffer
   2608           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2609          uint8 *zclSerializeData( uint8 dataType, void *attrData, uint8 *buf )
   \                     zclSerializeData:
   2610          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   8A..         MOV     ?V0 + 4,R2
   \   000009   8B..         MOV     ?V0 + 5,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FA           MOV     R2,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FB           MOV     R3,A
   2611            uint8 *pStr;
   2612            uint16 len;
   2613          
   2614            if ( attrData == NULL )
   \   00000F   E5..         MOV     A,?V0 + 4
   \   000011   45..         ORL     A,?V0 + 5
   \   000013   7003         JNZ     $+5
   \   000015   02....       LJMP    ??zclSerializeData_0 & 0xFFFF
   2615            {
   2616              return ( buf );
   2617            }
   2618          
   2619            switch ( dataType )
   \   000018   8A82         MOV     DPL,R2
   \   00001A   8B83         MOV     DPH,R3
   \   00001C   A3           INC     DPTR
   \   00001D   AC82         MOV     R4,DPL
   \   00001F   AD83         MOV     R5,DPH
   \   000021   85....       MOV     ?V0 + 0,?V0 + 4
   \   000024   85....       MOV     ?V0 + 1,?V0 + 5
   \   000027   75..00       MOV     ?V0 + 2,#0x0
   \   00002A   EE           MOV     A,R6
   \   00002B   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclSerializeData>_0`:
   \   00002E   04           DB        4
   \   00002F   41           DB        65
   \   000030   42           DB        66
   \   000031   ....         DW        ??zclSerializeData_1
   \   000033   43           DB        67
   \   000034   44           DB        68
   \   000035   ....         DW        ??zclSerializeData_2
   \   000037   E0           DB        224
   \   000038   E2           DB        226
   \   000039   ....         DW        ??zclSerializeData_3
   \   00003B   E8           DB        232
   \   00003C   E9           DB        233
   \   00003D   ....         DW        ??zclSerializeData_4
   \   00003F   1A           DB        26
   \   000040   08           DB        8
   \   000041   ....         DW        ??zclSerializeData_5
   \   000043   09           DB        9
   \   000044   ....         DW        ??zclSerializeData_4
   \   000046   0A           DB        10
   \   000047   ....         DW        ??zclSerializeData_6
   \   000049   0B           DB        11
   \   00004A   ....         DW        ??zclSerializeData_3
   \   00004C   10           DB        16
   \   00004D   ....         DW        ??zclSerializeData_5
   \   00004F   18           DB        24
   \   000050   ....         DW        ??zclSerializeData_5
   \   000052   19           DB        25
   \   000053   ....         DW        ??zclSerializeData_4
   \   000055   1A           DB        26
   \   000056   ....         DW        ??zclSerializeData_6
   \   000058   1B           DB        27
   \   000059   ....         DW        ??zclSerializeData_3
   \   00005B   20           DB        32
   \   00005C   ....         DW        ??zclSerializeData_5
   \   00005E   21           DB        33
   \   00005F   ....         DW        ??zclSerializeData_4
   \   000061   22           DB        34
   \   000062   ....         DW        ??zclSerializeData_6
   \   000064   23           DB        35
   \   000065   ....         DW        ??zclSerializeData_3
   \   000067   24           DB        36
   \   000068   ....         DW        ??zclSerializeData_7
   \   00006A   25           DB        37
   \   00006B   ....         DW        ??zclSerializeData_8
   \   00006D   28           DB        40
   \   00006E   ....         DW        ??zclSerializeData_5
   \   000070   29           DB        41
   \   000071   ....         DW        ??zclSerializeData_4
   \   000073   2A           DB        42
   \   000074   ....         DW        ??zclSerializeData_6
   \   000076   2B           DB        43
   \   000077   ....         DW        ??zclSerializeData_3
   \   000079   30           DB        48
   \   00007A   ....         DW        ??zclSerializeData_5
   \   00007C   31           DB        49
   \   00007D   ....         DW        ??zclSerializeData_4
   \   00007F   38           DB        56
   \   000080   ....         DW        ??zclSerializeData_4
   \   000082   39           DB        57
   \   000083   ....         DW        ??zclSerializeData_3
   \   000085   EA           DB        234
   \   000086   ....         DW        ??zclSerializeData_3
   \   000088   F0           DB        240
   \   000089   ....         DW        ??zclSerializeData_9
   \   00008B   F1           DB        241
   \   00008C   ....         DW        ??zclSerializeData_10
   \   00008E   ....         DW        ??zclSerializeData_0
   2620            {
   2621              case ZCL_DATATYPE_DATA8:
   2622              case ZCL_DATATYPE_BOOLEAN:
   2623              case ZCL_DATATYPE_BITMAP8:
   2624              case ZCL_DATATYPE_INT8:
   2625              case ZCL_DATATYPE_UINT8:
   2626              case ZCL_DATATYPE_ENUM8:
   2627                *buf++ = *((uint8 *)attrData);
   \                     ??zclSerializeData_5:
   \   000090   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_233:
   \   000093   F0           MOVX    @DPTR,A
   \   000094   EC           MOV     A,R4
   \   000095   FA           MOV     R2,A
   \   000096   ED           MOV     A,R5
   \   000097   FB           MOV     R3,A
   2628                 break;
   \   000098   02....       LJMP    ??zclSerializeData_0 & 0xFFFF
   2629          
   2630              case ZCL_DATATYPE_DATA16:
   2631              case ZCL_DATATYPE_BITMAP16:
   2632              case ZCL_DATATYPE_UINT16:
   2633              case ZCL_DATATYPE_INT16:
   2634              case ZCL_DATATYPE_ENUM16:
   2635              case ZCL_DATATYPE_SEMI_PREC:
   2636              case ZCL_DATATYPE_CLUSTER_ID:
   2637              case ZCL_DATATYPE_ATTR_ID:
   2638                *buf++ = LO_UINT16( *((uint16*)attrData) );
   \                     ??zclSerializeData_4:
   \   00009B   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_234:
   \   00009E   12....       LCALL   ?Subroutine20 & 0xFFFF
   2639                *buf++ = HI_UINT16( *((uint16*)attrData) );
   \                     ??CrossCallReturnLabel_16:
   \   0000A1   A3           INC     DPTR
   \   0000A2   12....       LCALL   ??Subroutine128_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_228:
   \   0000A5   803C         SJMP    ??zclSerializeData_11
   2640                break;
   2641          
   2642              case ZCL_DATATYPE_DATA24:
   2643              case ZCL_DATATYPE_BITMAP24:
   2644              case ZCL_DATATYPE_UINT24:
   2645              case ZCL_DATATYPE_INT24:
   2646                *buf++ = BREAK_UINT32( *((uint32*)attrData), 0 );
   \                     ??zclSerializeData_6:
   \   0000A7   85..82       MOV     DPL,?V0 + 4
   \   0000AA   85..83       MOV     DPH,?V0 + 5
   \   0000AD   78..         MOV     R0,#?V0 + 0
   \   0000AF   12....       LCALL   ?L_MOV_X
   \   0000B2   8A82         MOV     DPL,R2
   \   0000B4   8B83         MOV     DPH,R3
   \   0000B6   E5..         MOV     A,?V0 + 0
   \   0000B8   12....       LCALL   ?Subroutine20 & 0xFFFF
   2647                *buf++ = BREAK_UINT32( *((uint32*)attrData), 1 );
   \                     ??CrossCallReturnLabel_17:
   \   0000BB   78..         MOV     R0,#?V0 + 0
   \   0000BD   12....       LCALL   ?L_MOV_X
   \   0000C0   E5..         MOV     A,?V0 + 1
   \   0000C2   8A82         MOV     DPL,R2
   \   0000C4   8B83         MOV     DPH,R3
   \   0000C6   F0           MOVX    @DPTR,A
   \   0000C7   A3           INC     DPTR
   \   0000C8   0A           INC     R2
   \   0000C9   AB83         MOV     R3,DPH
   2648                *buf++ = BREAK_UINT32( *((uint32*)attrData), 2 );
   \   0000CB   85..82       MOV     DPL,?V0 + 4
   \   0000CE   85..83       MOV     DPH,?V0 + 5
   \   0000D1   78..         MOV     R0,#?V0 + 0
   \   0000D3   12....       LCALL   ?L_MOV_X
   \   0000D6   7410         MOV     A,#0x10
   \   0000D8   78..         MOV     R0,#?V0 + 0
   \   0000DA   12....       LCALL   ?UL_SHR
   \   0000DD   8A82         MOV     DPL,R2
   \   0000DF   8B83         MOV     DPH,R3
   \   0000E1   E5..         MOV     A,?V0 + 0
   \                     ??zclSerializeData_11:
   \   0000E3   F0           MOVX    @DPTR,A
   \   0000E4   A3           INC     DPTR
   \   0000E5   0A           INC     R2
   \   0000E6   AB83         MOV     R3,DPH
   2649                break;
   \   0000E8   8066         SJMP    ??zclSerializeData_0
   2650          
   2651              case ZCL_DATATYPE_DATA32:
   2652              case ZCL_DATATYPE_BITMAP32:
   2653              case ZCL_DATATYPE_UINT32:
   2654              case ZCL_DATATYPE_INT32:
   2655              case ZCL_DATATYPE_SINGLE_PREC:
   2656              case ZCL_DATATYPE_TOD:
   2657              case ZCL_DATATYPE_DATE:
   2658              case ZCL_DATATYPE_UTC:
   2659              case ZCL_DATATYPE_BAC_OID:
   2660                buf = zcl_buffer_uint32( buf, *((uint32*)attrData) );
   \                     ??zclSerializeData_3:
   \   0000EA                ; Setup parameters for call to function osal_buffer_uint32
   \   0000EA   85..82       MOV     DPL,?V0 + 4
   \   0000ED   85..83       MOV     DPH,?V0 + 5
   \   0000F0   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   0000F3   12....       LCALL   ??osal_buffer_uint32?relay
   \   0000F6   7404         MOV     A,#0x4
   \   0000F8   12....       LCALL   ?DEALLOC_XSTACK8
   2661                break;
   \   0000FB   8053         SJMP    ??zclSerializeData_0
   2662          
   2663              case ZCL_DATATYPE_UINT40:
   2664                pStr = (uint8*)attrData;
   2665                buf = zcl_memcpy( buf, pStr, 5 );
   \                     ??zclSerializeData_7:
   \   0000FD                ; Setup parameters for call to function osal_memcpy
   \   0000FD   78..         MOV     R0,#?V0 + 0
   \   0000FF   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000102   7C05         MOV     R4,#0x5
   \   000104   8040         SJMP    ??zclSerializeData_12
   2666                break;
   2667          
   2668              case ZCL_DATATYPE_UINT48:
   2669                pStr = (uint8*)attrData;
   2670                buf = zcl_memcpy( buf, pStr, 6 );
   \                     ??zclSerializeData_8:
   \   000106                ; Setup parameters for call to function osal_memcpy
   \   000106   78..         MOV     R0,#?V0 + 0
   \   000108   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00010B   7C06         MOV     R4,#0x6
   \   00010D   8037         SJMP    ??zclSerializeData_12
   2671                break;
   2672          
   2673              case ZCL_DATATYPE_IEEE_ADDR:
   2674                pStr = (uint8*)attrData;
   2675                buf = zcl_memcpy( buf, pStr, 8 );
   \                     ??zclSerializeData_9:
   \   00010F                ; Setup parameters for call to function osal_memcpy
   \   00010F   78..         MOV     R0,#?V0 + 0
   \   000111   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000114   7C08         MOV     R4,#0x8
   \   000116   802E         SJMP    ??zclSerializeData_12
   2676                break;
   2677          
   2678              case ZCL_DATATYPE_CHAR_STR:
   2679              case ZCL_DATATYPE_OCTET_STR:
   2680                pStr = (uint8*)attrData;
   2681                len = *pStr;
   2682                buf = zcl_memcpy( buf, pStr, len+1 ); // Including length field
   \                     ??zclSerializeData_1:
   \   000118                ; Setup parameters for call to function osal_memcpy
   \   000118   78..         MOV     R0,#?V0 + 0
   \   00011A   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00011D   85..82       MOV     DPL,?V0 + 4
   \   000120   85..83       MOV     DPH,?V0 + 5
   \   000123   E0           MOVX    A,@DPTR
   \   000124   2401         ADD     A,#0x1
   \   000126   FC           MOV     R4,A
   \   000127   E4           CLR     A
   \   000128   8010         SJMP    ??zclSerializeData_13
   2683                break;
   2684          
   2685              case ZCL_DATATYPE_LONG_CHAR_STR:
   2686              case ZCL_DATATYPE_LONG_OCTET_STR:
   2687                pStr = (uint8*)attrData;
   2688                len = BUILD_UINT16( pStr[0], pStr[1] );
   2689                buf = zcl_memcpy( buf, pStr, len+2 ); // Including length field
   \                     ??zclSerializeData_2:
   \   00012A                ; Setup parameters for call to function osal_memcpy
   \   00012A   78..         MOV     R0,#?V0 + 0
   \   00012C   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00012F   85..82       MOV     DPL,?V0 + 4
   \   000132   85..83       MOV     DPH,?V0 + 5
   \   000135   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_92:
   \   000138   FC           MOV     R4,A
   \   000139   E9           MOV     A,R1
   \                     ??zclSerializeData_13:
   \   00013A   3400         ADDC    A,#0x0
   \   00013C   FD           MOV     R5,A
   \   00013D   8009         SJMP    ??zclSerializeData_14
   2690                break;
   2691          
   2692              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   2693                pStr = (uint8*)attrData;
   2694                buf = zcl_memcpy( buf, pStr, SEC_KEY_LEN );
   \                     ??zclSerializeData_10:
   \   00013F                ; Setup parameters for call to function osal_memcpy
   \   00013F   78..         MOV     R0,#?V0 + 0
   \   000141   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000144   7C10         MOV     R4,#0x10
   \                     ??zclSerializeData_12:
   \   000146   7D00         MOV     R5,#0x0
   \                     ??zclSerializeData_14:
   \   000148   12....       LCALL   ??osal_memcpy?relay
   \   00014B   7403         MOV     A,#0x3
   \   00014D   12....       LCALL   ?DEALLOC_XSTACK8
   2695                break;
   2696          
   2697              case ZCL_DATATYPE_NO_DATA:
   2698              case ZCL_DATATYPE_UNKNOWN:
   2699                // Fall through
   2700          
   2701              default:
   2702                break;
   2703            }
   2704          
   2705            return ( buf );
   \                     ??zclSerializeData_0:
   \   000150   02....       LJMP    ?Subroutine3 & 0xFFFF
   2706          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   EC           MOV     A,R4
   \   000002   FA           MOV     R2,A
   \   000003   ED           MOV     A,R5
   \   000004   FB           MOV     R3,A
   \   000005   85..82       MOV     DPL,?V0 + 4
   \   000008   85..83       MOV     DPH,?V0 + 5
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   12....       LCALL   ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_340:
   \   000003   F9           MOV     R1,A
   \   000004   EC           MOV     A,R4
   \   000005   2402         ADD     A,#0x2
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   85..82       MOV     DPL,?V0 + 4
   \   000003   85..83       MOV     DPH,?V0 + 5
   \   000006                REQUIRE ??Subroutine128_0
   \   000006                ; // Fall through to label ??Subroutine128_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine128_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   22           RET
   2707          
   2708          #ifdef ZCL_REPORT
   2709          /*********************************************************************
   2710           * @fn      zclAnalogDataType
   2711           *
   2712           * @brief   Checks to see if Data Type is Analog
   2713           *
   2714           * @param   dataType - data type
   2715           *
   2716           * @return  TRUE if data type is analog
   2717           */
   2718          uint8 zclAnalogDataType( uint8 dataType )
   2719          {
   2720            uint8 analog;
   2721          
   2722            switch ( dataType )
   2723            {
   2724              case ZCL_DATATYPE_UINT8:
   2725              case ZCL_DATATYPE_UINT16:
   2726              case ZCL_DATATYPE_UINT24:
   2727              case ZCL_DATATYPE_UINT32:
   2728              case ZCL_DATATYPE_UINT40:
   2729              case ZCL_DATATYPE_UINT48:
   2730              case ZCL_DATATYPE_UINT56:
   2731              case ZCL_DATATYPE_UINT64:
   2732              case ZCL_DATATYPE_INT8:
   2733              case ZCL_DATATYPE_INT16:
   2734              case ZCL_DATATYPE_INT24:
   2735              case ZCL_DATATYPE_INT32:
   2736              case ZCL_DATATYPE_INT40:
   2737              case ZCL_DATATYPE_INT48:
   2738              case ZCL_DATATYPE_INT56:
   2739              case ZCL_DATATYPE_INT64:
   2740              case ZCL_DATATYPE_SEMI_PREC:
   2741              case ZCL_DATATYPE_SINGLE_PREC:
   2742              case ZCL_DATATYPE_DOUBLE_PREC:
   2743              case ZCL_DATATYPE_TOD:
   2744              case ZCL_DATATYPE_DATE:
   2745              case ZCL_DATATYPE_UTC:
   2746                analog = TRUE;
   2747                break;
   2748          
   2749              default:
   2750                analog = FALSE;
   2751                break;
   2752            }
   2753          
   2754            return ( analog );
   2755          }
   2756          
   2757          /*********************************************************************
   2758           * @fn      zclIsLittleEndianMachine
   2759           *
   2760           * @brief   Verifies endianness in system.
   2761           *
   2762           * @param   none
   2763           *
   2764           * @return  MSB-00 or LSB-01 depending on endianness in the system
   2765           */
   2766          static int zclIsLittleEndianMachine(void)
   2767          {
   2768            uint16 test = 0x0001;
   2769          
   2770            return (*((uint8 *)(&test)));
   2771          }
   2772          
   2773          /*********************************************************************
   2774           * @fn      zcl_BuildAnalogData
   2775           *
   2776           * @brief   Build an analog arribute out of sequential bytes.
   2777           *
   2778           * @param   dataType - type of data
   2779           * @param   pData - pointer to data
   2780           * @param   pBuf - where to put the data
   2781           *
   2782           * @return  none
   2783           */
   2784          static void zcl_BuildAnalogData( uint8 dataType, uint8 *pData, uint8 *pBuf )
   2785          {
   2786            int current_byte_index;
   2787            int remaining_bytes;
   2788            int step;
   2789          
   2790            remaining_bytes = zclGetAttrDataLength(dataType, pData);
   2791          
   2792            // decide if move forward or backwards to copy data
   2793            if ( zclIsLittleEndianMachine() )
   2794            {
   2795              step = 1;
   2796              current_byte_index = 0;
   2797            }
   2798            else
   2799            {
   2800              step = -1;
   2801              current_byte_index = remaining_bytes - 1;
   2802            }
   2803          
   2804            while ( remaining_bytes-- )
   2805            {
   2806              pData[current_byte_index] = *(pBuf++);
   2807              current_byte_index += step;
   2808            }
   2809          }
   2810          #endif // ZCL_REPORT
   2811          
   2812          /*********************************************************************
   2813           * @fn      zclGetDataTypeLength
   2814           *
   2815           * @brief   Return the length of the datatype in octet.
   2816           *
   2817           *          NOTE: Should not be called for ZCL_DATATYPE_OCTECT_STR or
   2818           *                ZCL_DATATYPE_CHAR_STR data types.
   2819           *
   2820           * @param   dataType - data type
   2821           *
   2822           * @return  length of data
   2823           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2824          uint8 zclGetDataTypeLength( uint8 dataType )
   \                     zclGetDataTypeLength:
   2825          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   E9           MOV     A,R1
   2826            uint8 len;
   2827          
   2828            switch ( dataType )
   \   000001   24F8         ADD     A,#-0x8
   \   000003   6078         JZ      ??zclGetDataTypeLength_0
   \   000005   14           DEC     A
   \   000006   6079         JZ      ??zclGetDataTypeLength_1
   \   000008   14           DEC     A
   \   000009   607A         JZ      ??zclGetDataTypeLength_2
   \   00000B   14           DEC     A
   \   00000C   607B         JZ      ??zclGetDataTypeLength_3
   \   00000E   24FB         ADD     A,#-0x5
   \   000010   606B         JZ      ??zclGetDataTypeLength_0
   \   000012   24F8         ADD     A,#-0x8
   \   000014   6067         JZ      ??zclGetDataTypeLength_0
   \   000016   14           DEC     A
   \   000017   6068         JZ      ??zclGetDataTypeLength_1
   \   000019   14           DEC     A
   \   00001A   6069         JZ      ??zclGetDataTypeLength_2
   \   00001C   14           DEC     A
   \   00001D   606A         JZ      ??zclGetDataTypeLength_3
   \   00001F   24FB         ADD     A,#-0x5
   \   000021   605A         JZ      ??zclGetDataTypeLength_0
   \   000023   14           DEC     A
   \   000024   605B         JZ      ??zclGetDataTypeLength_1
   \   000026   14           DEC     A
   \   000027   605C         JZ      ??zclGetDataTypeLength_2
   \   000029   14           DEC     A
   \   00002A   605D         JZ      ??zclGetDataTypeLength_3
   \   00002C   14           DEC     A
   \   00002D   605E         JZ      ??zclGetDataTypeLength_4
   \   00002F   14           DEC     A
   \   000030   605F         JZ      ??zclGetDataTypeLength_5
   \   000032   14           DEC     A
   \   000033   6060         JZ      ??zclGetDataTypeLength_6
   \   000035   14           DEC     A
   \   000036   6061         JZ      ??zclGetDataTypeLength_7
   \   000038   14           DEC     A
   \   000039   6042         JZ      ??zclGetDataTypeLength_0
   \   00003B   14           DEC     A
   \   00003C   6043         JZ      ??zclGetDataTypeLength_1
   \   00003E   14           DEC     A
   \   00003F   6044         JZ      ??zclGetDataTypeLength_2
   \   000041   14           DEC     A
   \   000042   6045         JZ      ??zclGetDataTypeLength_3
   \   000044   14           DEC     A
   \   000045   6046         JZ      ??zclGetDataTypeLength_4
   \   000047   14           DEC     A
   \   000048   6047         JZ      ??zclGetDataTypeLength_5
   \   00004A   14           DEC     A
   \   00004B   6048         JZ      ??zclGetDataTypeLength_6
   \   00004D   14           DEC     A
   \   00004E   6049         JZ      ??zclGetDataTypeLength_7
   \   000050   14           DEC     A
   \   000051   602A         JZ      ??zclGetDataTypeLength_0
   \   000053   14           DEC     A
   \   000054   602B         JZ      ??zclGetDataTypeLength_1
   \   000056   24F9         ADD     A,#-0x7
   \   000058   6027         JZ      ??zclGetDataTypeLength_1
   \   00005A   14           DEC     A
   \   00005B   602C         JZ      ??zclGetDataTypeLength_3
   \   00005D   14           DEC     A
   \   00005E   6039         JZ      ??zclGetDataTypeLength_7
   \   000060   245A         ADD     A,#0x5a
   \   000062   6025         JZ      ??zclGetDataTypeLength_3
   \   000064   14           DEC     A
   \   000065   6022         JZ      ??zclGetDataTypeLength_3
   \   000067   14           DEC     A
   \   000068   601F         JZ      ??zclGetDataTypeLength_3
   \   00006A   24FA         ADD     A,#-0x6
   \   00006C   6013         JZ      ??zclGetDataTypeLength_1
   \   00006E   14           DEC     A
   \   00006F   6010         JZ      ??zclGetDataTypeLength_1
   \   000071   14           DEC     A
   \   000072   6015         JZ      ??zclGetDataTypeLength_3
   \   000074   24FA         ADD     A,#-0x6
   \   000076   6021         JZ      ??zclGetDataTypeLength_7
   \   000078   14           DEC     A
   \   000079   6022         JZ      ??zclGetDataTypeLength_8
   \   00007B   8024         SJMP    ??zclGetDataTypeLength_9
   2829            {
   2830              case ZCL_DATATYPE_DATA8:
   2831              case ZCL_DATATYPE_BOOLEAN:
   2832              case ZCL_DATATYPE_BITMAP8:
   2833              case ZCL_DATATYPE_INT8:
   2834              case ZCL_DATATYPE_UINT8:
   2835              case ZCL_DATATYPE_ENUM8:
   2836                len = 1;
   \                     ??zclGetDataTypeLength_0:
   \   00007D   7901         MOV     R1,#0x1
   2837                break;
   \   00007F   8022         SJMP    ??zclGetDataTypeLength_10
   2838          
   2839              case ZCL_DATATYPE_DATA16:
   2840              case ZCL_DATATYPE_BITMAP16:
   2841              case ZCL_DATATYPE_UINT16:
   2842              case ZCL_DATATYPE_INT16:
   2843              case ZCL_DATATYPE_ENUM16:
   2844              case ZCL_DATATYPE_SEMI_PREC:
   2845              case ZCL_DATATYPE_CLUSTER_ID:
   2846              case ZCL_DATATYPE_ATTR_ID:
   2847                len = 2;
   \                     ??zclGetDataTypeLength_1:
   \   000081   7902         MOV     R1,#0x2
   2848                break;
   \   000083   801E         SJMP    ??zclGetDataTypeLength_10
   2849          
   2850              case ZCL_DATATYPE_DATA24:
   2851              case ZCL_DATATYPE_BITMAP24:
   2852              case ZCL_DATATYPE_UINT24:
   2853              case ZCL_DATATYPE_INT24:
   2854                len = 3;
   \                     ??zclGetDataTypeLength_2:
   \   000085   7903         MOV     R1,#0x3
   2855                break;
   \   000087   801A         SJMP    ??zclGetDataTypeLength_10
   2856          
   2857              case ZCL_DATATYPE_DATA32:
   2858              case ZCL_DATATYPE_BITMAP32:
   2859              case ZCL_DATATYPE_UINT32:
   2860              case ZCL_DATATYPE_INT32:
   2861              case ZCL_DATATYPE_SINGLE_PREC:
   2862              case ZCL_DATATYPE_TOD:
   2863              case ZCL_DATATYPE_DATE:
   2864              case ZCL_DATATYPE_UTC:
   2865              case ZCL_DATATYPE_BAC_OID:
   2866                len = 4;
   \                     ??zclGetDataTypeLength_3:
   \   000089   7904         MOV     R1,#0x4
   2867                break;
   \   00008B   8016         SJMP    ??zclGetDataTypeLength_10
   2868          
   2869             case ZCL_DATATYPE_UINT40:
   2870             case ZCL_DATATYPE_INT40:
   2871                 len = 5;
   \                     ??zclGetDataTypeLength_4:
   \   00008D   7905         MOV     R1,#0x5
   2872                 break;
   \   00008F   8012         SJMP    ??zclGetDataTypeLength_10
   2873          
   2874             case ZCL_DATATYPE_UINT48:
   2875             case ZCL_DATATYPE_INT48:
   2876                 len = 6;
   \                     ??zclGetDataTypeLength_5:
   \   000091   7906         MOV     R1,#0x6
   2877                 break;
   \   000093   800E         SJMP    ??zclGetDataTypeLength_10
   2878          
   2879             case ZCL_DATATYPE_UINT56:
   2880             case ZCL_DATATYPE_INT56:
   2881                 len = 7;
   \                     ??zclGetDataTypeLength_6:
   \   000095   7907         MOV     R1,#0x7
   2882                 break;
   \   000097   800A         SJMP    ??zclGetDataTypeLength_10
   2883          
   2884             case ZCL_DATATYPE_DOUBLE_PREC:
   2885             case ZCL_DATATYPE_IEEE_ADDR:
   2886             case ZCL_DATATYPE_UINT64:
   2887             case ZCL_DATATYPE_INT64:
   2888               len = 8;
   \                     ??zclGetDataTypeLength_7:
   \   000099   7908         MOV     R1,#0x8
   2889               break;
   \   00009B   8006         SJMP    ??zclGetDataTypeLength_10
   2890          
   2891              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   2892               len = SEC_KEY_LEN;
   \                     ??zclGetDataTypeLength_8:
   \   00009D   7910         MOV     R1,#0x10
   2893               break;
   \   00009F   8002         SJMP    ??zclGetDataTypeLength_10
   2894          
   2895              case ZCL_DATATYPE_NO_DATA:
   2896              case ZCL_DATATYPE_UNKNOWN:
   2897                // Fall through
   2898          
   2899              default:
   2900                len = 0;
   \                     ??zclGetDataTypeLength_9:
   \   0000A1   7900         MOV     R1,#0x0
   2901                break;
   2902            }
   2903          
   2904            return ( len );
   \                     ??zclGetDataTypeLength_10:
   \   0000A3   02....       LJMP    ?BRET
   2905          }
   2906          
   2907          /*********************************************************************
   2908           * @fn      zclGetAttrDataLength
   2909           *
   2910           * @brief   Return the length of the attribute.
   2911           *
   2912           * @param   dataType - data type
   2913           * @param   pData - pointer to data
   2914           *
   2915           * @return  returns atrribute length
   2916           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2917          uint16 zclGetAttrDataLength( uint8 dataType, uint8 *pData )
   \                     zclGetAttrDataLength:
   2918          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   2919            uint16 dataLen = 0;
   2920          
   2921            if ( dataType == ZCL_DATATYPE_LONG_CHAR_STR || dataType == ZCL_DATATYPE_LONG_OCTET_STR )
   \   000007   7444         MOV     A,#0x44
   \   000009   6E           XRL     A,R6
   \   00000A   6005         JZ      ??zclGetAttrDataLength_0
   \   00000C   7443         MOV     A,#0x43
   \   00000E   6E           XRL     A,R6
   \   00000F   700B         JNZ     ??zclGetAttrDataLength_1
   2922            {
   2923              dataLen = BUILD_UINT16( pData[0], pData[1] ) + 2; // long string length + 2 for length field
   \                     ??zclGetAttrDataLength_0:
   \   000011   8A82         MOV     DPL,R2
   \   000013   8B83         MOV     DPH,R3
   \   000015   12....       LCALL   ?Subroutine70 & 0xFFFF
   2924            }
   \                     ??CrossCallReturnLabel_93:
   \   000018   FA           MOV     R2,A
   \   000019   E9           MOV     A,R1
   \   00001A   8013         SJMP    ??zclGetAttrDataLength_2
   2925            else if ( dataType == ZCL_DATATYPE_CHAR_STR || dataType == ZCL_DATATYPE_OCTET_STR )
   \                     ??zclGetAttrDataLength_1:
   \   00001C   7442         MOV     A,#0x42
   \   00001E   6E           XRL     A,R6
   \   00001F   6005         JZ      ??zclGetAttrDataLength_3
   \   000021   7441         MOV     A,#0x41
   \   000023   6E           XRL     A,R6
   \   000024   700E         JNZ     ??zclGetAttrDataLength_4
   2926            {
   2927              dataLen = *pData + 1; // string length + 1 for length field
   \                     ??zclGetAttrDataLength_3:
   \   000026   8A82         MOV     DPL,R2
   \   000028   8B83         MOV     DPH,R3
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   2401         ADD     A,#0x1
   \   00002D   FA           MOV     R2,A
   \   00002E   E4           CLR     A
   \                     ??zclGetAttrDataLength_2:
   \   00002F   3400         ADDC    A,#0x0
   \   000031   FB           MOV     R3,A
   \   000032   8007         SJMP    ??zclGetAttrDataLength_5
   2928            }
   2929            else
   2930            {
   2931              dataLen = zclGetDataTypeLength( dataType );
   \                     ??zclGetAttrDataLength_4:
   \   000034                ; Setup parameters for call to function zclGetDataTypeLength
   \   000034   12....       LCALL   ??zclGetDataTypeLength?relay
   \   000037   E9           MOV     A,R1
   \   000038   FA           MOV     R2,A
   \   000039   7B00         MOV     R3,#0x0
   2932            }
   2933          
   2934            return ( dataLen );
   \                     ??zclGetAttrDataLength_5:
   \   00003B   02....       LJMP    ?Subroutine7 & 0xFFFF
   2935          }
   2936          
   2937          #ifdef ZCL_READ
   2938          /*********************************************************************
   2939           * @fn      zclReadAttrData
   2940           *
   2941           * @brief   Read the attribute's current value into pAttrData.
   2942           *          NOTE - Not compatible with application's attributes callbacks.
   2943           *
   2944           * @param   pAttrData - where to put attribute data
   2945           * @param   pAttr - pointer to attribute
   2946           * @param   pDataLen - where to put attribute data length
   2947           *
   2948           * @return Success
   2949           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2950          ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen )
   \                     zclReadAttrData:
   2951          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2952            uint16 dataLen;
   2953          
   2954            if ( pAttr->attr.dataPtr == NULL )
   \   000009   EC           MOV     A,R4
   \   00000A   2406         ADD     A,#0x6
   \   00000C   F8           MOV     R0,A
   \   00000D   ED           MOV     A,R5
   \   00000E   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   000011   12....       LCALL   ??Subroutine116_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_170:
   \   000014   7004         JNZ     ??zclReadAttrData_0
   2955            {
   2956              return ( ZCL_STATUS_FAILURE );
   \   000016   7901         MOV     R1,#0x1
   \   000018   804C         SJMP    ??zclReadAttrData_1
   2957            }
   2958          
   2959            dataLen = zclGetAttrDataLength( pAttr->attr.dataType, (uint8*)(pAttr->attr.dataPtr) );
   \                     ??zclReadAttrData_0:
   \   00001A                ; Setup parameters for call to function zclGetAttrDataLength
   \   00001A   8C82         MOV     DPL,R4
   \   00001C   8D83         MOV     DPH,R5
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F9           MOV     R1,A
   \   000024   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000027   8A..         MOV     ?V0 + 2,R2
   \   000029   8B..         MOV     ?V0 + 3,R3
   2960            zcl_memcpy( pAttrData, pAttr->attr.dataPtr, dataLen );
   \   00002B                ; Setup parameters for call to function osal_memcpy
   \   00002B   85..82       MOV     DPL,?V0 + 0
   \   00002E   85..83       MOV     DPH,?V0 + 1
   \   000031   E0           MOVX    A,@DPTR
   \   000032   F5..         MOV     ?V0 + 0,A
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   85....       MOV     ?V0 + 4,?V0 + 0
   \   000039   F5..         MOV     ?V0 + 5,A
   \   00003B   75..00       MOV     ?V0 + 6,#0x0
   \   00003E   78..         MOV     R0,#?V0 + 4
   \   000040   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000043   AC..         MOV     R4,?V0 + 2
   \   000045   AD..         MOV     R5,?V0 + 3
   \   000047   EE           MOV     A,R6
   \   000048   FA           MOV     R2,A
   \   000049   EF           MOV     A,R7
   \   00004A   FB           MOV     R3,A
   \   00004B   12....       LCALL   ??osal_memcpy?relay
   \   00004E   7403         MOV     A,#0x3
   \   000050   12....       LCALL   ?DEALLOC_XSTACK8
   \   000053   740F         MOV     A,#0xf
   \   000055   12....       LCALL   ?XSTACK_DISP0_8
   \   000058   12....       LCALL   ?Subroutine48 & 0xFFFF
   2961          
   2962            if ( pDataLen != NULL )
   \                     ??CrossCallReturnLabel_53:
   \   00005B   6007         JZ      ??zclReadAttrData_2
   2963            {
   2964              *pDataLen = dataLen;
   \   00005D   E5..         MOV     A,?V0 + 2
   \   00005F   F0           MOVX    @DPTR,A
   \   000060   A3           INC     DPTR
   \   000061   E5..         MOV     A,?V0 + 3
   \   000063   F0           MOVX    @DPTR,A
   2965            }
   2966          
   2967            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclReadAttrData_2:
   \   000064   7900         MOV     R1,#0x0
   \                     ??zclReadAttrData_1:
   \   000066                REQUIRE ?Subroutine8
   \   000066                ; // Fall through to label ?Subroutine8
   2968          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   7F07         MOV     R7,#0x7
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   2969          
   2970          /*********************************************************************
   2971           * @fn      zcl_ReadAttrData
   2972           *
   2973           * @brief   Read the attribute's current value into pAttrData.
   2974           *          Use application's callback function if assigned to this attribute.
   2975           *
   2976           * @param   endpoint - application's endpoint
   2977           * @param   clusterId - cluster that attribute belongs to
   2978           * @param   attrId - attribute id
   2979           * @param   pAttrData - where to put attribute data
   2980           * @param   pDataLen - where to put attribute data length
   2981           *
   2982           * @return  Successful if data was read
   2983           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2984          ZStatus_t zcl_ReadAttrData( uint8 endpoint, uint16 clusterId, uint16 attrId,
   \                     zcl_ReadAttrData:
   2985                                                   uint8 *pAttrData, uint16 *pDataLen )
   2986          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V0 + 2,R1
   \   00000C   8A..         MOV     ?V0 + 0,R2
   \   00000E   8B..         MOV     ?V0 + 1,R3
   \   000010   EC           MOV     A,R4
   \   000011   FE           MOV     R6,A
   \   000012   ED           MOV     A,R5
   \   000013   FF           MOV     R7,A
   2987            zclAttrRec_t attrRec;
   2988          
   2989            if ( zclFindAttrRec( endpoint, clusterId, attrId, &attrRec ) == FALSE )
   \   000014                ; Setup parameters for call to function zclFindAttrRec
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   8582..       MOV     ?V0 + 4,DPL
   \   00001D   8583..       MOV     ?V0 + 5,DPH
   \   000020   78..         MOV     R0,#?V0 + 4
   \   000022   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000025   12....       LCALL   ??zclFindAttrRec?relay
   \   000028   7402         MOV     A,#0x2
   \   00002A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00002D   E9           MOV     A,R1
   \   00002E   7004         JNZ     ??zcl_ReadAttrData_0
   2990            {
   2991              return ( ZCL_STATUS_FAILURE );
   \   000030   7901         MOV     R1,#0x1
   \   000032   8050         SJMP    ??zcl_ReadAttrData_1
   2992            }
   \                     ??zcl_ReadAttrData_0:
   \   000034   7418         MOV     A,#0x18
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   00003C   741A         MOV     A,#0x1a
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   12....       LCALL   ?Subroutine59 & 0xFFFF
   2993          
   2994            if ( attrRec.attr.dataPtr != NULL )
   \                     ??CrossCallReturnLabel_70:
   \   000044   7406         MOV     A,#0x6
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   12....       LCALL   ??Subroutine124_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_201:
   \   00004C   78..         MOV     R0,#?V0 + 4
   \   00004E   601A         JZ      ??zcl_ReadAttrData_2
   2995            {
   2996              return zclReadAttrData( pAttrData, &attrRec, pDataLen );
   \   000050                ; Setup parameters for call to function zclReadAttrData
   \   000050   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000053   7402         MOV     A,#0x2
   \   000055   12....       LCALL   ?XSTACK_DISP0_8
   \   000058   AC82         MOV     R4,DPL
   \   00005A   AD83         MOV     R5,DPH
   \   00005C   AA..         MOV     R2,?V0 + 6
   \   00005E   AB..         MOV     R3,?V0 + 7
   \   000060   12....       LCALL   ??zclReadAttrData?relay
   \   000063   7402         MOV     A,#0x2
   \   000065   12....       LCALL   ?DEALLOC_XSTACK8
   \   000068   801A         SJMP    ??zcl_ReadAttrData_1
   2997            }
   2998            else
   2999            {
   3000              return zclReadAttrDataUsingCB( endpoint, clusterId, attrId, pAttrData, pDataLen );
   \                     ??zcl_ReadAttrData_2:
   \   00006A                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   00006A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006D   78..         MOV     R0,#?V0 + 6
   \   00006F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000072   EE           MOV     A,R6
   \   000073   FC           MOV     R4,A
   \   000074   EF           MOV     A,R7
   \   000075   FD           MOV     R5,A
   \   000076   AA..         MOV     R2,?V0 + 0
   \   000078   AB..         MOV     R3,?V0 + 1
   \   00007A   A9..         MOV     R1,?V0 + 2
   \   00007C   12....       LCALL   ??zclReadAttrDataUsingCB?relay
   \   00007F   7404         MOV     A,#0x4
   \   000081   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??zcl_ReadAttrData_1:
   \   000084   7408         MOV     A,#0x8
   3001            }
   \   000086   02....       LJMP    ?Subroutine6 & 0xFFFF
   3002          }
   3003          
   3004          /*********************************************************************
   3005           * @fn      zclGetAttrDataLengthUsingCB
   3006           *
   3007           * @brief   Use application's callback to get the length of the attribute's
   3008           *          current value stored in the database.
   3009           *
   3010           * @param   endpoint - application's endpoint
   3011           * @param   clusterId - cluster that attribute belongs to
   3012           * @param   attrId - attribute id
   3013           *
   3014           * @return  returns attribute length
   3015           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3016          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId )
   \                     zclGetAttrDataLengthUsingCB:
   3017          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   3018            uint16 dataLen = 0;
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   E4           CLR     A
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   A3           INC     DPTR
   \   00001B   F0           MOVX    @DPTR,A
   3019            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   00001C                ; Setup parameters for call to function zclGetReadWriteCB
   \   00001C   12....       LCALL   ??zclGetReadWriteCB?relay
   \   00001F   8A..         MOV     ?V0 + 4,R2
   \   000021   8B..         MOV     ?V0 + 5,R3
   3020          
   3021            if ( pfnReadWriteCB != NULL )
   \   000023   EA           MOV     A,R2
   \   000024   45..         ORL     A,?V0 + 5
   \   000026   6033         JZ      ??zclGetAttrDataLengthUsingCB_0
   3022            {
   3023              // Only get the attribute length
   3024              (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_LEN, NULL, &dataLen );
   \   000028                ; Setup parameters for indirect call
   \   000028   85..82       MOV     DPL,?XSP + 0
   \   00002B   85..83       MOV     DPH,?XSP + 1
   \   00002E   8582..       MOV     ?V0 + 6,DPL
   \   000031   8583..       MOV     ?V0 + 7,DPH
   \   000034   78..         MOV     R0,#?V0 + 6
   \   000036   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000039   E4           CLR     A
   \   00003A   F5..         MOV     ?V0 + 6,A
   \   00003C   F5..         MOV     ?V0 + 7,A
   \   00003E   78..         MOV     R0,#?V0 + 6
   \   000040   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000043   7900         MOV     R1,#0x0
   \   000045   EE           MOV     A,R6
   \   000046   FC           MOV     R4,A
   \   000047   EF           MOV     A,R7
   \   000048   FD           MOV     R5,A
   \   000049   AA..         MOV     R2,?V0 + 0
   \   00004B   AB..         MOV     R3,?V0 + 1
   \   00004D   85..82       MOV     DPL,?V0 + 4
   \   000050   85..83       MOV     DPH,?V0 + 5
   \   000053   12....       LCALL   ?CALL_IND
   \   000056   7404         MOV     A,#0x4
   \   000058   12....       LCALL   ?DEALLOC_XSTACK8
   3025            }
   3026          
   3027            return ( dataLen );
   \                     ??zclGetAttrDataLengthUsingCB_0:
   \   00005B   85..82       MOV     DPL,?XSP + 0
   \   00005E   85..83       MOV     DPH,?XSP + 1
   \   000061   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_298:
   \   000064   7402         MOV     A,#0x2
   \   000066   02....       LJMP    ?Subroutine6 & 0xFFFF
   3028          }
   3029          
   3030          /*********************************************************************
   3031           * @fn      zclReadAttrDataUsingCB
   3032           *
   3033           * @brief   Use application's callback to read the attribute's current
   3034           *          value stored in the database.
   3035           *
   3036           * @param   endpoint - application's endpoint
   3037           * @param   clusterId - cluster that attribute belongs to
   3038           * @param   attrId - attribute id
   3039           * @param   pAttrData - where to put attribute data
   3040           * @param   pDataLen - where to put attribute data length
   3041           *
   3042           * @return  Successful if data was read
   3043           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3044          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
   \                     zclReadAttrDataUsingCB:
   3045                                                   uint8 *pAttrData, uint16 *pDataLen )
   3046          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   \   00000D   7412         MOV     A,#0x12
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   12....       LCALL   ?Subroutine61 & 0xFFFF
   3047            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \                     ??CrossCallReturnLabel_76:
   \   000015                ; Setup parameters for call to function zclGetReadWriteCB
   \   000015   12....       LCALL   ??zclGetReadWriteCB?relay
   \   000018   8A..         MOV     ?V0 + 2,R2
   \   00001A   8B..         MOV     ?V0 + 3,R3
   \   00001C   7414         MOV     A,#0x14
   \   00001E   12....       LCALL   ?XSTACK_DISP0_8
   \   000021   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   3048          
   3049            if ( pDataLen != NULL )
   \                     ??CrossCallReturnLabel_316:
   \   000024   E5..         MOV     A,?V0 + 8
   \   000026   45..         ORL     A,?V0 + 9
   \   000028   600A         JZ      ??zclReadAttrDataUsingCB_0
   3050            {
   3051              *pDataLen = 0; // Always initialize it to 0
   \   00002A   85..82       MOV     DPL,?V0 + 8
   \   00002D   85..83       MOV     DPH,?V0 + 9
   \   000030   E4           CLR     A
   \   000031   F0           MOVX    @DPTR,A
   \   000032   A3           INC     DPTR
   \   000033   F0           MOVX    @DPTR,A
   3052            }
   3053          
   3054            if ( pfnReadWriteCB != NULL )
   \                     ??zclReadAttrDataUsingCB_0:
   \   000034   EA           MOV     A,R2
   \   000035   45..         ORL     A,?V0 + 3
   \   000037   6024         JZ      ??zclReadAttrDataUsingCB_1
   3055            {
   3056              // Read the attribute value and its length
   3057              return ( (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_READ, pAttrData, pDataLen ) );
   \   000039                ; Setup parameters for indirect call
   \   000039   78..         MOV     R0,#?V0 + 8
   \   00003B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003E   78..         MOV     R0,#?V0 + 6
   \   000040   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000043   7901         MOV     R1,#0x1
   \   000045   EE           MOV     A,R6
   \   000046   FC           MOV     R4,A
   \   000047   EF           MOV     A,R7
   \   000048   FD           MOV     R5,A
   \   000049   AA..         MOV     R2,?V0 + 0
   \   00004B   AB..         MOV     R3,?V0 + 1
   \   00004D   85..82       MOV     DPL,?V0 + 2
   \   000050   85..83       MOV     DPH,?V0 + 3
   \   000053   12....       LCALL   ?CALL_IND
   \   000056   7404         MOV     A,#0x4
   \   000058   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005B   8002         SJMP    ??zclReadAttrDataUsingCB_2
   3058            }
   3059          
   3060            return ( ZCL_STATUS_SOFTWARE_FAILURE );
   \                     ??zclReadAttrDataUsingCB_1:
   \   00005D   79C1         MOV     R1,#-0x3f
   \                     ??zclReadAttrDataUsingCB_2:
   \   00005F   7F0A         MOV     R7,#0xa
   \   000061   02....       LJMP    ?BANKED_LEAVE_XDATA
   3061          }
   3062          
   3063          /*********************************************************************
   3064           * @fn      zclAuthorizeRead
   3065           *
   3066           * @brief   Use application's callback to authorize a Read operation
   3067           *          on a given attribute.
   3068           *
   3069           * @param   endpoint - application's endpoint
   3070           * @param   srcAddr - source Address
   3071           * @param   pAttr - pointer to attribute
   3072           *
   3073           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   3074           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   3075           */
   3076          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   3077          {
   3078            if ( zcl_AccessCtrlAuthRead( pAttr->attr.accessControl ) )
   3079            {
   3080              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   3081          
   3082              if ( pfnAuthorizeCB != NULL )
   3083              {
   3084                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_READ ) );
   3085              }
   3086            }
   3087          
   3088            return ( ZCL_STATUS_SUCCESS );
   3089          }
   3090          #endif // ZCL_READ
   3091          
   3092          #ifdef ZCL_WRITE
   3093          /*********************************************************************
   3094           * @fn      zclWriteAttrData
   3095           *
   3096           * @brief   Write the received data.
   3097           *
   3098           * @param   endpoint - application's endpoint
   3099           * @param   pAttr - where to write data to
   3100           * @param   pWriteRec - data to be written
   3101           *
   3102           * @return  Successful if data was written
   3103           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3104          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
   \                     zclWriteAttrData:
   3105                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec )
   3106          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   \   000007   ED           MOV     A,R5
   \   000008   FF           MOV     R7,A
   3107            uint8 status;
   3108          
   3109            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   A2E1         MOV     C,0xE0 /* A   */.1
   \   000015   5075         JNC     ??zclWriteAttrData_0
   3110            {
   3111              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   000017                ; Setup parameters for call to function zclAuthorizeWrite
   \   000017   12....       LCALL   ??zclAuthorizeWrite?relay
   \   00001A   E9           MOV     A,R1
   \   00001B   F5..         MOV     ?V0 + 3,A
   3112              if ( status == ZCL_STATUS_SUCCESS )
   \   00001D   7070         JNZ     ??zclWriteAttrData_1
   \   00001F   740F         MOV     A,#0xf
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   E0           MOVX    A,@DPTR
   \   000025   F5..         MOV     ?V0 + 0,A
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F5..         MOV     ?V0 + 1,A
   3113              {
   3114                if ( ( zcl_ValidateAttrDataCB == NULL ) || zcl_ValidateAttrDataCB( pAttr, pWriteRec ) )
   \   00002B   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   00002E   12....       LCALL   ??Subroutine124_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_202:
   \   000031   6013         JZ      ??zclWriteAttrData_2
   \   000033                ; Setup parameters for indirect call
   \   000033   AC..         MOV     R4,?V0 + 0
   \   000035   AD..         MOV     R5,?V0 + 1
   \   000037   EE           MOV     A,R6
   \   000038   FA           MOV     R2,A
   \   000039   EF           MOV     A,R7
   \   00003A   FB           MOV     R3,A
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   F583         MOV     DPH,A
   \   00003E   8882         MOV     DPL,R0
   \   000040   12....       LCALL   ?CALL_IND
   \   000043   E9           MOV     A,R1
   \   000044   6041         JZ      ??zclWriteAttrData_3
   3115                {
   3116                  // Write the attribute value
   3117                  uint16 len = zclGetAttrDataLength( pAttr->attr.dataType, pWriteRec->attrData );
   \                     ??zclWriteAttrData_2:
   \   000046   E5..         MOV     A,?V0 + 0
   \   000048   2403         ADD     A,#0x3
   \   00004A   F8           MOV     R0,A
   \   00004B   E5..         MOV     A,?V0 + 1
   \   00004D   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   000050   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_299:
   \   000053   8E82         MOV     DPL,R6
   \   000055   8F83         MOV     DPH,R7
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   F9           MOV     R1,A
   \   00005D   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000060   8A..         MOV     ?V0 + 4,R2
   \   000062   8B..         MOV     ?V0 + 5,R3
   \   000064   AC..         MOV     R4,?V0 + 4
   \   000066   AD..         MOV     R5,?V0 + 5
   3118                  zcl_memcpy( pAttr->attr.dataPtr, pWriteRec->attrData, len );
   \   000068                ; Setup parameters for call to function osal_memcpy
   \   000068   85..82       MOV     DPL,?V0 + 0
   \   00006B   85..83       MOV     DPH,?V0 + 1
   \   00006E   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   000071   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000074   8E82         MOV     DPL,R6
   \   000076   8F83         MOV     DPH,R7
   \   000078   A3           INC     DPTR
   \   000079   A3           INC     DPTR
   \   00007A   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_306:
   \   00007D   12....       LCALL   ??osal_memcpy?relay
   \   000080   7403         MOV     A,#0x3
   \   000082   12....       LCALL   ?DEALLOC_XSTACK8
   3119          
   3120                  status = ZCL_STATUS_SUCCESS;
   \   000085   8008         SJMP    ??zclWriteAttrData_1
   3121                }
   3122                else
   3123                {
   3124                  status = ZCL_STATUS_INVALID_VALUE;
   \                     ??zclWriteAttrData_3:
   \   000087   75..87       MOV     ?V0 + 3,#-0x79
   \   00008A   8003         SJMP    ??zclWriteAttrData_1
   3125                }
   3126              }
   3127            }
   3128            else
   3129            {
   3130              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrData_0:
   \   00008C   75..88       MOV     ?V0 + 3,#-0x78
   3131            }
   3132          
   3133            return ( status );
   \                     ??zclWriteAttrData_1:
   \   00008F   A9..         MOV     R1,?V0 + 3
   \   000091   02....       LJMP    ?Subroutine8 & 0xFFFF
   3134          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_130:
   \   000003   75..00       MOV     ?V0 + 6,#0x0
   \   000006   78..         MOV     R0,#?V0 + 4
   \   000008   22           RET
   3135          
   3136          /*********************************************************************
   3137           * @fn      zclWriteAttrDataUsingCB
   3138           *
   3139           * @brief   Use application's callback to write the attribute's current
   3140           *          value stored in the database.
   3141           *
   3142           * @param   endpoint - application's endpoint
   3143           * @param   pAttr - where to write data to
   3144           * @param   pAttrData - data to be written
   3145           *
   3146           * @return  Successful if data was written
   3147           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3148          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
   \                     zclWriteAttrDataUsingCB:
   3149                                                    zclAttrRec_t *pAttr, uint8 *pAttrData )
   3150          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   EC           MOV     A,R4
   \   000008   FE           MOV     R6,A
   \   000009   ED           MOV     A,R5
   \   00000A   FF           MOV     R7,A
   \   00000B   7410         MOV     A,#0x10
   \   00000D   12....       LCALL   ?XSTACK_DISP0_8
   \   000010   12....       LCALL   ?Subroutine59 & 0xFFFF
   3151            uint8 status;
   3152          
   3153            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \                     ??CrossCallReturnLabel_71:
   \   000013   8E82         MOV     DPL,R6
   \   000015   8F83         MOV     DPH,R7
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   A2E1         MOV     C,0xE0 /* A   */.1
   \   00001F   5047         JNC     ??zclWriteAttrDataUsingCB_0
   3154            {
   3155              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   000021                ; Setup parameters for call to function zclAuthorizeWrite
   \   000021   12....       LCALL   ??zclAuthorizeWrite?relay
   \   000024   E9           MOV     A,R1
   3156              if ( status == ZCL_STATUS_SUCCESS )
   \   000025   7043         JNZ     ??zclWriteAttrDataUsingCB_1
   3157              {
   3158                zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   000027                ; Setup parameters for call to function zclGetReadWriteCB
   \   000027   A9..         MOV     R1,?V0 + 0
   \   000029   12....       LCALL   ??zclGetReadWriteCB?relay
   \   00002C   8A..         MOV     ?V0 + 2,R2
   \   00002E   8B..         MOV     ?V0 + 3,R3
   3159                if ( pfnReadWriteCB != NULL )
   \   000030   EA           MOV     A,R2
   \   000031   45..         ORL     A,?V0 + 3
   \   000033   602F         JZ      ??zclWriteAttrDataUsingCB_2
   3160                {
   3161                  // Write the attribute value
   3162                  status = (*pfnReadWriteCB)( pAttr->clusterID, pAttr->attr.attrId,
   3163                                              ZCL_OPER_WRITE, pAttrData, NULL );
   \   000035                ; Setup parameters for indirect call
   \   000035   E4           CLR     A
   \   000036   F5..         MOV     ?V0 + 6,A
   \   000038   F5..         MOV     ?V0 + 7,A
   \   00003A   78..         MOV     R0,#?V0 + 6
   \   00003C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003F   78..         MOV     R0,#?V0 + 4
   \   000041   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000044   7902         MOV     R1,#0x2
   \   000046   8E82         MOV     DPL,R6
   \   000048   8F83         MOV     DPH,R7
   \   00004A   12....       LCALL   ??Subroutine143_0 & 0xFFFF
   3164                }
   \                     ??CrossCallReturnLabel_327:
   \   00004D   8E82         MOV     DPL,R6
   \   00004F   8F83         MOV     DPH,R7
   \   000051   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_300:
   \   000054   85..82       MOV     DPL,?V0 + 2
   \   000057   85..83       MOV     DPH,?V0 + 3
   \   00005A   12....       LCALL   ?CALL_IND
   \   00005D   7404         MOV     A,#0x4
   \   00005F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000062   8006         SJMP    ??zclWriteAttrDataUsingCB_1
   3165                else
   3166                {
   3167                  status = ZCL_STATUS_SOFTWARE_FAILURE;
   \                     ??zclWriteAttrDataUsingCB_2:
   \   000064   79C1         MOV     R1,#-0x3f
   \   000066   8002         SJMP    ??zclWriteAttrDataUsingCB_1
   3168                }
   3169              }
   3170            }
   3171            else
   3172            {
   3173              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrDataUsingCB_0:
   \   000068   7988         MOV     R1,#-0x78
   3174            }
   3175          
   3176            return ( status );
   \                     ??zclWriteAttrDataUsingCB_1:
   \   00006A   02....       LJMP    ??Subroutine121_0 & 0xFFFF
   3177          }
   3178          
   3179          /*********************************************************************
   3180           * @fn      zclAuthorizeWrite
   3181           *
   3182           * @brief   Use application's callback to authorize a Write operation
   3183           *          on a given attribute.
   3184           *
   3185           * @param   endpoint - application's endpoint
   3186           * @param   srcAddr - source Address
   3187           * @param   pAttr - pointer to attribute
   3188           *
   3189           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   3190           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   3191           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3192          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   \                     zclAuthorizeWrite:
   3193          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
   3194            if ( zcl_AccessCtrlAuthWrite( pAttr->attr.accessControl ) )
   \   00000D   8C82         MOV     DPL,R4
   \   00000F   8D83         MOV     DPH,R5
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   A2E5         MOV     C,0xE0 /* A   */.5
   \   000019   501C         JNC     ??zclAuthorizeWrite_0
   3195            {
   3196              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   \   00001B                ; Setup parameters for call to function zclGetAuthorizeCB
   \   00001B   12....       LCALL   ??zclGetAuthorizeCB?relay
   \   00001E   8A82         MOV     DPL,R2
   \   000020   8B83         MOV     DPH,R3
   3197          
   3198              if ( pfnAuthorizeCB != NULL )
   \   000022   E582         MOV     A,DPL
   \   000024   4583         ORL     A,DPH
   \   000026   600F         JZ      ??zclAuthorizeWrite_0
   3199              {
   3200                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_WRITE ) );
   \   000028                ; Setup parameters for indirect call
   \   000028   7902         MOV     R1,#0x2
   \   00002A   AC..         MOV     R4,?V0 + 0
   \   00002C   AD..         MOV     R5,?V0 + 1
   \   00002E   EE           MOV     A,R6
   \   00002F   FA           MOV     R2,A
   \   000030   EF           MOV     A,R7
   \   000031   FB           MOV     R3,A
   \   000032   12....       LCALL   ?CALL_IND
   \   000035   8002         SJMP    ??zclAuthorizeWrite_1
   3201              }
   3202            }
   3203          
   3204            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclAuthorizeWrite_0:
   \   000037   7900         MOV     R1,#0x0
   \                     ??zclAuthorizeWrite_1:
   \   000039   02....       LJMP    ?Subroutine3 & 0xFFFF
   3205          }
   3206          #endif // ZCL_WRITE
   3207          
   3208          #ifdef ZCL_READ
   3209          /*********************************************************************
   3210           * @fn      zclParseInReadCmd
   3211           *
   3212           * @brief   Parse the "Profile" Read Commands
   3213           *
   3214           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3215           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3216           *
   3217           * @param   pCmd - pointer to incoming data to parse
   3218           *
   3219           * @return  pointer to the parsed command structure
   3220           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3221          void *zclParseInReadCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadCmd:
   3222          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   3223            zclReadCmd_t *readCmd;
   3224            uint8 *pBuf = pCmd->pData;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   00000F   FE           MOV     R6,A
   \   000010   E9           MOV     A,R1
   \   000011   FF           MOV     R7,A
   3225          
   3226            readCmd = (zclReadCmd_t *)zcl_mem_alloc( sizeof ( zclReadCmd_t ) + pCmd->dataLen );
   \   000012   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   000015   12....       LCALL   ??osal_mem_alloc?relay
   3227            if ( readCmd != NULL )
   \   000018   EA           MOV     A,R2
   \   000019   4B           ORL     A,R3
   \   00001A   604C         JZ      ??zclParseInReadCmd_0
   3228            {
   3229              uint8 i;
   3230              readCmd->numAttr = pCmd->dataLen / 2; // Atrribute ID
   \   00001C   85..82       MOV     DPL,?V0 + 0
   \   00001F   85..83       MOV     DPH,?V0 + 1
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F8           MOV     R0,A
   \   000024   A3           INC     DPTR
   \   000025   E0           MOVX    A,@DPTR
   \   000026   C3           CLR     C
   \   000027   13           RRC     A
   \   000028   E8           MOV     A,R0
   \   000029   13           RRC     A
   \   00002A   8A82         MOV     DPL,R2
   \   00002C   8B83         MOV     DPH,R3
   \   00002E   F0           MOVX    @DPTR,A
   3231              for ( i = 0; i < readCmd->numAttr; i++ )
   \   00002F   75..00       MOV     ?V0 + 0,#0x0
   \   000032   8028         SJMP    ??zclParseInReadCmd_1
   3232              {
   3233                readCmd->attrID[i] = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInReadCmd_2:
   \   000034   8E82         MOV     DPL,R6
   \   000036   8F83         MOV     DPH,R7
   \   000038   12....       LCALL   ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_339:
   \   00003B   F9           MOV     R1,A
   \   00003C   EC           MOV     A,R4
   \   00003D   2400         ADD     A,#0x0
   \   00003F   E4           CLR     A
   \   000040   39           ADDC    A,R1
   \   000041   FD           MOV     R5,A
   \   000042   E5..         MOV     A,?V0 + 0
   \   000044   33           RLC     A
   \   000045   F8           MOV     R0,A
   \   000046   E4           CLR     A
   \   000047   33           RLC     A
   \   000048   F9           MOV     R1,A
   \   000049   EA           MOV     A,R2
   \   00004A   28           ADD     A,R0
   \   00004B   F582         MOV     DPL,A
   \   00004D   EB           MOV     A,R3
   \   00004E   39           ADDC    A,R1
   \   00004F   F583         MOV     DPH,A
   \   000051   A3           INC     DPTR
   \   000052   EC           MOV     A,R4
   \   000053   F0           MOVX    @DPTR,A
   \   000054   A3           INC     DPTR
   \   000055   ED           MOV     A,R5
   \   000056   F0           MOVX    @DPTR,A
   3234                pBuf += 2;
   \   000057   12....       LCALL   ?Subroutine72 & 0xFFFF
   3235              }
   \                     ??CrossCallReturnLabel_97:
   \   00005A   05..         INC     ?V0 + 0
   \                     ??zclParseInReadCmd_1:
   \   00005C   8A82         MOV     DPL,R2
   \   00005E   8B83         MOV     DPH,R3
   \   000060   E0           MOVX    A,@DPTR
   \   000061   F8           MOV     R0,A
   \   000062   E5..         MOV     A,?V0 + 0
   \   000064   C3           CLR     C
   \   000065   98           SUBB    A,R0
   \   000066   40CC         JC      ??zclParseInReadCmd_2
   3236            }
   3237          
   3238            return ( (void *)readCmd );
   \                     ??zclParseInReadCmd_0:
   \   000068   02....       LJMP    ?Subroutine1 & 0xFFFF
   3239          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   8582..       MOV     ?V0 + 0,DPL
   \   000008   8583..       MOV     ?V0 + 1,DPH
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   2401         ADD     A,#0x1
   \   00000E   FA           MOV     R2,A
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   3400         ADDC    A,#0x0
   \   000013   FB           MOV     R3,A
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_289:
   \   000003   E8           MOV     A,R0
   \   000004   22           RET
   3240          
   3241          /*********************************************************************
   3242           * @fn      zclParseInReadRspCmd
   3243           *
   3244           * @brief   Parse the "Profile" Read Response Commands
   3245           *
   3246           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3247           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3248           *
   3249           * @param   pCmd - pointer to incoming data to parse
   3250           *
   3251           * @return  pointer to the parsed command structure
   3252           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   AA..         MOV     R2,?V0 + 10
   \   000002   AB..         MOV     R3,?V0 + 11
   \   000004                REQUIRE ??Subroutine113_0
   \   000004                ; // Fall through to label ??Subroutine113_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3253          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadRspCmd:
   3254          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 8,R2
   \   000007   8B..         MOV     ?V0 + 9,R3
   3255            zclReadRspCmd_t *readRspCmd;
   3256            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV     A,R2
   \   00000A   2403         ADD     A,#0x3
   \   00000C   F5..         MOV     ?V0 + 4,A
   \   00000E   EB           MOV     A,R3
   \   00000F   3400         ADDC    A,#0x0
   \   000011   F5..         MOV     ?V0 + 5,A
   \   000013   85..82       MOV     DPL,?V0 + 4
   \   000016   12....       LCALL   ??Subroutine126_0 & 0xFFFF
   3257            uint8 *dataPtr;
   3258            uint8 numAttr = 0;
   \                     ??CrossCallReturnLabel_225:
   \   000019   75..00       MOV     ?V0 + 2,#0x0
   3259            uint8 hdrLen;
   3260            uint16 dataLen = 0;
   \   00001C   75..00       MOV     ?V0 + 6,#0x0
   \   00001F   75..00       MOV     ?V0 + 7,#0x0
   \   000022   802D         SJMP    ??zclParseInReadRspCmd_0
   3261            uint16 attrDataLen;
   3262          
   3263            // find out the number of attributes and the length of attribute data
   3264            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3265            {
   3266              uint8 status;
   3267          
   3268              numAttr++;
   \                     ??zclParseInReadRspCmd_1:
   \   000024   05..         INC     ?V0 + 2
   3269              pBuf += 2; // move pass attribute id
   \   000026   12....       LCALL   ?Subroutine71 & 0xFFFF
   3270          
   3271              status = *pBuf++;
   \                     ??CrossCallReturnLabel_94:
   \   000029   A3           INC     DPTR
   \   00002A   AE82         MOV     R6,DPL
   \   00002C   AF83         MOV     R7,DPH
   3272              if ( status == ZCL_STATUS_SUCCESS )
   \   00002E   7021         JNZ     ??zclParseInReadRspCmd_0
   3273              {
   3274                uint8 dataType = *pBuf++;
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F9           MOV     R1,A
   \   000032   A3           INC     DPTR
   \   000033   0E           INC     R6
   \   000034   AF83         MOV     R7,DPH
   3275          
   3276                attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \   000036                ; Setup parameters for call to function zclGetAttrDataLength
   \   000036   EE           MOV     A,R6
   \   000037   FA           MOV     R2,A
   \   000038   EF           MOV     A,R7
   \   000039   FB           MOV     R3,A
   \   00003A   12....       LCALL   ??zclGetAttrDataLength?relay
   \   00003D   12....       LCALL   ?Subroutine79 & 0xFFFF
   3277                pBuf += attrDataLen; // move pass attribute data
   3278          
   3279                // add padding if needed
   3280                if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_107:
   \   000040   5003         JNC     ??CrossCallReturnLabel_113
   3281                {
   3282                  attrDataLen++;
   \   000042   12....       LCALL   ?Subroutine82 & 0xFFFF
   3283                }
   3284          
   3285                dataLen += attrDataLen;
   \                     ??CrossCallReturnLabel_113:
   \   000045   E5..         MOV     A,?V0 + 6
   \   000047   25..         ADD     A,?V0 + 0
   \   000049   F5..         MOV     ?V0 + 6,A
   \   00004B   E5..         MOV     A,?V0 + 7
   \   00004D   35..         ADDC    A,?V0 + 1
   \   00004F   F5..         MOV     ?V0 + 7,A
   3286              }
   3287            }
   \                     ??zclParseInReadRspCmd_0:
   \   000051   85..82       MOV     DPL,?V0 + 8
   \   000054   85..83       MOV     DPH,?V0 + 9
   \   000057   A3           INC     DPTR
   \   000058   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   00005B   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   00005E   40C4         JC      ??zclParseInReadRspCmd_1
   3288          
   3289            // calculate the length of the response header
   3290            hdrLen = sizeof( zclReadRspCmd_t ) + ( numAttr * sizeof( zclReadRspStatus_t ) );
   \   000060   75F006       MOV     B,#0x6
   \   000063   E5..         MOV     A,?V0 + 2
   \   000065   A4           MUL     AB
   \   000066   04           INC     A
   \   000067   F5..         MOV     ?V0 + 8,A
   3291          
   3292            readRspCmd = (zclReadRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   000069                ; Setup parameters for call to function osal_mem_alloc
   \   000069   25..         ADD     A,?V0 + 6
   \   00006B   FA           MOV     R2,A
   \   00006C   E4           CLR     A
   \   00006D   35..         ADDC    A,?V0 + 7
   \   00006F   FB           MOV     R3,A
   \   000070   12....       LCALL   ??osal_mem_alloc?relay
   \   000073   8A..         MOV     ?V0 + 10,R2
   \   000075   8B..         MOV     ?V0 + 11,R3
   3293            if ( readRspCmd != NULL )
   \   000077   EA           MOV     A,R2
   \   000078   45..         ORL     A,?V0 + 11
   \   00007A   7003         JNZ     $+5
   \   00007C   02....       LJMP    ??zclParseInReadRspCmd_2 & 0xFFFF
   3294            {
   3295              uint8 i;
   3296              pBuf = pCmd->pData;
   \   00007F   85..82       MOV     DPL,?V0 + 4
   \   000082   85..83       MOV     DPH,?V0 + 5
   \   000085   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   3297              dataPtr = (uint8 *)( (uint8 *)readRspCmd + hdrLen );
   \                     ??CrossCallReturnLabel_220:
   \   000088   EA           MOV     A,R2
   \   000089   25..         ADD     A,?V0 + 8
   \   00008B   F5..         MOV     ?V0 + 8,A
   \   00008D   EB           MOV     A,R3
   \   00008E   3400         ADDC    A,#0x0
   \   000090   F5..         MOV     ?V0 + 9,A
   3298          
   3299              readRspCmd->numAttr = numAttr;
   \   000092   8A82         MOV     DPL,R2
   \   000094   8B83         MOV     DPH,R3
   \   000096   E5..         MOV     A,?V0 + 2
   \   000098   F0           MOVX    @DPTR,A
   3300              for ( i = 0; i < numAttr; i++ )
   \   000099   75..00       MOV     ?V0 + 3,#0x0
   \   00009C   8068         SJMP    ??zclParseInReadRspCmd_3
   3301              {
   3302                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \                     ??zclParseInReadRspCmd_4:
   \   00009E   E5..         MOV     A,?V0 + 3
   \   0000A0   75F006       MOV     B,#0x6
   \   0000A3   12....       LCALL   ?Subroutine11 & 0xFFFF
   3303          
   3304                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3305                pBuf += 2;
   3306          
   3307                statusRec->status = *pBuf++;
   \                     ??CrossCallReturnLabel_2:
   \   0000A6   12....       LCALL   ?Subroutine17 & 0xFFFF
   3308                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \                     ??CrossCallReturnLabel_209:
   \   0000A9   7059         JNZ     ??zclParseInReadRspCmd_5
   3309                {
   3310                  statusRec->dataType = *pBuf++;
   \   0000AB   E0           MOVX    A,@DPTR
   \   0000AC   F9           MOV     R1,A
   \   0000AD   85..82       MOV     DPL,?V0 + 12
   \   0000B0   85..83       MOV     DPH,?V0 + 13
   \   0000B3   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_179:
   \   0000B6   0E           INC     R6
   \   0000B7   AF83         MOV     R7,DPH
   3311          
   3312                  attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \   0000B9                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000B9   EE           MOV     A,R6
   \   0000BA   FA           MOV     R2,A
   \   0000BB   EF           MOV     A,R7
   \   0000BC   FB           MOV     R3,A
   \   0000BD   12....       LCALL   ??zclGetAttrDataLength?relay
   \   0000C0   8A..         MOV     ?V0 + 0,R2
   \   0000C2   8B..         MOV     ?V0 + 1,R3
   3313                  zcl_memcpy( dataPtr, pBuf, attrDataLen);
   \   0000C4                ; Setup parameters for call to function osal_memcpy
   \   0000C4   8E..         MOV     ?V0 + 4,R6
   \   0000C6   8F..         MOV     ?V0 + 5,R7
   \   0000C8   75..00       MOV     ?V0 + 6,#0x0
   \   0000CB   78..         MOV     R0,#?V0 + 4
   \   0000CD   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000D0   AC..         MOV     R4,?V0 + 0
   \   0000D2   AD..         MOV     R5,?V0 + 1
   \   0000D4   AA..         MOV     R2,?V0 + 8
   \   0000D6   AB..         MOV     R3,?V0 + 9
   \   0000D8   12....       LCALL   ??osal_memcpy?relay
   \   0000DB   7403         MOV     A,#0x3
   \   0000DD   12....       LCALL   ?DEALLOC_XSTACK8
   3314                  statusRec->data = dataPtr;
   \   0000E0   85..82       MOV     DPL,?V0 + 12
   \   0000E3   85..83       MOV     DPH,?V0 + 13
   \   0000E6   A3           INC     DPTR
   \   0000E7   A3           INC     DPTR
   \   0000E8   A3           INC     DPTR
   \   0000E9   A3           INC     DPTR
   \   0000EA   E5..         MOV     A,?V0 + 8
   \   0000EC   F0           MOVX    @DPTR,A
   \   0000ED   A3           INC     DPTR
   \   0000EE   E5..         MOV     A,?V0 + 9
   \   0000F0   12....       LCALL   ?Subroutine13 & 0xFFFF
   3315          
   3316                  pBuf += attrDataLen; // move pass attribute data
   3317          
   3318                  // advance attribute data pointer
   3319                  if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_6:
   \   0000F3   5003         JNC     ??CrossCallReturnLabel_111
   3320                  {
   3321                    attrDataLen++;
   \   0000F5   12....       LCALL   ?Subroutine81 & 0xFFFF
   3322                  }
   3323          
   3324                  dataPtr += attrDataLen;
   \                     ??CrossCallReturnLabel_111:
   \   0000F8   E5..         MOV     A,?V0 + 8
   \   0000FA   25..         ADD     A,?V0 + 0
   \   0000FC   F5..         MOV     ?V0 + 8,A
   \   0000FE   E5..         MOV     A,?V0 + 9
   \   000100   35..         ADDC    A,?V0 + 1
   \   000102   F5..         MOV     ?V0 + 9,A
   3325                }
   3326              }
   \                     ??zclParseInReadRspCmd_5:
   \   000104   05..         INC     ?V0 + 3
   \                     ??zclParseInReadRspCmd_3:
   \   000106   E5..         MOV     A,?V0 + 3
   \   000108   C3           CLR     C
   \   000109   95..         SUBB    A,?V0 + 2
   \   00010B   4091         JC      ??zclParseInReadRspCmd_4
   3327            }
   3328          
   3329            return ( (void *)readRspCmd );
   \                     ??zclParseInReadRspCmd_2:
   \   00010D   02....       LJMP    ?Subroutine5 & 0xFFFF
   3330          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   85..82       MOV     DPL,?V0 + 12
   \   000003   85..83       MOV     DPH,?V0 + 13
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008                REQUIRE ??Subroutine125_0
   \   000008                ; // Fall through to label ??Subroutine125_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine82:
   \   000000   2401         ADD     A,#0x1
   \   000002   F5..         MOV     ?V0 + 0,A
   \   000004   EB           MOV     A,R3
   \   000005   3400         ADDC    A,#0x0
   \   000007   F5..         MOV     ?V0 + 1,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine81:
   \   000000   2401         ADD     A,#0x1
   \   000002   F5..         MOV     ?V0 + 0,A
   \   000004   E5..         MOV     A,?V0 + 1
   \   000006   3400         ADDC    A,#0x0
   \   000008   F5..         MOV     ?V0 + 1,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine79:
   \   000000   12....       LCALL   ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_156:
   \   000003   EA           MOV     A,R2
   \   000004   A2E0         MOV     C,0xE0 /* A   */.0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_143:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine126_0:
   \   000000   F583         MOV     DPH,A
   \   000002                REQUIRE ??Subroutine127_0
   \   000002                ; // Fall through to label ??Subroutine127_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   12....       LCALL   ??Subroutine114_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_157:
   \   000004   E5..         MOV     A,?V0 + 0
   \   000006   A2E0         MOV     C,0xE0 /* A   */.0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V0 + 10
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V0 + 11
   \   00000B   39           ADDC    A,R1
   \   00000C   F583         MOV     DPH,A
   \   00000E   A3           INC     DPTR
   \   00000F   8582..       MOV     ?V0 + 12,DPL
   \   000012   8583..       MOV     ?V0 + 13,DPH
   \   000015   8E82         MOV     DPL,R6
   \   000017   8F83         MOV     DPH,R7
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   FA           MOV     R2,A
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F9           MOV     R1,A
   \   00001E   EA           MOV     A,R2
   \   00001F   85..82       MOV     DPL,?V0 + 12
   \   000022   85..83       MOV     DPH,?V0 + 13
   \   000025   F0           MOVX    @DPTR,A
   \   000026   A3           INC     DPTR
   \   000027   E9           MOV     A,R1
   \   000028   F0           MOVX    @DPTR,A
   \   000029   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   00002C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine101:
   \   000000   EE           MOV     A,R6
   \   000001   2402         ADD     A,#0x2
   \   000003   FE           MOV     R6,A
   \   000004   EF           MOV     A,R7
   \   000005   3400         ADDC    A,#0x0
   \   000007   FF           MOV     R7,A
   \   000008   8E82         MOV     DPL,R6
   \   00000A   8F83         MOV     DPH,R7
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine90:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   28           ADD     A,R0
   \   000002   F8           MOV     R0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   39           ADDC    A,R1
   \   000006   F9           MOV     R1,A
   \   000007   C3           CLR     C
   \   000008   EE           MOV     A,R6
   \   000009   98           SUBB    A,R0
   \   00000A   EF           MOV     A,R7
   \   00000B   99           SUBB    A,R1
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_288:
   \   000003   85..82       MOV     DPL,?V0 + 4
   \   000006   85..83       MOV     DPH,?V0 + 5
   \   000009   22           RET
   3331          #endif // ZCL_READ
   3332          
   3333          #ifdef ZCL_WRITE
   3334          /*********************************************************************
   3335           * @fn      zclParseInWriteCmd
   3336           *
   3337           * @brief   Parse the "Profile" Write, Write Undivided and Write No
   3338           *          Response Commands
   3339           *
   3340           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3341           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3342           *
   3343           * @param   pCmd - pointer to incoming data to parse
   3344           *
   3345           * @return  pointer to the parsed command structure
   3346           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3347          void *zclParseInWriteCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteCmd:
   3348          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 8,R2
   \   000007   8B..         MOV     ?V0 + 9,R3
   3349            zclWriteCmd_t *writeCmd;
   3350            uint8 *pBuf = pCmd->pData;
   \   000009   12....       LCALL   ?Subroutine39 & 0xFFFF
   3351            uint16 attrDataLen;
   3352            uint8 *dataPtr;
   3353            uint8 numAttr = 0;
   \                     ??CrossCallReturnLabel_226:
   \   00000C   75..00       MOV     ?V0 + 7,#0x0
   3354            uint8 hdrLen;
   3355            uint16 dataLen = 0;
   \   00000F   75..00       MOV     ?V0 + 4,#0x0
   \   000012   75..00       MOV     ?V0 + 5,#0x0
   \   000015   8026         SJMP    ??zclParseInWriteCmd_0
   3356          
   3357            // find out the number of attributes and the length of attribute data
   3358            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3359            {
   3360              uint8 dataType;
   3361          
   3362              numAttr++;
   \                     ??zclParseInWriteCmd_1:
   \   000017   05..         INC     ?V0 + 7
   3363              pBuf += 2; // move pass attribute id
   \   000019   12....       LCALL   ?Subroutine71 & 0xFFFF
   3364          
   3365              dataType = *pBuf++;
   \                     ??CrossCallReturnLabel_95:
   \   00001C   F9           MOV     R1,A
   \   00001D   A3           INC     DPTR
   \   00001E   AE82         MOV     R6,DPL
   \   000020   AF83         MOV     R7,DPH
   3366          
   3367              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \   000022                ; Setup parameters for call to function zclGetAttrDataLength
   \   000022   EE           MOV     A,R6
   \   000023   FA           MOV     R2,A
   \   000024   EF           MOV     A,R7
   \   000025   FB           MOV     R3,A
   \   000026   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000029   12....       LCALL   ?Subroutine79 & 0xFFFF
   3368              pBuf += attrDataLen; // move pass attribute data
   3369          
   3370              // add padding if needed
   3371              if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_108:
   \   00002C   5003         JNC     ??CrossCallReturnLabel_114
   3372              {
   3373                attrDataLen++;
   \   00002E   12....       LCALL   ?Subroutine82 & 0xFFFF
   3374              }
   3375          
   3376              dataLen += attrDataLen;
   \                     ??CrossCallReturnLabel_114:
   \   000031   E5..         MOV     A,?V0 + 4
   \   000033   25..         ADD     A,?V0 + 0
   \   000035   F5..         MOV     ?V0 + 4,A
   \   000037   E5..         MOV     A,?V0 + 5
   \   000039   35..         ADDC    A,?V0 + 1
   \   00003B   F5..         MOV     ?V0 + 5,A
   3377            }
   \                     ??zclParseInWriteCmd_0:
   \   00003D   85..82       MOV     DPL,?V0 + 8
   \   000040   85..83       MOV     DPH,?V0 + 9
   \   000043   A3           INC     DPTR
   \   000044   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   000047   40CE         JC      ??zclParseInWriteCmd_1
   3378          
   3379            // calculate the length of the response header
   3380            hdrLen = sizeof( zclWriteCmd_t ) + ( numAttr * sizeof( zclWriteRec_t ) );
   \   000049   75F005       MOV     B,#0x5
   \   00004C   E5..         MOV     A,?V0 + 7
   \   00004E   A4           MUL     AB
   \   00004F   04           INC     A
   \   000050   F5..         MOV     ?V0 + 6,A
   3381          
   3382            writeCmd = (zclWriteCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   000052                ; Setup parameters for call to function osal_mem_alloc
   \   000052   25..         ADD     A,?V0 + 4
   \   000054   FA           MOV     R2,A
   \   000055   E4           CLR     A
   \   000056   35..         ADDC    A,?V0 + 5
   \   000058   FB           MOV     R3,A
   \   000059   12....       LCALL   ??osal_mem_alloc?relay
   \   00005C   8A..         MOV     ?V0 + 10,R2
   \   00005E   8B..         MOV     ?V0 + 11,R3
   3383            if ( writeCmd != NULL )
   \   000060   EA           MOV     A,R2
   \   000061   45..         ORL     A,?V0 + 11
   \   000063   7003         JNZ     $+5
   \   000065   02....       LJMP    ??zclParseInWriteCmd_2 & 0xFFFF
   3384            {
   3385              uint8 i;
   3386              pBuf = pCmd->pData;
   \   000068   85..82       MOV     DPL,?V0 + 2
   \   00006B   85..83       MOV     DPH,?V0 + 3
   \   00006E   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   3387              dataPtr = (uint8 *)( (uint8 *)writeCmd + hdrLen );
   \                     ??CrossCallReturnLabel_221:
   \   000071   85....       MOV     ?V0 + 0,?V0 + 6
   \   000074   EA           MOV     A,R2
   \   000075   25..         ADD     A,?V0 + 0
   \   000077   F5..         MOV     ?V0 + 2,A
   \   000079   EB           MOV     A,R3
   \   00007A   3400         ADDC    A,#0x0
   \   00007C   F5..         MOV     ?V0 + 3,A
   3388          
   3389              writeCmd->numAttr = numAttr;
   \   00007E   8A82         MOV     DPL,R2
   \   000080   8B83         MOV     DPH,R3
   \   000082   E5..         MOV     A,?V0 + 7
   \   000084   F0           MOVX    @DPTR,A
   3390              for ( i = 0; i < numAttr; i++ )
   \   000085   75..00       MOV     ?V0 + 8,#0x0
   \   000088   8058         SJMP    ??zclParseInWriteCmd_3
   3391              {
   3392                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zclParseInWriteCmd_4:
   \   00008A   E5..         MOV     A,?V0 + 8
   \   00008C   75F005       MOV     B,#0x5
   \   00008F   12....       LCALL   ?Subroutine11 & 0xFFFF
   3393          
   3394                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3395                pBuf += 2;
   3396                statusRec->dataType = *pBuf++;
   \                     ??CrossCallReturnLabel_3:
   \   000092   F9           MOV     R1,A
   \   000093   12....       LCALL   ?Subroutine17 & 0xFFFF
   3397          
   3398                attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \                     ??CrossCallReturnLabel_210:
   \   000096                ; Setup parameters for call to function zclGetAttrDataLength
   \   000096   EE           MOV     A,R6
   \   000097   FA           MOV     R2,A
   \   000098   EF           MOV     A,R7
   \   000099   FB           MOV     R3,A
   \   00009A   12....       LCALL   ??zclGetAttrDataLength?relay
   \   00009D   8A..         MOV     ?V0 + 0,R2
   \   00009F   8B..         MOV     ?V0 + 1,R3
   3399                zcl_memcpy( dataPtr, pBuf, attrDataLen);
   \   0000A1                ; Setup parameters for call to function osal_memcpy
   \   0000A1   8E..         MOV     ?V0 + 4,R6
   \   0000A3   8F..         MOV     ?V0 + 5,R7
   \   0000A5   75..00       MOV     ?V0 + 6,#0x0
   \   0000A8   78..         MOV     R0,#?V0 + 4
   \   0000AA   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000AD   AC..         MOV     R4,?V0 + 0
   \   0000AF   AD..         MOV     R5,?V0 + 1
   \   0000B1   AA..         MOV     R2,?V0 + 2
   \   0000B3   AB..         MOV     R3,?V0 + 3
   \   0000B5   12....       LCALL   ??osal_memcpy?relay
   \   0000B8   7403         MOV     A,#0x3
   \   0000BA   12....       LCALL   ?DEALLOC_XSTACK8
   3400                statusRec->attrData = dataPtr;
   \   0000BD   85..82       MOV     DPL,?V0 + 12
   \   0000C0   85..83       MOV     DPH,?V0 + 13
   \   0000C3   A3           INC     DPTR
   \   0000C4   A3           INC     DPTR
   \   0000C5   A3           INC     DPTR
   \   0000C6   E5..         MOV     A,?V0 + 2
   \   0000C8   F0           MOVX    @DPTR,A
   \   0000C9   A3           INC     DPTR
   \   0000CA   E5..         MOV     A,?V0 + 3
   \   0000CC   12....       LCALL   ?Subroutine13 & 0xFFFF
   3401          
   3402                pBuf += attrDataLen; // move pass attribute data
   3403          
   3404                // advance attribute data pointer
   3405                if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_7:
   \   0000CF   5003         JNC     ??CrossCallReturnLabel_112
   3406                {
   3407                  attrDataLen++;
   \   0000D1   12....       LCALL   ?Subroutine81 & 0xFFFF
   3408                }
   3409          
   3410                dataPtr += attrDataLen;
   \                     ??CrossCallReturnLabel_112:
   \   0000D4   E5..         MOV     A,?V0 + 2
   \   0000D6   25..         ADD     A,?V0 + 0
   \   0000D8   F5..         MOV     ?V0 + 2,A
   \   0000DA   E5..         MOV     A,?V0 + 3
   \   0000DC   35..         ADDC    A,?V0 + 1
   \   0000DE   F5..         MOV     ?V0 + 3,A
   3411              }
   \   0000E0   05..         INC     ?V0 + 8
   \                     ??zclParseInWriteCmd_3:
   \   0000E2   E5..         MOV     A,?V0 + 8
   \   0000E4   C3           CLR     C
   \   0000E5   95..         SUBB    A,?V0 + 7
   \   0000E7   40A1         JC      ??zclParseInWriteCmd_4
   3412            }
   3413          
   3414            return ( (void *)writeCmd );
   \                     ??zclParseInWriteCmd_2:
   \   0000E9   02....       LJMP    ?Subroutine5 & 0xFFFF
   3415          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   EA           MOV     A,R2
   \   000001   2403         ADD     A,#0x3
   \   000003   F5..         MOV     ?V0 + 2,A
   \   000005   EB           MOV     A,R3
   \   000006   3400         ADDC    A,#0x0
   \   000008   F5..         MOV     ?V0 + 3,A
   \   00000A   85..82       MOV     DPL,?V0 + 2
   \   00000D                REQUIRE ??Subroutine126_0
   \   00000D                ; // Fall through to label ??Subroutine126_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_287:
   \   000003   85..82       MOV     DPL,?V0 + 2
   \   000006   85..83       MOV     DPH,?V0 + 3
   \   000009   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_128:
   \   00000C   22           RET
   3416          
   3417          /*********************************************************************
   3418           * @fn      zclParseInWriteRspCmd
   3419           *
   3420           * @brief   Parse the "Profile" Write Response Commands
   3421           *
   3422           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3423           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3424           *
   3425           * @param   pCmd - pointer to incoming data to parse
   3426           *
   3427           * @return  pointer to the parsed command structure
   3428           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3429          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteRspCmd:
   3430          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   3431            zclWriteRspCmd_t *writeRspCmd;
   3432            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL   ?Subroutine39 & 0xFFFF
   3433            uint8 i = 0;
   \                     ??CrossCallReturnLabel_227:
   \   000008   75..00       MOV     ?V0 + 4,#0x0
   3434          
   3435            writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof ( zclWriteRspCmd_t ) + pCmd->dataLen );
   \   00000B   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   00000E   12....       LCALL   ??osal_mem_alloc?relay
   3436            if ( writeRspCmd != NULL )
   \   000011   EA           MOV     A,R2
   \   000012   4B           ORL     A,R3
   \   000013   6060         JZ      ??zclParseInWriteRspCmd_0
   3437            {
   3438              if ( pCmd->dataLen == 1 )
   \   000015   85..82       MOV     DPL,?V0 + 0
   \   000018   85..83       MOV     DPH,?V0 + 1
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   6401         XRL     A,#0x1
   \   00001E   7002         JNZ     ??zclParseInWriteRspCmd_1
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \                     ??zclParseInWriteRspCmd_1:
   \   000022   703F         JNZ     ??CrossCallReturnLabel_98
   3439              {
   3440                // special case when all writes were successfull
   3441                writeRspCmd->attrList[i++].status = *pBuf;
   \   000024   8E82         MOV     DPL,R6
   \   000026   8F83         MOV     DPH,R7
   \   000028   12....       LCALL   ??Subroutine128_0 & 0xFFFF
   3442              }
   \                     ??CrossCallReturnLabel_229:
   \   00002B   A3           INC     DPTR
   \   00002C   F0           MOVX    @DPTR,A
   \   00002D   75..01       MOV     ?V0 + 4,#0x1
   \   000030   803C         SJMP    ??zclParseInWriteRspCmd_2
   3443              else
   3444              {
   3445                while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3446                {
   3447                  writeRspCmd->attrList[i].status = *pBuf++;
   \                     ??zclParseInWriteRspCmd_3:
   \   000032   E5..         MOV     A,?V0 + 4
   \   000034   75F003       MOV     B,#0x3
   \   000037   A4           MUL     AB
   \   000038   F8           MOV     R0,A
   \   000039   A9F0         MOV     R1,B
   \   00003B   EA           MOV     A,R2
   \   00003C   28           ADD     A,R0
   \   00003D   F8           MOV     R0,A
   \   00003E   EB           MOV     A,R3
   \   00003F   39           ADDC    A,R1
   \   000040   F9           MOV     R1,A
   \   000041   8E82         MOV     DPL,R6
   \   000043   8F83         MOV     DPH,R7
   \   000045   E0           MOVX    A,@DPTR
   \   000046   8882         MOV     DPL,R0
   \   000048   8983         MOV     DPH,R1
   \   00004A   12....       LCALL   ?Subroutine16 & 0xFFFF
   3448                  writeRspCmd->attrList[i++].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??CrossCallReturnLabel_13:
   \   00004D   F5..         MOV     ?V0 + 6,A
   \   00004F   A3           INC     DPTR
   \   000050   E0           MOVX    A,@DPTR
   \   000051   FD           MOV     R5,A
   \   000052   E5..         MOV     A,?V0 + 6
   \   000054   8882         MOV     DPL,R0
   \   000056   8983         MOV     DPH,R1
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   F0           MOVX    @DPTR,A
   \   00005B   A3           INC     DPTR
   \   00005C   ED           MOV     A,R5
   \   00005D   F0           MOVX    @DPTR,A
   \   00005E   05..         INC     ?V0 + 4
   3449                  pBuf += 2;
   \   000060   12....       LCALL   ?Subroutine72 & 0xFFFF
   3450                }
   \                     ??CrossCallReturnLabel_98:
   \   000063   85..82       MOV     DPL,?V0 + 0
   \   000066   85..83       MOV     DPH,?V0 + 1
   \   000069   12....       LCALL   ?Subroutine36 & 0xFFFF
   3451              }
   \                     ??CrossCallReturnLabel_36:
   \   00006C   40C4         JC      ??zclParseInWriteRspCmd_3
   3452          
   3453              writeRspCmd->numAttr = i;
   \                     ??zclParseInWriteRspCmd_2:
   \   00006E   8A82         MOV     DPL,R2
   \   000070   8B83         MOV     DPH,R3
   \   000072   E5..         MOV     A,?V0 + 4
   \   000074   F0           MOVX    @DPTR,A
   3454            }
   3455          
   3456            return ( (void *)writeRspCmd );
   \                     ??zclParseInWriteRspCmd_0:
   \   000075   02....       LJMP    ??Subroutine121_0 & 0xFFFF
   3457          }
   3458          #endif // ZCL_WRITE
   3459          
   3460          #ifdef ZCL_REPORT
   3461          /*********************************************************************
   3462           * @fn      zclParseInConfigReportCmd
   3463           *
   3464           * @brief   Parse the "Profile" Configure Reporting Command
   3465           *
   3466           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3467           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3468           *
   3469           * @param   pCmd - pointer to incoming data to parse
   3470           *
   3471           * @return  pointer to the parsed command structure
   3472           */
   3473          void *zclParseInConfigReportCmd( zclParseCmd_t *pCmd )
   3474          {
   3475            zclCfgReportCmd_t *cfgReportCmd;
   3476            uint8 *pBuf = pCmd->pData;
   3477            uint8 *dataPtr;
   3478            uint8 numAttr = 0;
   3479            uint8 dataType;
   3480            uint8 hdrLen;
   3481            uint16 dataLen = 0;
   3482            uint8 reportChangeLen; // length of Reportable Change field
   3483          
   3484            // Calculate the length of the Request command
   3485            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3486            {
   3487              uint8 direction;
   3488          
   3489              numAttr++;
   3490              direction = *pBuf++;
   3491              pBuf += 2; // move pass the attribute ID
   3492          
   3493              // Is there a Reportable Change field?
   3494              if ( direction == ZCL_SEND_ATTR_REPORTS )
   3495              {
   3496                dataType = *pBuf++;
   3497                pBuf += 4; // move pass the Min and Max Reporting Intervals
   3498          
   3499                // For attributes of 'discrete' data types this field is omitted
   3500                if ( zclAnalogDataType( dataType ) )
   3501                {
   3502                  reportChangeLen = zclGetDataTypeLength( dataType );
   3503                  pBuf += reportChangeLen;
   3504          
   3505                  // add padding if needed
   3506                  if ( PADDING_NEEDED( reportChangeLen ) )
   3507                  {
   3508                    reportChangeLen++;
   3509                  }
   3510          
   3511                  dataLen += reportChangeLen;
   3512                }
   3513                else
   3514                {
   3515                  pBuf++; // move past reportable change field
   3516                }
   3517              }
   3518              else
   3519              {
   3520                pBuf += 2; // move pass the Timeout Period
   3521              }
   3522            } // while loop
   3523          
   3524            hdrLen = sizeof( zclCfgReportCmd_t ) + ( numAttr * sizeof( zclCfgReportRec_t ) );
   3525          
   3526            cfgReportCmd = (zclCfgReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   3527            if ( cfgReportCmd != NULL )
   3528            {
   3529              uint8 i;
   3530              pBuf = pCmd->pData;
   3531              dataPtr = (uint8 *)( (uint8 *)cfgReportCmd + hdrLen );
   3532          
   3533              cfgReportCmd->numAttr = numAttr;
   3534              for ( i = 0; i < numAttr; i++ )
   3535              {
   3536                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   3537          
   3538                zcl_memset( reportRec, 0, sizeof( zclCfgReportRec_t ) );
   3539          
   3540                reportRec->direction = *pBuf++;
   3541                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3542                pBuf += 2;
   3543                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   3544                {
   3545                  // Attribute to be reported
   3546                  reportRec->dataType = *pBuf++;
   3547                  reportRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3548                  pBuf += 2;
   3549                  reportRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3550                  pBuf += 2;
   3551          
   3552                  // For attributes of 'discrete' data types this field is omitted
   3553                  if ( zclAnalogDataType( reportRec->dataType ) )
   3554                  {
   3555                    zcl_BuildAnalogData( reportRec->dataType, dataPtr, pBuf);
   3556                    reportRec->reportableChange = dataPtr;
   3557          
   3558                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
   3559                    pBuf += reportChangeLen;
   3560          
   3561                    // advance attribute data pointer
   3562                    if ( PADDING_NEEDED( reportChangeLen ) )
   3563                    {
   3564                      reportChangeLen++;
   3565                    }
   3566          
   3567                    dataPtr += reportChangeLen;
   3568                  }
   3569                }
   3570                else
   3571                {
   3572                  // Attribute reports to be received
   3573                  reportRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   3574                  pBuf += 2;
   3575                }
   3576              } // while loop
   3577            }
   3578          
   3579            return ( (void *)cfgReportCmd );
   3580          }
   3581          
   3582          /*********************************************************************
   3583           * @fn      zclParseInConfigReportRspCmd
   3584           *
   3585           * @brief   Parse the "Profile" Configure Reporting Response Command
   3586           *
   3587           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3588           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3589           *
   3590           * @param   pCmd - pointer to incoming data to parse
   3591           *
   3592           * @return  pointer to the parsed command structure
   3593           */
   3594          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd )
   3595          {
   3596            zclCfgReportRspCmd_t *cfgReportRspCmd;
   3597            uint8 *pBuf = pCmd->pData;
   3598            uint8 numAttr;
   3599          
   3600            numAttr = pCmd->dataLen / ( 1 + 1 + 2 ); // Status + Direction + Attribute ID
   3601          
   3602            cfgReportRspCmd = (zclCfgReportRspCmd_t *)zcl_mem_alloc( sizeof( zclCfgReportRspCmd_t )
   3603                                                      + ( numAttr * sizeof( zclCfgReportStatus_t ) ) );
   3604            if ( cfgReportRspCmd != NULL )
   3605            {
   3606              uint8 i;
   3607              cfgReportRspCmd->numAttr = numAttr;
   3608              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   3609              {
   3610                cfgReportRspCmd->attrList[i].status = *pBuf++;
   3611                cfgReportRspCmd->attrList[i].direction = *pBuf++;
   3612                cfgReportRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3613                pBuf += 2;
   3614              }
   3615            }
   3616          
   3617            return ( (void *)cfgReportRspCmd );
   3618          }
   3619          
   3620          /*********************************************************************
   3621           * @fn      zclParseInReadReportCfgCmd
   3622           *
   3623           * @brief   Parse the "Profile" Read Reporting Configuration Command
   3624           *
   3625           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3626           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3627           *
   3628           * @param   pCmd - pointer to incoming data to parse
   3629           *
   3630           * @return  pointer to the parsed command structure
   3631           */
   3632          void *zclParseInReadReportCfgCmd( zclParseCmd_t *pCmd )
   3633          {
   3634            zclReadReportCfgCmd_t *readReportCfgCmd;
   3635            uint8 *pBuf = pCmd->pData;
   3636            uint8 numAttr;
   3637          
   3638            numAttr = pCmd->dataLen / ( 1 + 2 ); // Direction + Attribute ID
   3639          
   3640            readReportCfgCmd = (zclReadReportCfgCmd_t *)zcl_mem_alloc( sizeof( zclReadReportCfgCmd_t )
   3641                                                            + ( numAttr * sizeof( zclReadReportCfgRec_t ) ) );
   3642            if ( readReportCfgCmd != NULL )
   3643            {
   3644              uint8 i;
   3645              readReportCfgCmd->numAttr = numAttr;
   3646              for ( i = 0; i < readReportCfgCmd->numAttr; i++)
   3647              {
   3648                readReportCfgCmd->attrList[i].direction = *pBuf++;;
   3649                readReportCfgCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3650                pBuf += 2;
   3651              }
   3652            }
   3653          
   3654            return ( (void *)readReportCfgCmd );
   3655          }
   3656          
   3657          /*********************************************************************
   3658           * @fn      zclParseInReadReportCfgRspCmd
   3659           *
   3660           * @brief   Parse the "Profile" Read Reporting Configuration Response Command
   3661           *
   3662           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3663           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3664           *
   3665           * @param   pCmd - pointer to incoming data to parse
   3666           *
   3667           * @return  pointer to the parsed command structure
   3668           */
   3669          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd )
   3670          {
   3671            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   3672            uint8 reportChangeLen;
   3673            uint8 *pBuf = pCmd->pData;
   3674            uint8 *dataPtr;
   3675            uint8 numAttr = 0;
   3676            uint8 hdrLen;
   3677            uint16 dataLen = 0;
   3678          
   3679            // Calculate the length of the response command
   3680            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3681            {
   3682              uint8 status;
   3683              uint8 direction;
   3684          
   3685              numAttr++;
   3686              status = *pBuf++;
   3687              direction = *pBuf++;
   3688              pBuf += 2; // move pass the attribute ID
   3689          
   3690              if ( status == ZCL_STATUS_SUCCESS )
   3691              {
   3692                if ( direction == ZCL_SEND_ATTR_REPORTS )
   3693                {
   3694                  uint8 dataType = *pBuf++;
   3695                  pBuf += 4; // move pass the Min and Max Reporting Intervals
   3696          
   3697                  // For attributes of 'discrete' data types this field is omitted
   3698                  if ( zclAnalogDataType( dataType ) )
   3699                  {
   3700                    reportChangeLen = zclGetDataTypeLength( dataType );
   3701                    pBuf += reportChangeLen;
   3702          
   3703                    // add padding if needed
   3704                    if ( PADDING_NEEDED( reportChangeLen ) )
   3705                    {
   3706                      reportChangeLen++;
   3707                    }
   3708          
   3709                    dataLen += reportChangeLen;
   3710                  }
   3711                }
   3712                else
   3713                {
   3714                  pBuf += 2; // move pass the Timeout field
   3715                }
   3716              }
   3717            } // while loop
   3718          
   3719            hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( numAttr * sizeof( zclReportCfgRspRec_t ) );
   3720          
   3721            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   3722            if ( readReportCfgRspCmd != NULL )
   3723            {
   3724              uint8 i;
   3725              pBuf = pCmd->pData;
   3726              dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
   3727          
   3728              readReportCfgRspCmd->numAttr = numAttr;
   3729              for ( i = 0; i < numAttr; i++ )
   3730              {
   3731                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   3732          
   3733                reportRspRec->status = *pBuf++;
   3734                reportRspRec->direction = *pBuf++;
   3735                reportRspRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3736                pBuf += 2;
   3737          
   3738                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   3739                {
   3740                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   3741                  {
   3742                    reportRspRec->dataType = *pBuf++;
   3743                    reportRspRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3744                    pBuf += 2;
   3745                    reportRspRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3746                    pBuf += 2;
   3747          
   3748                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   3749                    {
   3750                      zcl_BuildAnalogData( reportRspRec->dataType, dataPtr, pBuf);
   3751                      reportRspRec->reportableChange = dataPtr;
   3752          
   3753                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
   3754                      pBuf += reportChangeLen;
   3755          
   3756                      // advance attribute data pointer
   3757                      if ( PADDING_NEEDED( reportChangeLen ) )
   3758                      {
   3759                        reportChangeLen++;
   3760                      }
   3761          
   3762                      dataPtr += reportChangeLen;
   3763                    }
   3764                  }
   3765                  else
   3766                  {
   3767                    reportRspRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   3768                    pBuf += 2;
   3769                  }
   3770                }
   3771              }
   3772            }
   3773          
   3774            return ( (void *)readReportCfgRspCmd );
   3775          }
   3776          
   3777          /*********************************************************************
   3778           * @fn      zclParseInReportCmd
   3779           *
   3780           * @brief   Parse the "Profile" Report Command
   3781           *
   3782           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3783           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3784           *
   3785           * @param   pCmd - pointer to incoming data to parse
   3786           *
   3787           * @return  pointer to the parsed command structure
   3788           */
   3789          void *zclParseInReportCmd( zclParseCmd_t *pCmd )
   3790          {
   3791            zclReportCmd_t *reportCmd;
   3792            uint8 *pBuf = pCmd->pData;
   3793            uint16 attrDataLen;
   3794            uint8 *dataPtr;
   3795            uint8 numAttr = 0;
   3796            uint8 hdrLen;
   3797            uint16 dataLen = 0;
   3798          
   3799            // find out the number of attributes and the length of attribute data
   3800            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3801            {
   3802              uint8 dataType;
   3803          
   3804              numAttr++;
   3805              pBuf += 2; // move pass attribute id
   3806          
   3807              dataType = *pBuf++;
   3808          
   3809              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   3810              pBuf += attrDataLen; // move pass attribute data
   3811          
   3812              // add padding if needed
   3813              if ( PADDING_NEEDED( attrDataLen ) )
   3814              {
   3815                attrDataLen++;
   3816              }
   3817          
   3818              dataLen += attrDataLen;
   3819            }
   3820          
   3821            hdrLen = sizeof( zclReportCmd_t ) + ( numAttr * sizeof( zclReport_t ) );
   3822          
   3823            reportCmd = (zclReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   3824            if (reportCmd != NULL )
   3825            {
   3826              uint8 i;
   3827              pBuf = pCmd->pData;
   3828              dataPtr = (uint8 *)( (uint8 *)reportCmd + hdrLen );
   3829          
   3830              reportCmd->numAttr = numAttr;
   3831              for ( i = 0; i < numAttr; i++ )
   3832              {
   3833                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   3834          
   3835                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3836                pBuf += 2;
   3837                reportRec->dataType = *pBuf++;
   3838          
   3839                attrDataLen = zclGetAttrDataLength( reportRec->dataType, pBuf );
   3840                zcl_memcpy( dataPtr, pBuf, attrDataLen );
   3841                reportRec->attrData = dataPtr;
   3842          
   3843                pBuf += attrDataLen; // move pass attribute data
   3844          
   3845                // advance attribute data pointer
   3846                if ( PADDING_NEEDED( attrDataLen ) )
   3847                {
   3848                  attrDataLen++;
   3849                }
   3850          
   3851                dataPtr += attrDataLen;
   3852              }
   3853            }
   3854          
   3855            return ( (void *)reportCmd );
   3856          }
   3857          #endif // ZCL_REPORT
   3858          
   3859          /*********************************************************************
   3860           * @fn      zclParseInDefaultRspCmd
   3861           *
   3862           * @brief   Parse the "Profile" Default Response Command
   3863           *
   3864           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3865           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3866           *
   3867           * @param   pCmd - pointer to incoming data to parse
   3868           *
   3869           * @return  pointer to the parsed command structure
   3870           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3871          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDefaultRspCmd:
   3872          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   3873            zclDefaultRspCmd_t *defaultRspCmd;
   3874            uint8 *pBuf = pCmd->pData;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   3875          
   3876            defaultRspCmd = (zclDefaultRspCmd_t *)zcl_mem_alloc( sizeof ( zclDefaultRspCmd_t ) );
   \                     ??CrossCallReturnLabel_222:
   \   00000F                ; Setup parameters for call to function osal_mem_alloc
   \   00000F   7A02         MOV     R2,#0x2
   \   000011   7B00         MOV     R3,#0x0
   \   000013   12....       LCALL   ??osal_mem_alloc?relay
   3877            if ( defaultRspCmd != NULL )
   \   000016   EA           MOV     A,R2
   \   000017   4B           ORL     A,R3
   \   000018   600F         JZ      ??zclParseInDefaultRspCmd_0
   3878            {
   3879              defaultRspCmd->commandID = *pBuf++;
   \   00001A   8E82         MOV     DPL,R6
   \   00001C   8F83         MOV     DPH,R7
   \   00001E   12....       LCALL   ??Subroutine128_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_230:
   \   000021   12....       LCALL   ??Subroutine118_0 & 0xFFFF
   3880              defaultRspCmd->statusCode = *pBuf;
   \                     ??CrossCallReturnLabel_177:
   \   000024   12....       LCALL   ??Subroutine128_0 & 0xFFFF
   3881            }
   \                     ??CrossCallReturnLabel_231:
   \   000027   A3           INC     DPTR
   \   000028   F0           MOVX    @DPTR,A
   3882          
   3883            return ( (void *)defaultRspCmd );
   \                     ??zclParseInDefaultRspCmd_0:
   \   000029   02....       LJMP    ?Subroutine2 & 0xFFFF
   3884          }
   3885          
   3886          #ifdef ZCL_DISCOVER
   3887          /*********************************************************************
   3888           * @fn      zclParseInDiscAttrsCmd
   3889           *
   3890           * @brief   Parse the "Profile" Discovery Attributes and Attributes Extended Commands
   3891           *
   3892           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3893           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3894           *
   3895           * @param   pCmd - pointer to incoming data to parse
   3896           *
   3897           * @return  pointer to the parsed command structure
   3898           */
   3899          void *zclParseInDiscAttrsCmd( zclParseCmd_t *pCmd )
   3900          {
   3901            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   3902            uint8 *pBuf = pCmd->pData;
   3903          
   3904            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsCmd_t ) );
   3905            if ( pDiscoverCmd != NULL )
   3906            {
   3907              pDiscoverCmd->startAttr = BUILD_UINT16( pBuf[0], pBuf[1] );
   3908              pBuf += 2;
   3909              pDiscoverCmd->maxAttrIDs = *pBuf;
   3910            }
   3911          
   3912            return ( (void *)pDiscoverCmd );
   3913          }
   3914          
   3915          /*********************************************************************
   3916           * @fn      zclParseInDiscAttrsRspCmd
   3917           *
   3918           * @brief   Parse the "Profile" Discovery Response Commands
   3919           *
   3920           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3921           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3922           *
   3923           * @param   pCmd - pointer to incoming data to parse
   3924           *
   3925           * @return  pointer to the parsed command structure
   3926           */
   3927          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   3928          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd )
   3929          {
   3930            zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd;
   3931            uint8 *pBuf = pCmd->pData;
   3932            uint8 numAttr = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 ); // Attr ID + Data Type
   3933          
   3934            pDiscoverRspCmd = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsRspCmd_t ) +
   3935                              ( numAttr * sizeof(zclDiscoverAttrInfo_t) ) );
   3936          
   3937            if ( pDiscoverRspCmd != NULL )
   3938            {
   3939              pDiscoverRspCmd->discComplete = *pBuf++;
   3940              pDiscoverRspCmd->numAttr = numAttr;
   3941          
   3942              for ( uint8 i = 0; i < numAttr; i++ )
   3943              {
   3944                pDiscoverRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3945                pBuf += 2;
   3946                pDiscoverRspCmd->attrList[i].dataType = *pBuf++;
   3947              }
   3948            }
   3949          
   3950            return ( (void *)pDiscoverRspCmd );
   3951          }
   3952          
   3953          /*********************************************************************
   3954           * @fn      zclParseInDiscCmdsCmd
   3955           *
   3956           * @brief   Parse the "Profile" Discovery Commands
   3957           *
   3958           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3959           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3960           *
   3961           * @param   pCmd - pointer to incoming data to parse
   3962           *
   3963           * @return  pointer to the parsed command structure
   3964           */
   3965          void *zclParseInDiscCmdsCmd( zclParseCmd_t *pCmd )
   3966          {
   3967            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   3968            uint8 *pBuf = pCmd->pData;
   3969          
   3970            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmd_t ) );
   3971            if ( pDiscoverCmd != NULL )
   3972            {
   3973              pDiscoverCmd->startCmdID = *pBuf++;
   3974              pDiscoverCmd->maxCmdID = *pBuf++;
   3975            }
   3976          
   3977            return ( (void *)pDiscoverCmd );
   3978          }
   3979          
   3980          /*********************************************************************
   3981           * @fn      zclParseInDiscCmdsRspCmd
   3982           *
   3983           * @brief   Parse the Discover Commands Response Command
   3984           *
   3985           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3986           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3987           *
   3988           * @param   pCmd - pointer to incoming data to parse
   3989           *
   3990           * @return  pointer to the parsed command structure
   3991           */
   3992          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   3993          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd )
   3994          {
   3995            zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd;
   3996            uint8 *pBuf = pCmd->pData;
   3997            uint8 i;
   3998            uint8 numCmds = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen);  // determine length of command ID variable array
   3999          
   4000            // allocate memory for size of structure plus variable array
   4001            pDiscoverRspCmd = (zclDiscoverCmdsCmdRsp_t *)zcl_mem_alloc( 1 + numCmds );
   4002            if ( pDiscoverRspCmd != NULL )
   4003            {
   4004              pDiscoverRspCmd->discComplete = *pBuf++;
   4005              pDiscoverRspCmd->numCmd = numCmds;
   4006          
   4007              for ( i = 0; i < numCmds; i++ )
   4008              {
   4009                pDiscoverRspCmd->pCmdID[i] = *pBuf++;
   4010              }
   4011            }
   4012          
   4013            return ( (void *)pDiscoverRspCmd );
   4014          }
   4015          
   4016          /*********************************************************************
   4017           * @fn      zclParseInDiscAttrsExtRspCmd
   4018           *
   4019           * @brief   Parse the "Profile" Discovery Extended Attributes Response Commands
   4020           *
   4021           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4022           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4023           *
   4024           * @param   pCmd - pointer to incoming data to parse
   4025           *
   4026           * @return  pointer to the parsed command structure
   4027           */
   4028          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   4029          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd )
   4030          {
   4031            zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd;
   4032            uint8 i;
   4033            uint8 *pBuf = pCmd->pData;
   4034            uint8 numAttrs = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 + 1 ); // Attr ID + Data Type + Access Control
   4035          
   4036            pDiscoverRspCmd = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsExtRsp_t ) +
   4037                              ( numAttrs * sizeof(zclDiscoverAttrsExtRsp_t) ) );
   4038          
   4039            if ( pDiscoverRspCmd != NULL )
   4040            {
   4041              pDiscoverRspCmd->discComplete = *pBuf++;
   4042              pDiscoverRspCmd->numAttr = numAttrs;
   4043          
   4044              for ( i = 0; i < numAttrs; i++ )
   4045              {
   4046                pDiscoverRspCmd->aExtAttrInfo[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4047                pBuf += 2;
   4048                pDiscoverRspCmd->aExtAttrInfo[i].attrDataType = *pBuf++;
   4049                pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl = *pBuf++;
   4050              }
   4051            }
   4052          
   4053            return ( (void *)pDiscoverRspCmd );
   4054          }
   4055          #endif // ZCL_DISCOVER
   4056          
   4057          #ifdef ZCL_READ
   4058          /*********************************************************************
   4059           * @fn      zclProcessInReadCmd
   4060           *
   4061           * @brief   Process the "Profile" Read Command
   4062           *
   4063           * @param   pInMsg - incoming message to process
   4064           *
   4065           * @return  TRUE if command processed. FALSE, otherwise.
   4066           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4067          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInReadCmd:
   4068          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   4069            zclReadCmd_t *readCmd;
   4070            zclReadRspCmd_t *readRspCmd;
   4071            zclAttrRec_t attrRec;
   4072            uint16 len;
   4073            uint8 i;
   4074          
   4075            readCmd = (zclReadCmd_t *)pInMsg->attrCmd;
   \   00000E   EE           MOV     A,R6
   \   00000F   240C         ADD     A,#0xc
   \   000011   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_175:
   \   000014   F5..         MOV     ?V0 + 10,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 11,A
   4076          
   4077            // calculate the length of the response status record
   4078            len = sizeof( zclReadRspCmd_t ) + (readCmd->numAttr * sizeof( zclReadRspStatus_t ));
   4079          
   4080            readRspCmd = zcl_mem_alloc( len );
   \   00001A                ; Setup parameters for call to function osal_mem_alloc
   \   00001A   85..82       MOV     DPL,?V0 + 10
   \   00001D   F583         MOV     DPH,A
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   75F006       MOV     B,#0x6
   \   000023   12....       LCALL   ?Subroutine106 & 0xFFFF
   \                     ??CrossCallReturnLabel_147:
   \   000026   12....       LCALL   ??osal_mem_alloc?relay
   \   000029   8A..         MOV     ?V0 + 0,R2
   \   00002B   8B..         MOV     ?V0 + 1,R3
   4081            if ( readRspCmd == NULL )
   \   00002D   EA           MOV     A,R2
   \   00002E   45..         ORL     A,?V0 + 1
   \   000030   7005         JNZ     ??zclProcessInReadCmd_0
   4082            {
   4083              return FALSE; // EMBEDDED RETURN
   \   000032   7900         MOV     R1,#0x0
   \   000034   02....       LJMP    ??zclProcessInReadCmd_1 & 0xFFFF
   4084            }
   4085          
   4086            readRspCmd->numAttr = readCmd->numAttr;
   \                     ??zclProcessInReadCmd_0:
   \   000037   85..82       MOV     DPL,?V0 + 10
   \   00003A   85..83       MOV     DPH,?V0 + 11
   \   00003D   12....       LCALL   ??Subroutine128_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_232:
   \   000040   F0           MOVX    @DPTR,A
   4087            for ( i = 0; i < readCmd->numAttr; i++ )
   \   000041   75..00       MOV     ?V0 + 2,#0x0
   \   000044   800B         SJMP    ??zclProcessInReadCmd_2
   4088            {
   4089              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   4090          
   4091              statusRec->attrID = readCmd->attrID[i];
   4092          
   4093              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4094                                   readCmd->attrID[i], &attrRec ) )
   4095              {
   4096                if ( zcl_AccessCtrlRead( attrRec.attr.accessControl ) )
   4097                {
   4098                  statusRec->status = zclAuthorizeRead( pInMsg->msg->endPoint,
   4099                                                        &(pInMsg->msg->srcAddr), &attrRec );
   4100                  if ( statusRec->status == ZCL_STATUS_SUCCESS )
   4101                  {
   4102                    statusRec->data = attrRec.attr.dataPtr;
   4103                    statusRec->dataType = attrRec.attr.dataType;
   4104                  }
   4105                }
   4106                else
   4107                {
   4108                  statusRec->status = ZCL_STATUS_WRITE_ONLY;
   4109                }
   4110              }
   4111              else
   4112              {
   4113                statusRec->status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \                     ??zclProcessInReadCmd_3:
   \   000046   85..82       MOV     DPL,?V0 + 6
   \   000049   85..83       MOV     DPH,?V0 + 7
   \   00004C   7486         MOV     A,#-0x7a
   \                     ??zclProcessInReadCmd_4:
   \   00004E   F0           MOVX    @DPTR,A
   4114              }
   \                     ??zclProcessInReadCmd_5:
   \   00004F   05..         INC     ?V0 + 2
   \                     ??zclProcessInReadCmd_2:
   \   000051   85..82       MOV     DPL,?V0 + 10
   \   000054   85..83       MOV     DPH,?V0 + 11
   \   000057   12....       LCALL   ??Subroutine129_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_237:
   \   00005A   4003         JC      $+5
   \   00005C   02....       LJMP    ??zclProcessInReadCmd_6 & 0xFFFF
   \   00005F   85..82       MOV     DPL,?V0 + 2
   \   000062   A882         MOV     R0,DPL
   \   000064   E8           MOV     A,R0
   \   000065   75F006       MOV     B,#0x6
   \   000068   A4           MUL     AB
   \   000069   FA           MOV     R2,A
   \   00006A   ABF0         MOV     R3,B
   \   00006C   E5..         MOV     A,?V0 + 0
   \   00006E   2A           ADD     A,R2
   \   00006F   F582         MOV     DPL,A
   \   000071   E5..         MOV     A,?V0 + 1
   \   000073   3B           ADDC    A,R3
   \   000074   F583         MOV     DPH,A
   \   000076   A3           INC     DPTR
   \   000077   8582..       MOV     ?V0 + 4,DPL
   \   00007A   8583..       MOV     ?V0 + 5,DPH
   \   00007D   E8           MOV     A,R0
   \   00007E   C3           CLR     C
   \   00007F   33           RLC     A
   \   000080   F8           MOV     R0,A
   \   000081   E4           CLR     A
   \   000082   33           RLC     A
   \   000083   F9           MOV     R1,A
   \   000084   E5..         MOV     A,?V0 + 10
   \   000086   28           ADD     A,R0
   \   000087   F582         MOV     DPL,A
   \   000089   E5..         MOV     A,?V0 + 11
   \   00008B   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_106:
   \   00008E   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   000091   12....       LCALL   ??Subroutine130_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_247:
   \   000094   E5..         MOV     A,?V0 + 4
   \   000096   2402         ADD     A,#0x2
   \   000098   F5..         MOV     ?V0 + 6,A
   \   00009A   E5..         MOV     A,?V0 + 5
   \   00009C   3400         ADDC    A,#0x0
   \   00009E   F5..         MOV     ?V0 + 7,A
   \   0000A0   8E82         MOV     DPL,R6
   \   0000A2   8F83         MOV     DPH,R7
   \   0000A4   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   0000A7   8582..       MOV     ?V0 + 12,DPL
   \   0000AA   8583..       MOV     ?V0 + 13,DPH
   \   0000AD   78..         MOV     R0,#?V0 + 12
   \   0000AF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B2   8A82         MOV     DPL,R2
   \   0000B4   8B83         MOV     DPH,R3
   \   0000B6   12....       LCALL   ??Subroutine134_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_258:
   \   0000B9   12....       LCALL   ??zclFindAttrRec?relay
   \   0000BC   7402         MOV     A,#0x2
   \   0000BE   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C1   E9           MOV     A,R1
   \   0000C2   6082         JZ      ??zclProcessInReadCmd_3
   \   0000C4   7405         MOV     A,#0x5
   \   0000C6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C9   E0           MOVX    A,@DPTR
   \   0000CA   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000CC   5071         JNC     ??zclProcessInReadCmd_7
   \   0000CE   8E82         MOV     DPL,R6
   \   0000D0   8F83         MOV     DPH,R7
   \   0000D2   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   0000D5   2406         ADD     A,#0x6
   \   0000D7   F5..         MOV     ?V0 + 14,A
   \   0000D9   E9           MOV     A,R1
   \   0000DA   3400         ADDC    A,#0x0
   \   0000DC   F5..         MOV     ?V0 + 15,A
   \   0000DE   7405         MOV     A,#0x5
   \   0000E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E3   E0           MOVX    A,@DPTR
   \   0000E4   A2E4         MOV     C,0xE0 /* A   */.4
   \   0000E6   502B         JNC     ??zclProcessInReadCmd_8
   \   0000E8                ; Setup parameters for call to function zclGetAuthorizeCB
   \   0000E8   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_268:
   \   0000EB   12....       LCALL   ??zclGetAuthorizeCB?relay
   \   0000EE   8A..         MOV     ?V0 + 8,R2
   \   0000F0   8B..         MOV     ?V0 + 9,R3
   \   0000F2   EA           MOV     A,R2
   \   0000F3   45..         ORL     A,?V0 + 9
   \   0000F5   601C         JZ      ??zclProcessInReadCmd_8
   \   0000F7                ; Setup parameters for indirect call
   \   0000F7   7901         MOV     R1,#0x1
   \   0000F9   85..82       MOV     DPL,?XSP + 0
   \   0000FC   85..83       MOV     DPH,?XSP + 1
   \   0000FF   AC82         MOV     R4,DPL
   \   000101   AD83         MOV     R5,DPH
   \   000103   AA..         MOV     R2,?V0 + 14
   \   000105   AB..         MOV     R3,?V0 + 15
   \   000107   85..82       MOV     DPL,?V0 + 8
   \   00010A   85..83       MOV     DPH,?V0 + 9
   \   00010D   12....       LCALL   ?CALL_IND
   \   000110   E9           MOV     A,R1
   \   000111   8001         SJMP    ??zclProcessInReadCmd_9
   \                     ??zclProcessInReadCmd_8:
   \   000113   E4           CLR     A
   \                     ??zclProcessInReadCmd_9:
   \   000114   85..82       MOV     DPL,?V0 + 6
   \   000117   85..83       MOV     DPH,?V0 + 7
   \   00011A   F0           MOVX    @DPTR,A
   \   00011B   6003         JZ      $+5
   \   00011D   02....       LJMP    ??zclProcessInReadCmd_5 & 0xFFFF
   \   000120   7406         MOV     A,#0x6
   \   000122   12....       LCALL   ?XSTACK_DISP0_8
   \   000125   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000128   A3           INC     DPTR
   \   000129   A3           INC     DPTR
   \   00012A   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_251:
   \   00012D   7404         MOV     A,#0x4
   \   00012F   12....       LCALL   ?XSTACK_DISP0_8
   \   000132   E0           MOVX    A,@DPTR
   \   000133   85..82       MOV     DPL,?V0 + 4
   \   000136   85..83       MOV     DPH,?V0 + 5
   \   000139   A3           INC     DPTR
   \   00013A   A3           INC     DPTR
   \   00013B   A3           INC     DPTR
   \   00013C   02....       LJMP    ??zclProcessInReadCmd_4 & 0xFFFF
   \                     ??zclProcessInReadCmd_7:
   \   00013F   85..82       MOV     DPL,?V0 + 6
   \   000142   85..83       MOV     DPH,?V0 + 7
   \   000145   748F         MOV     A,#-0x71
   \   000147   02....       LJMP    ??zclProcessInReadCmd_4 & 0xFFFF
   4115            }
   4116          
   4117            // Build and send Read Response command
   4118            zcl_SendReadRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId,
   4119                             readRspCmd, !pInMsg->hdr.fc.direction,
   4120                             true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInReadCmd_6:
   \   00014A   8E82         MOV     DPL,R6
   \   00014C   8F83         MOV     DPH,R7
   \   00014E   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_317:
   \   000151                ; Setup parameters for call to function zcl_SendReadRsp
   \   000151   8E82         MOV     DPL,R6
   \   000153   8F83         MOV     DPH,R7
   \   000155   A3           INC     DPTR
   \   000156   A3           INC     DPTR
   \   000157   A3           INC     DPTR
   \   000158   A3           INC     DPTR
   \   000159   A3           INC     DPTR
   \   00015A   A3           INC     DPTR
   \   00015B   E0           MOVX    A,@DPTR
   \   00015C   F5..         MOV     ?V0 + 2,A
   \   00015E   78..         MOV     R0,#?V0 + 2
   \   000160   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000163   75..01       MOV     ?V0 + 2,#0x1
   \   000166   78..         MOV     R0,#?V0 + 2
   \   000168   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00016B   8E82         MOV     DPL,R6
   \   00016D   8F83         MOV     DPH,R7
   \   00016F   12....       LCALL   ??Subroutine133_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_253:
   \   000172   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000175   78..         MOV     R0,#?V0 + 0
   \   000177   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00017A   85..82       MOV     DPL,?V0 + 8
   \   00017D   85..83       MOV     DPH,?V0 + 9
   \   000180   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_330:
   \   000183   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   000186   12....       LCALL   ??Subroutine136_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_263:
   \   000189   12....       LCALL   ??zcl_SendReadRsp?relay
   \   00018C   7405         MOV     A,#0x5
   \   00018E   12....       LCALL   ?DEALLOC_XSTACK8
   4121            zcl_mem_free( readRspCmd );
   \   000191                ; Setup parameters for call to function osal_mem_free
   \   000191   AA..         MOV     R2,?V0 + 0
   \   000193   AB..         MOV     R3,?V0 + 1
   \   000195   12....       LCALL   ??osal_mem_free?relay
   4122          
   4123            return TRUE;
   \   000198   7901         MOV     R1,#0x1
   \                     ??zclProcessInReadCmd_1:
   \   00019A   7408         MOV     A,#0x8
   \   00019C   02....       LJMP    ?Subroutine4 & 0xFFFF
   4124          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine130_0
   \   000002                ; // Fall through to label ??Subroutine130_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine133_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_257:
   \   000005   F5..         MOV     ?V0 + 2,A
   \   000007   78..         MOV     R0,#?V0 + 2
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine134_0:
   \   000000   12....       LCALL   ??Subroutine145_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_334:
   \   000003   85..82       MOV     DPL,?V0 + 8
   \   000006   85..83       MOV     DPH,?V0 + 9
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_313:
   \   000010   E5..         MOV     A,?V0 + 8
   \   000012   12....       LCALL   ??Subroutine146_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_346:
   \   000015   E5..         MOV     A,?V0 + 9
   \   000017   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_273:
   \   00001A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine76:
   \   000000   E5..         MOV     A,?V0 + 8
   \   000002   2406         ADD     A,#0x6
   \   000004   FA           MOV     R2,A
   \   000005   E5..         MOV     A,?V0 + 9
   \   000007   3400         ADDC    A,#0x0
   \   000009   FB           MOV     R3,A
   \   00000A   E5..         MOV     A,?V0 + 8
   \   00000C   12....       LCALL   ??Subroutine146_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_342:
   \   00000F   E5..         MOV     A,?V0 + 9
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 8,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 9,A
   \   000007                ; Setup parameters for call to function zclFindAttrRec
   \   000007                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   000007   85..82       MOV     DPL,?XSP + 0
   \   00000A   85..83       MOV     DPH,?XSP + 1
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine106:
   \   000000   A4           MUL     AB
   \   000001   2401         ADD     A,#0x1
   \   000003   FA           MOV     R2,A
   \   000004   E5F0         MOV     A,B
   \   000006   3400         ADDC    A,#0x0
   \   000008   FB           MOV     R3,A
   \   000009   22           RET
   4125          #endif // ZCL_READ
   4126          
   4127          #ifdef ZCL_WRITE
   4128          /*********************************************************************
   4129           * @fn      processInWriteCmd
   4130           *
   4131           * @brief   Process the "Profile" Write and Write No Response Commands
   4132           *
   4133           * @param   pInMsg - incoming message to process
   4134           *
   4135           * @return  TRUE if command processed. FALSE, otherwise.
   4136           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4137          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteCmd:
   4138          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 4,R2
   \   00000C   8B..         MOV     ?V0 + 5,R3
   4139            zclWriteCmd_t *writeCmd;
   4140            zclWriteRspCmd_t *writeRspCmd;
   4141            uint8 sendRsp = FALSE;
   \   00000E   7F00         MOV     R7,#0x0
   4142            uint8 j = 0;
   \   000010   12....       LCALL   ?Subroutine68 & 0xFFFF
   4143            uint8 i;
   4144          
   4145            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \                     ??CrossCallReturnLabel_275:
   \   000013   85..82       MOV     DPL,?XSP + 0
   \   000016   85..83       MOV     DPH,?XSP + 1
   \   000019   12....       LCALL   ??Subroutine130_0 & 0xFFFF
   4146            if ( pInMsg->hdr.commandID == ZCL_CMD_WRITE )
   \                     ??CrossCallReturnLabel_248:
   \   00001C   8A82         MOV     DPL,R2
   \   00001E   8B83         MOV     DPH,R3
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   6402         XRL     A,#0x2
   \   00002A   701B         JNZ     ??zclProcessInWriteCmd_0
   4147            {
   4148              // We need to send a response back - allocate space for it
   4149              writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
   4150                      + sizeof( zclWriteRspStatus_t ) * writeCmd->numAttr );
   \   00002C                ; Setup parameters for call to function osal_mem_alloc
   \   00002C   85..82       MOV     DPL,?XSP + 0
   \   00002F   85..83       MOV     DPH,?XSP + 1
   \   000032   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000035   12....       LCALL   ??osal_mem_alloc?relay
   \   000038   8A..         MOV     ?V0 + 0,R2
   \   00003A   8B..         MOV     ?V0 + 1,R3
   4151              if ( writeRspCmd == NULL )
   \   00003C   EA           MOV     A,R2
   \   00003D   45..         ORL     A,?V0 + 1
   \   00003F   7005         JNZ     ??zclProcessInWriteCmd_1
   4152              {
   4153                return FALSE; // EMBEDDED RETURN
   \   000041   7900         MOV     R1,#0x0
   \   000043   02....       LJMP    ??zclProcessInWriteCmd_2 & 0xFFFF
   4154              }
   4155          
   4156              sendRsp = TRUE;
   \                     ??zclProcessInWriteCmd_1:
   \   000046   0F           INC     R7
   4157            }
   4158          
   4159            for ( i = 0; i < writeCmd->numAttr; i++ )
   \                     ??zclProcessInWriteCmd_0:
   \   000047   8E..         MOV     ?V0 + 6,R6
   \   000049   801C         SJMP    ??zclProcessInWriteCmd_3
   4160            {
   4161              zclAttrRec_t attrRec;
   4162              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4163          
   4164              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4165                                   statusRec->attrID, &attrRec ) )
   4166              {
   4167                if ( statusRec->dataType == attrRec.attr.dataType )
   4168                {
   4169                  uint8 status;
   4170          
   4171                  // Write the new attribute value
   4172                  if ( attrRec.attr.dataPtr != NULL )
   4173                  {
   4174                    status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4175                                               &attrRec, statusRec );
   4176                  }
   4177                  else // Use CB
   4178                  {
   4179                    status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4180                                                      &attrRec, statusRec->attrData );
   4181                  }
   4182          
   4183                  // If successful, a write attribute status record shall NOT be generated
   4184                  if ( sendRsp && status != ZCL_STATUS_SUCCESS )
   4185                  {
   4186                    // Attribute is read only - move on to the next write attribute record
   4187                    writeRspCmd->attrList[j].status = status;
   4188                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4189                  }
   4190                }
   4191                else
   4192                {
   4193                  // Attribute data type is incorrect - move on to the next write attribute record
   4194                  if ( sendRsp )
   4195                  {
   4196                    writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   4197                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4198                  }
   4199                }
   4200              }
   4201              else
   4202              {
   4203                // Attribute is not supported - move on to the next write attribute record
   4204                if ( sendRsp )
   \                     ??zclProcessInWriteCmd_4:
   \   00004B   EF           MOV     A,R7
   \   00004C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00004E   5015         JNC     ??zclProcessInWriteCmd_5
   4205                {
   4206                  writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \   000050   85..82       MOV     DPL,?V0 + 14
   \   000053   85..83       MOV     DPH,?V0 + 15
   \   000056   7486         MOV     A,#-0x7a
   4207                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4208                }
   4209              }
   \                     ??zclProcessInWriteCmd_6:
   \   000058   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   00005B   85..82       MOV     DPL,?V0 + 12
   \   00005E   85..83       MOV     DPH,?V0 + 13
   \   000061   12....       LCALL   ??Subroutine130_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_249:
   \   000064   0E           INC     R6
   \                     ??zclProcessInWriteCmd_5:
   \   000065   05..         INC     ?V0 + 6
   \                     ??zclProcessInWriteCmd_3:
   \   000067   85..82       MOV     DPL,?XSP + 0
   \   00006A   85..83       MOV     DPH,?XSP + 1
   \   00006D   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   000070   E5..         MOV     A,?V0 + 6
   \   000072   C3           CLR     C
   \   000073   98           SUBB    A,R0
   \   000074   4003         JC      $+5
   \   000076   02....       LJMP    ??zclProcessInWriteCmd_7 & 0xFFFF
   \   000079   E5..         MOV     A,?V0 + 6
   \   00007B   75F005       MOV     B,#0x5
   \   00007E   A4           MUL     AB
   \   00007F   F8           MOV     R0,A
   \   000080   A9F0         MOV     R1,B
   \   000082   85..82       MOV     DPL,?XSP + 0
   \   000085   85..83       MOV     DPH,?XSP + 1
   \   000088   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   00008B   EE           MOV     A,R6
   \   00008C   75F003       MOV     B,#0x3
   \   00008F   A4           MUL     AB
   \   000090   F8           MOV     R0,A
   \   000091   A9F0         MOV     R1,B
   \   000093   E5..         MOV     A,?V0 + 0
   \   000095   28           ADD     A,R0
   \   000096   F582         MOV     DPL,A
   \   000098   E5..         MOV     A,?V0 + 1
   \   00009A   39           ADDC    A,R1
   \   00009B   F583         MOV     DPH,A
   \   00009D   E582         MOV     A,DPL
   \   00009F   2402         ADD     A,#0x2
   \   0000A1   F5..         MOV     ?V0 + 12,A
   \   0000A3   E583         MOV     A,DPH
   \   0000A5   3400         ADDC    A,#0x0
   \   0000A7   F5..         MOV     ?V0 + 13,A
   \   0000A9   A3           INC     DPTR
   \   0000AA   8582..       MOV     ?V0 + 14,DPL
   \   0000AD   8583..       MOV     ?V0 + 15,DPH
   \   0000B0   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_319:
   \   0000B3                ; Setup parameters for call to function zclFindAttrRec
   \   0000B3   7402         MOV     A,#0x2
   \   0000B5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B8   8582..       MOV     ?V0 + 10,DPL
   \   0000BB   8583..       MOV     ?V0 + 11,DPH
   \   0000BE   78..         MOV     R0,#?V0 + 10
   \   0000C0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C3   85..82       MOV     DPL,?V0 + 2
   \   0000C6   85..83       MOV     DPH,?V0 + 3
   \   0000C9   12....       LCALL   ??Subroutine134_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_259:
   \   0000CC   12....       LCALL   ??zclFindAttrRec?relay
   \   0000CF   7402         MOV     A,#0x2
   \   0000D1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D4   E9           MOV     A,R1
   \   0000D5   7003         JNZ     $+5
   \   0000D7   02....       LJMP    ??zclProcessInWriteCmd_4 & 0xFFFF
   \   0000DA   85..82       MOV     DPL,?V0 + 2
   \   0000DD   85..83       MOV     DPH,?V0 + 3
   \   0000E0   A3           INC     DPTR
   \   0000E1   A3           INC     DPTR
   \   0000E2   E0           MOVX    A,@DPTR
   \   0000E3   F8           MOV     R0,A
   \   0000E4   7406         MOV     A,#0x6
   \   0000E6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E9   E0           MOVX    A,@DPTR
   \   0000EA   68           XRL     A,R0
   \   0000EB   707D         JNZ     ??zclProcessInWriteCmd_8
   \   0000ED   85..82       MOV     DPL,?V0 + 4
   \   0000F0   85..83       MOV     DPH,?V0 + 5
   \   0000F3   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   0000F6   2414         ADD     A,#0x14
   \   0000F8   F5..         MOV     ?V0 + 8,A
   \   0000FA   E9           MOV     A,R1
   \   0000FB   3400         ADDC    A,#0x0
   \   0000FD   F5..         MOV     ?V0 + 9,A
   \   0000FF   E8           MOV     A,R0
   \   000100   2406         ADD     A,#0x6
   \   000102   FA           MOV     R2,A
   \   000103   E9           MOV     A,R1
   \   000104   3400         ADDC    A,#0x0
   \   000106   FB           MOV     R3,A
   \   000107   7408         MOV     A,#0x8
   \   000109   12....       LCALL   ?XSTACK_DISP0_8
   \   00010C   12....       LCALL   ??Subroutine124_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_203:
   \   00010F   601B         JZ      ??zclProcessInWriteCmd_9
   \   000111                ; Setup parameters for call to function zclWriteAttrData
   \   000111   78..         MOV     R0,#?V0 + 2
   \   000113   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000116   7404         MOV     A,#0x4
   \   000118   12....       LCALL   ?XSTACK_DISP0_8
   \   00011B   AC82         MOV     R4,DPL
   \   00011D   AD83         MOV     R5,DPH
   \   00011F   85..82       MOV     DPL,?V0 + 8
   \   000122   85..83       MOV     DPH,?V0 + 9
   \   000125   E0           MOVX    A,@DPTR
   \   000126   F9           MOV     R1,A
   \   000127   12....       LCALL   ??zclWriteAttrData?relay
   \   00012A   8020         SJMP    ??zclProcessInWriteCmd_10
   \                     ??zclProcessInWriteCmd_9:
   \   00012C                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   00012C   85..82       MOV     DPL,?V0 + 2
   \   00012F   85..83       MOV     DPH,?V0 + 3
   \   000132   A3           INC     DPTR
   \   000133   A3           INC     DPTR
   \   000134   A3           INC     DPTR
   \   000135   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000138   7404         MOV     A,#0x4
   \   00013A   12....       LCALL   ?XSTACK_DISP0_8
   \   00013D   AC82         MOV     R4,DPL
   \   00013F   AD83         MOV     R5,DPH
   \   000141   85..82       MOV     DPL,?V0 + 8
   \   000144   85..83       MOV     DPH,?V0 + 9
   \   000147   E0           MOVX    A,@DPTR
   \   000148   F9           MOV     R1,A
   \   000149   12....       LCALL   ??zclWriteAttrDataUsingCB?relay
   \                     ??zclProcessInWriteCmd_10:
   \   00014C   7402         MOV     A,#0x2
   \   00014E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000151   E9           MOV     A,R1
   \   000152   F8           MOV     R0,A
   \   000153   EF           MOV     A,R7
   \   000154   A2E0         MOV     C,0xE0 /* A   */.0
   \   000156   4003         JC      $+5
   \   000158   02....       LJMP    ??zclProcessInWriteCmd_5 & 0xFFFF
   \   00015B   E8           MOV     A,R0
   \   00015C   7003         JNZ     $+5
   \   00015E   02....       LJMP    ??zclProcessInWriteCmd_5 & 0xFFFF
   \   000161   85..82       MOV     DPL,?V0 + 14
   \   000164   85..83       MOV     DPH,?V0 + 15
   \   000167   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   \                     ??zclProcessInWriteCmd_8:
   \   00016A   EF           MOV     A,R7
   \   00016B   A2E0         MOV     C,0xE0 /* A   */.0
   \   00016D   4003         JC      $+5
   \   00016F   02....       LJMP    ??zclProcessInWriteCmd_5 & 0xFFFF
   \   000172   85..82       MOV     DPL,?V0 + 14
   \   000175   85..83       MOV     DPH,?V0 + 15
   \   000178   748D         MOV     A,#-0x73
   \   00017A   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   4210            } // for loop
   4211          
   4212            if ( sendRsp )
   \                     ??zclProcessInWriteCmd_7:
   \   00017D   EF           MOV     A,R7
   \   00017E   A2E0         MOV     C,0xE0 /* A   */.0
   \   000180   5038         JNC     ??zclProcessInWriteCmd_11
   4213            {
   4214              writeRspCmd->numAttr = j;
   \   000182   EE           MOV     A,R6
   \   000183   85..82       MOV     DPL,?V0 + 0
   \   000186   85..83       MOV     DPH,?V0 + 1
   \   000189   F0           MOVX    @DPTR,A
   4215              if ( writeRspCmd->numAttr == 0 )
   \   00018A   7003         JNZ     ??CrossCallReturnLabel_29
   4216              {
   4217                // Since all records were written successful, include a single status record
   4218                // in the resonse command with the status field set to SUCCESS and the
   4219                // attribute ID field omitted.
   4220                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   00018C   12....       LCALL   ?Subroutine29 & 0xFFFF
   4221                writeRspCmd->numAttr = 1;
   4222              }
   4223          
   4224              zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4225                                pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction,
   4226                                true, pInMsg->hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_29:
   \   00018F   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   000192   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000195   75..01       MOV     ?V0 + 2,#0x1
   \   000198   78..         MOV     R0,#?V0 + 2
   \   00019A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00019D   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_254:
   \   0001A0   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001A3   78..         MOV     R0,#?V0 + 0
   \   0001A5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001A8   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   0001AB   12....       LCALL   ??zcl_SendWriteRsp?relay
   \   0001AE   7405         MOV     A,#0x5
   \   0001B0   12....       LCALL   ?DEALLOC_XSTACK8
   4227              zcl_mem_free( writeRspCmd );
   \   0001B3                ; Setup parameters for call to function osal_mem_free
   \   0001B3   AA..         MOV     R2,?V0 + 0
   \   0001B5   AB..         MOV     R3,?V0 + 1
   \   0001B7   12....       LCALL   ??osal_mem_free?relay
   4228            }
   4229          
   4230            return TRUE;
   \                     ??zclProcessInWriteCmd_11:
   \   0001BA   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteCmd_2:
   \   0001BC   740A         MOV     A,#0xa
   \   0001BE                REQUIRE ?Subroutine4
   \   0001BE                ; // Fall through to label ?Subroutine4
   4231          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   85..82       MOV     DPL,?V0 + 4
   \   000003   85..83       MOV     DPH,?V0 + 5
   \   000006                REQUIRE ??Subroutine133_0
   \   000006                ; // Fall through to label ??Subroutine133_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   7E00         MOV     R6,#0x0
   \   000002   EA           MOV     A,R2
   \   000003   240C         ADD     A,#0xc
   \   000005   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_192:
   \   000008                REQUIRE ??Subroutine137_0
   \   000008                ; // Fall through to label ??Subroutine137_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   85..82       MOV     DPL,?V0 + 4
   \   000003   85..83       MOV     DPH,?V0 + 5
   \   000006                REQUIRE ??Subroutine141_0
   \   000006                ; // Fall through to label ??Subroutine141_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine95:
   \   000000   12....       LCALL   ?Subroutine109 & 0xFFFF
   \                     ??CrossCallReturnLabel_151:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F8           MOV     R0,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_133:
   \   000003   8582..       MOV     ?V0 + 2,DPL
   \   000006   8583..       MOV     ?V0 + 3,DPH
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine94:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   28           ADD     A,R0
   \   000002   FA           MOV     R2,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   39           ADDC    A,R1
   \   000006   8A82         MOV     DPL,R2
   \   000008   F583         MOV     DPH,A
   \   00000A   A3           INC     DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_137:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   75F003       MOV     B,#0x3
   \   000007   12....       LCALL   ?Subroutine106 & 0xFFFF
   \                     ??CrossCallReturnLabel_148:
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   85..82       MOV     DPL,?V0 + 4
   \   000003   85..83       MOV     DPH,?V0 + 5
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FE           MOV     R6,A
   \   000008   A3           INC     DPTR
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   FF           MOV     R7,A
   \   00000B                ; Setup parameters for call to function zcl_SendWriteRsp
   \   00000B                ; Setup parameters for call to function zcl_SendWriteRsp
   \   00000B   85..82       MOV     DPL,?V0 + 4
   \   00000E   85..83       MOV     DPH,?V0 + 5
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 2,A
   \   00001A   78..         MOV     R0,#?V0 + 2
   \   00001C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_332:
   \   000007   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_146:
   \   00000A   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_271:
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine104:
   \   000000   EE           MOV     A,R6
   \   000001   2406         ADD     A,#0x6
   \   000003   FA           MOV     R2,A
   \   000004   EF           MOV     A,R7
   \   000005   3400         ADDC    A,#0x0
   \   000007   FB           MOV     R3,A
   \   000008   EE           MOV     A,R6
   \   000009   12....       LCALL   ??Subroutine146_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_343:
   \   00000C   EF           MOV     A,R7
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   A3           INC     DPTR
   \   000001   E4           CLR     A
   \   000002   F0           MOVX    @DPTR,A
   \   000003   85..82       MOV     DPL,?V0 + 0
   \   000006   85..83       MOV     DPH,?V0 + 1
   \   000009   04           INC     A
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V0 + 2
   \   000004   85..83       MOV     DPH,?V0 + 3
   \   000007   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_286:
   \   00000A   22           RET
   4232          
   4233          /*********************************************************************
   4234           * @fn      zclRevertWriteUndividedCmd
   4235           *
   4236           * @brief   Revert the "Profile" Write Undevided Command
   4237           *
   4238           * @param   pInMsg - incoming message to process
   4239           * @param   curWriteRec - old data
   4240           * @param   numAttr - number of attributes to be reverted
   4241           *
   4242           * @return  none
   4243           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4244          static void zclRevertWriteUndividedCmd( zclIncoming_t *pInMsg,
   \                     zclRevertWriteUndividedCmd:
   4245                                              zclWriteRec_t *curWriteRec, uint16 numAttr )
   4246          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   8C..         MOV     ?V0 + 10,R4
   \   000010   8D..         MOV     ?V0 + 11,R5
   4247            uint8 i;
   4248          
   4249            for ( i = 0; i < numAttr; i++ )
   \   000012   75..00       MOV     ?V0 + 0,#0x0
   \   000015   741C         MOV     A,#0x1c
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_318:
   \   00001D   802B         SJMP    ??zclRevertWriteUndividedCmd_0
   4250            {
   4251              zclAttrRec_t attrRec;
   4252              zclWriteRec_t *statusRec = &(curWriteRec[i]);
   4253          
   4254              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4255                                    statusRec->attrID, &attrRec ) )
   4256              {
   4257                break; // should never happen
   4258              }
   4259          
   4260              if ( attrRec.attr.dataPtr != NULL )
   4261              {
   4262                // Just copy the old data back - no need to validate the data
   4263                uint16 dataLen = zclGetAttrDataLength( attrRec.attr.dataType, statusRec->attrData );
   4264                zcl_memcpy( attrRec.attr.dataPtr, statusRec->attrData, dataLen );
   4265              }
   4266              else // Use CB
   4267              {
   4268                // Write the old data back
   4269                zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4270                                         &attrRec, statusRec->attrData );
   \                     ??zclRevertWriteUndividedCmd_1:
   \   00001F   85..82       MOV     DPL,?V0 + 2
   \   000022   85..83       MOV     DPH,?V0 + 3
   \   000025   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   4271              }
   \                     ??CrossCallReturnLabel_223:
   \   000028                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   000028   8A..         MOV     ?V0 + 4,R2
   \   00002A   8B..         MOV     ?V0 + 5,R3
   \   00002C   78..         MOV     R0,#?V0 + 4
   \   00002E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000031   7402         MOV     A,#0x2
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   AC82         MOV     R4,DPL
   \   000038   AD83         MOV     R5,DPH
   \   00003A   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_145:
   \   00003D   12....       LCALL   ??Subroutine136_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_264:
   \   000040   12....       LCALL   ??zclWriteAttrDataUsingCB?relay
   \   000043   7402         MOV     A,#0x2
   \   000045   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??zclRevertWriteUndividedCmd_2:
   \   000048   05..         INC     ?V0 + 0
   \                     ??zclRevertWriteUndividedCmd_0:
   \   00004A   85....       MOV     ?V0 + 4,?V0 + 0
   \   00004D   C3           CLR     C
   \   00004E   E5..         MOV     A,?V0 + 4
   \   000050   95..         SUBB    A,?V0 + 8
   \   000052   E4           CLR     A
   \   000053   95..         SUBB    A,?V0 + 9
   \   000055   4003         JC      $+5
   \   000057   02....       LJMP    ??zclRevertWriteUndividedCmd_3 & 0xFFFF
   \   00005A   E5..         MOV     A,?V0 + 0
   \   00005C   75F005       MOV     B,#0x5
   \   00005F   A4           MUL     AB
   \   000060   F8           MOV     R0,A
   \   000061   A9F0         MOV     R1,B
   \   000063   E5..         MOV     A,?V0 + 10
   \   000065   28           ADD     A,R0
   \   000066   FE           MOV     R6,A
   \   000067   E5..         MOV     A,?V0 + 11
   \   000069   39           ADDC    A,R1
   \   00006A   FF           MOV     R7,A
   \   00006B   85..82       MOV     DPL,?V0 + 2
   \   00006E   85..83       MOV     DPH,?V0 + 3
   \   000071   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_280:
   \   000074   88..         MOV     ?V0 + 4,R0
   \   000076                ; Setup parameters for call to function zclFindAttrRec
   \   000076   85..82       MOV     DPL,?XSP + 0
   \   000079   85..83       MOV     DPH,?XSP + 1
   \   00007C   8582..       MOV     ?V0 + 6,DPL
   \   00007F   8583..       MOV     ?V0 + 7,DPH
   \   000082   78..         MOV     R0,#?V0 + 6
   \   000084   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000087   8E82         MOV     DPL,R6
   \   000089   8F83         MOV     DPH,R7
   \   00008B   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_324:
   \   00008E   85..82       MOV     DPL,?V0 + 4
   \   000091   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_307:
   \   000094   E5..         MOV     A,?V0 + 4
   \   000096   12....       LCALL   ??Subroutine135_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_266:
   \   000099   12....       LCALL   ??zclFindAttrRec?relay
   \   00009C   7402         MOV     A,#0x2
   \   00009E   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A1   E9           MOV     A,R1
   \   0000A2   604E         JZ      ??zclRevertWriteUndividedCmd_3
   \   0000A4   EE           MOV     A,R6
   \   0000A5   2403         ADD     A,#0x3
   \   0000A7   F5..         MOV     ?V0 + 4,A
   \   0000A9   EF           MOV     A,R7
   \   0000AA   3400         ADDC    A,#0x0
   \   0000AC   F5..         MOV     ?V0 + 5,A
   \   0000AE   85..82       MOV     DPL,?V0 + 4
   \   0000B1   F583         MOV     DPH,A
   \   0000B3   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_301:
   \   0000B6   7406         MOV     A,#0x6
   \   0000B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BB   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_224:
   \   0000BE   EE           MOV     A,R6
   \   0000BF   4F           ORL     A,R7
   \   0000C0   7003         JNZ     $+5
   \   0000C2   02....       LJMP    ??zclRevertWriteUndividedCmd_1 & 0xFFFF
   \   0000C5                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000C5   7404         MOV     A,#0x4
   \   0000C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CA   E0           MOVX    A,@DPTR
   \   0000CB   F9           MOV     R1,A
   \   0000CC   12....       LCALL   ??zclGetAttrDataLength?relay
   \   0000CF   8A..         MOV     ?V0 + 6,R2
   \   0000D1   8B..         MOV     ?V0 + 7,R3
   \   0000D3   AC..         MOV     R4,?V0 + 6
   \   0000D5   AD..         MOV     R5,?V0 + 7
   \   0000D7                ; Setup parameters for call to function osal_memcpy
   \   0000D7   85..82       MOV     DPL,?V0 + 4
   \   0000DA   85..83       MOV     DPH,?V0 + 5
   \   0000DD   12....       LCALL   ?Subroutine54 & 0xFFFF
   4272            } // for loop
   \                     ??CrossCallReturnLabel_64:
   \   0000E0   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000E3   EE           MOV     A,R6
   \   0000E4   FA           MOV     R2,A
   \   0000E5   EF           MOV     A,R7
   \   0000E6   FB           MOV     R3,A
   \   0000E7   12....       LCALL   ??osal_memcpy?relay
   \   0000EA   7403         MOV     A,#0x3
   \   0000EC   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000EF   02....       LJMP    ??zclRevertWriteUndividedCmd_2 & 0xFFFF
   4273          }
   \                     ??zclRevertWriteUndividedCmd_3:
   \   0000F2   7408         MOV     A,#0x8
   \   0000F4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F7   7F0C         MOV     R7,#0xc
   \   0000F9   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine135_0:
   \   000000   12....       LCALL   ??Subroutine146_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_347:
   \   000003   E9           MOV     A,R1
   \   000004                REQUIRE ??Subroutine136_0
   \   000004                ; // Fall through to label ??Subroutine136_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   8983         MOV     DPH,R1
   \   000002                REQUIRE ??Subroutine138_0
   \   000002                ; // Fall through to label ??Subroutine138_0
   4274          
   4275          /*********************************************************************
   4276           * @fn      zclProcessInWriteUndividedCmd
   4277           *
   4278           * @brief   Process the "Profile" Write Undivided Command
   4279           *
   4280           * @param   pInMsg - incoming message to process
   4281           *
   4282           * @return  TRUE if command processed. FALSE, otherwise.
   4283           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   85..82       MOV     DPL,?V0 + 6
   \   000003   85..83       MOV     DPH,?V0 + 7
   \   000006                REQUIRE ??Subroutine134_0
   \   000006                ; // Fall through to label ??Subroutine134_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   E8           MOV     A,R0
   \   000001                REQUIRE ??Subroutine135_0
   \   000001                ; // Fall through to label ??Subroutine135_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4284          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteUndividedCmd:
   4285          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV     A,#-0xc
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 4,R2
   \   00000C   8B..         MOV     ?V0 + 5,R3
   4286            zclWriteCmd_t *writeCmd;
   4287            zclWriteRspCmd_t *writeRspCmd;
   4288            zclAttrRec_t attrRec;
   4289            uint16 dataLen;
   4290            uint16 curLen = 0;
   \   00000E   75..00       MOV     ?V0 + 6,#0x0
   \   000011   75..00       MOV     ?V0 + 7,#0x0
   4291            uint8 j = 0;
   \   000014   12....       LCALL   ?Subroutine68 & 0xFFFF
   4292            uint8 i;
   4293          
   4294            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \                     ??CrossCallReturnLabel_276:
   \   000017   7402         MOV     A,#0x2
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   12....       LCALL   ??Subroutine130_0 & 0xFFFF
   4295          
   4296            // Allocate space for Write Response Command
   4297            writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
   4298                             + sizeof( zclWriteRspStatus_t )* writeCmd->numAttr );
   \                     ??CrossCallReturnLabel_250:
   \   00001F                ; Setup parameters for call to function osal_mem_alloc
   \   00001F   7402         MOV     A,#0x2
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000027   12....       LCALL   ??osal_mem_alloc?relay
   \   00002A   8A..         MOV     ?V0 + 0,R2
   \   00002C   8B..         MOV     ?V0 + 1,R3
   4299            if ( writeRspCmd == NULL )
   \   00002E   EA           MOV     A,R2
   \   00002F   45..         ORL     A,?V0 + 1
   \   000031   7003         JNZ     $+5
   \   000033   02....       LJMP    ??zclProcessInWriteUndividedCmd_0 & 0xFFFF
   4300            {
   4301              return FALSE; // EMBEDDED RETURN
   4302            }
   4303          
   4304            // If any attribute cannot be written, no attribute values are changed. Hence,
   4305            // make sure all the attributes are supported and writable
   4306            for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000036   7F00         MOV     R7,#0x0
   \   000038   8048         SJMP    ??zclProcessInWriteUndividedCmd_1
   4307            {
   4308              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4309          
   4310              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4311                                    statusRec->attrID, &attrRec ) )
   4312              {
   4313                // Attribute is not supported - stop here
   4314                writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   4315                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4316                break;
   4317              }
   4318          
   4319              if ( statusRec->dataType != attrRec.attr.dataType )
   4320              {
   4321                // Attribute data type is incorrect - stope here
   4322                writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   4323                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4324                break;
   4325              }
   4326          
   4327              if ( !zcl_AccessCtrlWrite( attrRec.attr.accessControl ) )
   4328              {
   4329                // Attribute is not writable - stop here
   4330                writeRspCmd->attrList[j].status = ZCL_STATUS_READ_ONLY;
   4331                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4332                break;
   4333              }
   4334          
   4335              if ( zcl_AccessCtrlAuthWrite( attrRec.attr.accessControl ) )
   4336              {
   4337                // Not authorized to write - stop here
   4338                writeRspCmd->attrList[j].status = ZCL_STATUS_NOT_AUTHORIZED;
   4339                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4340                break;
   4341              }
   4342          
   4343              // Attribute Data length
   4344              if ( attrRec.attr.dataPtr != NULL )
   4345              {
   4346                dataLen = zclGetAttrDataLength( attrRec.attr.dataType, attrRec.attr.dataPtr );
   4347              }
   4348              else // Use CB
   4349              {
   4350                dataLen = zclGetAttrDataLengthUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4351                                                       statusRec->attrID );
   \                     ??zclProcessInWriteUndividedCmd_2:
   \   00003A   85..82       MOV     DPL,?V0 + 4
   \   00003D   85..83       MOV     DPH,?V0 + 5
   \   000040   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   4352              }
   \                     ??CrossCallReturnLabel_281:
   \   000043                ; Setup parameters for call to function zclGetAttrDataLengthUsingCB
   \   000043   85..82       MOV     DPL,?V0 + 2
   \   000046   85..83       MOV     DPH,?V0 + 3
   \   000049   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_325:
   \   00004C   8882         MOV     DPL,R0
   \   00004E   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_308:
   \   000051   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_269:
   \   000054   12....       LCALL   ??zclGetAttrDataLengthUsingCB?relay
   \                     ??zclProcessInWriteUndividedCmd_3:
   \   000057   85..82       MOV     DPL,?XSP + 0
   \   00005A   85..83       MOV     DPH,?XSP + 1
   \   00005D   EA           MOV     A,R2
   \   00005E   F0           MOVX    @DPTR,A
   \   00005F   A3           INC     DPTR
   \   000060   EB           MOV     A,R3
   \   000061   F0           MOVX    @DPTR,A
   4353          
   4354              // add padding if needed
   4355              if ( PADDING_NEEDED( dataLen ) )
   \   000062   85..82       MOV     DPL,?XSP + 0
   \   000065   85..83       MOV     DPH,?XSP + 1
   \   000068   E0           MOVX    A,@DPTR
   \   000069   A2E0         MOV     C,0xE0 /* A   */.0
   \   00006B   5003         JNC     ??CrossCallReturnLabel_115
   4356              {
   4357                dataLen++;
   \   00006D   12....       LCALL   ?Subroutine83 & 0xFFFF
   4358              }
   4359          
   4360              curLen += dataLen;
   \                     ??CrossCallReturnLabel_115:
   \   000070   85..82       MOV     DPL,?XSP + 0
   \   000073   85..83       MOV     DPH,?XSP + 1
   \   000076   E0           MOVX    A,@DPTR
   \   000077   25..         ADD     A,?V0 + 6
   \   000079   F5..         MOV     ?V0 + 6,A
   \   00007B   A3           INC     DPTR
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   35..         ADDC    A,?V0 + 7
   \   00007F   F5..         MOV     ?V0 + 7,A
   \   000081   0F           INC     R7
   \                     ??zclProcessInWriteUndividedCmd_1:
   \   000082   7402         MOV     A,#0x2
   \   000084   12....       LCALL   ?XSTACK_DISP0_8
   \   000087   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   00008A   5060         JNC     ??zclProcessInWriteUndividedCmd_4
   \   00008C   EF           MOV     A,R7
   \   00008D   75F005       MOV     B,#0x5
   \   000090   A4           MUL     AB
   \   000091   F8           MOV     R0,A
   \   000092   A9F0         MOV     R1,B
   \   000094   7402         MOV     A,#0x2
   \   000096   12....       LCALL   ?XSTACK_DISP0_8
   \   000099   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   00009C   85..82       MOV     DPL,?V0 + 4
   \   00009F   85..83       MOV     DPH,?V0 + 5
   \   0000A2   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_282:
   \   0000A5   88..         MOV     ?V0 + 8,R0
   \   0000A7                ; Setup parameters for call to function zclFindAttrRec
   \   0000A7   7404         MOV     A,#0x4
   \   0000A9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AC   8582..       MOV     ?V0 + 10,DPL
   \   0000AF   8583..       MOV     ?V0 + 11,DPH
   \   0000B2   78..         MOV     R0,#?V0 + 10
   \   0000B4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B7   85..82       MOV     DPL,?V0 + 2
   \   0000BA   85..83       MOV     DPH,?V0 + 3
   \   0000BD   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_326:
   \   0000C0   85..82       MOV     DPL,?V0 + 8
   \   0000C3   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_309:
   \   0000C6   E5..         MOV     A,?V0 + 8
   \   0000C8   12....       LCALL   ??Subroutine135_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_267:
   \   0000CB   12....       LCALL   ??zclFindAttrRec?relay
   \   0000CE   7402         MOV     A,#0x2
   \   0000D0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D3   E9           MOV     A,R1
   \   0000D4   7047         JNZ     ??zclProcessInWriteUndividedCmd_5
   \   0000D6   85..82       MOV     DPL,?V0 + 0
   \   0000D9   85..83       MOV     DPH,?V0 + 1
   \   0000DC   A3           INC     DPTR
   \   0000DD   7486         MOV     A,#-0x7a
   \                     ??zclProcessInWriteUndividedCmd_6:
   \   0000DF   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   0000E2   85..82       MOV     DPL,?V0 + 0
   \   0000E5   85..83       MOV     DPH,?V0 + 1
   \   0000E8   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_252:
   \   0000EB   0E           INC     R6
   4361            } // for loop
   4362          
   4363            writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_4:
   \   0000EC   EE           MOV     A,R6
   \   0000ED   85..82       MOV     DPL,?V0 + 0
   \   0000F0   85..83       MOV     DPH,?V0 + 1
   \   0000F3   F0           MOVX    @DPTR,A
   4364            if ( writeRspCmd->numAttr == 0 ) // All attributes can be written
   \   0000F4   6003         JZ      $+5
   \   0000F6   02....       LJMP    ??zclProcessInWriteUndividedCmd_7 & 0xFFFF
   4365            {
   4366              uint8 *curDataPtr;
   4367              zclWriteRec_t *curWriteRec;
   4368          
   4369              // calculate the length of the current data header
   4370              uint8 hdrLen = j * sizeof( zclWriteRec_t );
   \   0000F9   75F005       MOV     B,#0x5
   \   0000FC   A4           MUL     AB
   \   0000FD   FF           MOV     R7,A
   4371          
   4372              // Allocate space to keep a copy of the current data
   4373              curWriteRec = (zclWriteRec_t *) zcl_mem_alloc( hdrLen + curLen );
   \   0000FE                ; Setup parameters for call to function osal_mem_alloc
   \   0000FE   25..         ADD     A,?V0 + 6
   \   000100   FA           MOV     R2,A
   \   000101   E4           CLR     A
   \   000102   35..         ADDC    A,?V0 + 7
   \   000104   FB           MOV     R3,A
   \   000105   12....       LCALL   ??osal_mem_alloc?relay
   \   000108   8A..         MOV     ?V0 + 14,R2
   \   00010A   8B..         MOV     ?V0 + 15,R3
   4374              if ( curWriteRec == NULL )
   \   00010C   EA           MOV     A,R2
   \   00010D   45..         ORL     A,?V0 + 15
   \   00010F   7061         JNZ     ??zclProcessInWriteUndividedCmd_8
   4375              {
   4376                zcl_mem_free(writeRspCmd );
   \   000111                ; Setup parameters for call to function osal_mem_free
   \   000111   AA..         MOV     R2,?V0 + 0
   \   000113   AB..         MOV     R3,?V0 + 1
   \   000115   12....       LCALL   ??osal_mem_free?relay
   4377                return FALSE; // EMBEDDED RETURN
   \                     ??zclProcessInWriteUndividedCmd_0:
   \   000118   7900         MOV     R1,#0x0
   \   00011A   02....       LJMP    ??zclProcessInWriteUndividedCmd_9 & 0xFFFF
   4378              }
   \                     ??zclProcessInWriteUndividedCmd_5:
   \   00011D   7408         MOV     A,#0x8
   \   00011F   12....       LCALL   ?XSTACK_DISP0_8
   \   000122   E0           MOVX    A,@DPTR
   \   000123   F9           MOV     R1,A
   \   000124   85..82       MOV     DPL,?V0 + 2
   \   000127   85..83       MOV     DPH,?V0 + 3
   \   00012A   A3           INC     DPTR
   \   00012B   A3           INC     DPTR
   \   00012C   E0           MOVX    A,@DPTR
   \   00012D   69           XRL     A,R1
   \   00012E   600B         JZ      ??zclProcessInWriteUndividedCmd_10
   \   000130   85..82       MOV     DPL,?V0 + 0
   \   000133   85..83       MOV     DPH,?V0 + 1
   \   000136   A3           INC     DPTR
   \   000137   748D         MOV     A,#-0x73
   \   000139   80A4         SJMP    ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_10:
   \   00013B   7409         MOV     A,#0x9
   \   00013D   12....       LCALL   ?XSTACK_DISP0_8
   \   000140   E0           MOVX    A,@DPTR
   \   000141   A2E1         MOV     C,0xE0 /* A   */.1
   \   000143   400B         JC      ??zclProcessInWriteUndividedCmd_11
   \   000145   85..82       MOV     DPL,?V0 + 0
   \   000148   85..83       MOV     DPH,?V0 + 1
   \   00014B   A3           INC     DPTR
   \   00014C   7488         MOV     A,#-0x78
   \   00014E   808F         SJMP    ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_11:
   \   000150   A2E5         MOV     C,0xE0 /* A   */.5
   \   000152   500B         JNC     ??zclProcessInWriteUndividedCmd_12
   \   000154   85..82       MOV     DPL,?V0 + 0
   \   000157   85..83       MOV     DPH,?V0 + 1
   \   00015A   A3           INC     DPTR
   \   00015B   747E         MOV     A,#0x7e
   \   00015D   8080         SJMP    ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_12:
   \   00015F   740A         MOV     A,#0xa
   \   000161   12....       LCALL   ?XSTACK_DISP0_8
   \   000164   12....       LCALL   ??Subroutine116_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_171:
   \   000167   7003         JNZ     $+5
   \   000169   02....       LJMP    ??zclProcessInWriteUndividedCmd_2 & 0xFFFF
   \   00016C                ; Setup parameters for call to function zclGetAttrDataLength
   \   00016C   12....       LCALL   ??zclGetAttrDataLength?relay
   \   00016F   02....       LJMP    ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
   4379          
   4380              curDataPtr = (uint8 *)((uint8 *)curWriteRec + hdrLen);
   \                     ??zclProcessInWriteUndividedCmd_8:
   \   000172   8F..         MOV     ?V0 + 2,R7
   \   000174   EA           MOV     A,R2
   \   000175   25..         ADD     A,?V0 + 2
   \   000177   F5..         MOV     ?V0 + 2,A
   \   000179   EB           MOV     A,R3
   \   00017A   3400         ADDC    A,#0x0
   \   00017C   F5..         MOV     ?V0 + 3,A
   4381          
   4382              // Write the new data over
   4383              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   00017E   7F00         MOV     R7,#0x0
   \   000180   8022         SJMP    ??zclProcessInWriteUndividedCmd_13
   4384              {
   4385                uint8 status;
   4386                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4387                zclWriteRec_t *curStatusRec = &(curWriteRec[i]);
   4388          
   4389                if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4390                                      statusRec->attrID, &attrRec ) )
   4391                {
   4392                  break; // should never happen
   4393                }
   4394          
   4395                // Keep a copy of the current data before before writing the new data over
   4396                curStatusRec->attrID = statusRec->attrID;
   4397                curStatusRec->attrData = curDataPtr;
   4398          
   4399                if ( attrRec.attr.dataPtr != NULL )
   4400                {
   4401                  // Read the current value
   4402                  zclReadAttrData( curDataPtr, &attrRec, &dataLen );
   4403          
   4404                  // Write the new attribute value
   4405                  status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4406                                             &attrRec, statusRec );
   4407                }
   4408                else // Use CBs
   4409                {
   4410                  // Read the current value
   4411                  zclReadAttrDataUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4412                                          statusRec->attrID, curDataPtr, &dataLen );
   4413                  // Write the new attribute value
   4414                  status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4415                                                    &attrRec, statusRec->attrData );
   4416                }
   4417          
   4418                // If successful, a write attribute status record shall NOT be generated
   4419                if ( status != ZCL_STATUS_SUCCESS )
   4420                {
   4421                  writeRspCmd->attrList[j].status = status;
   4422                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4423          
   4424                  // Since this write failed, we need to revert all the pervious writes
   4425                  zclRevertWriteUndividedCmd( pInMsg, curWriteRec, i);
   4426                  break;
   4427                }
   4428          
   4429                // add padding if needed
   4430                if ( PADDING_NEEDED( dataLen ) )
   \                     ??zclProcessInWriteUndividedCmd_14:
   \   000182   85..82       MOV     DPL,?XSP + 0
   \   000185   85..83       MOV     DPH,?XSP + 1
   \   000188   E0           MOVX    A,@DPTR
   \   000189   A2E0         MOV     C,0xE0 /* A   */.0
   \   00018B   5003         JNC     ??CrossCallReturnLabel_116
   4431                {
   4432                  dataLen++;
   \   00018D   12....       LCALL   ?Subroutine83 & 0xFFFF
   4433                }
   4434          
   4435                curDataPtr += dataLen;
   \                     ??CrossCallReturnLabel_116:
   \   000190   85..82       MOV     DPL,?XSP + 0
   \   000193   85..83       MOV     DPH,?XSP + 1
   \   000196   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_283:
   \   000199   E5..         MOV     A,?V0 + 2
   \   00019B   28           ADD     A,R0
   \   00019C   F5..         MOV     ?V0 + 2,A
   \   00019E   E5..         MOV     A,?V0 + 3
   \   0001A0   39           ADDC    A,R1
   \   0001A1   F5..         MOV     ?V0 + 3,A
   \   0001A3   0F           INC     R7
   \                     ??zclProcessInWriteUndividedCmd_13:
   \   0001A4   7402         MOV     A,#0x2
   \   0001A6   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A9   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   0001AC   4003         JC      $+5
   \   0001AE   02....       LJMP    ??zclProcessInWriteUndividedCmd_15 & 0xFFFF
   \   0001B1   EF           MOV     A,R7
   \   0001B2   75F005       MOV     B,#0x5
   \   0001B5   A4           MUL     AB
   \   0001B6   F8           MOV     R0,A
   \   0001B7   A9F0         MOV     R1,B
   \   0001B9   7402         MOV     A,#0x2
   \   0001BB   12....       LCALL   ?XSTACK_DISP0_8
   \   0001BE   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_132:
   \   0001C1   8582..       MOV     ?V0 + 6,DPL
   \   0001C4   8583..       MOV     ?V0 + 7,DPH
   \   0001C7   E5..         MOV     A,?V0 + 14
   \   0001C9   28           ADD     A,R0
   \   0001CA   F5..         MOV     ?V0 + 12,A
   \   0001CC   E5..         MOV     A,?V0 + 15
   \   0001CE   39           ADDC    A,R1
   \   0001CF   F5..         MOV     ?V0 + 13,A
   \   0001D1   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_320:
   \   0001D4                ; Setup parameters for call to function zclFindAttrRec
   \   0001D4   7404         MOV     A,#0x4
   \   0001D6   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D9   8582..       MOV     ?V0 + 10,DPL
   \   0001DC   8583..       MOV     ?V0 + 11,DPH
   \   0001DF   78..         MOV     R0,#?V0 + 10
   \   0001E1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001E4   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_260:
   \   0001E7   12....       LCALL   ??zclFindAttrRec?relay
   \   0001EA   7402         MOV     A,#0x2
   \   0001EC   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001EF   E9           MOV     A,R1
   \   0001F0   7003         JNZ     $+5
   \   0001F2   02....       LJMP    ??zclProcessInWriteUndividedCmd_15 & 0xFFFF
   \   0001F5   85..82       MOV     DPL,?V0 + 6
   \   0001F8   85..83       MOV     DPH,?V0 + 7
   \   0001FB   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_284:
   \   0001FE   85..82       MOV     DPL,?V0 + 12
   \   000201   85..83       MOV     DPH,?V0 + 13
   \   000204   E8           MOV     A,R0
   \   000205   F0           MOVX    @DPTR,A
   \   000206   A3           INC     DPTR
   \   000207   E9           MOV     A,R1
   \   000208   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   00020B   E5..         MOV     A,?V0 + 2
   \   00020D   F0           MOVX    @DPTR,A
   \   00020E   A3           INC     DPTR
   \   00020F   E5..         MOV     A,?V0 + 3
   \   000211   F0           MOVX    @DPTR,A
   \   000212   740A         MOV     A,#0xa
   \   000214   12....       LCALL   ?XSTACK_DISP0_8
   \   000217   12....       LCALL   ??Subroutine124_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_204:
   \   00021A   6042         JZ      ??zclProcessInWriteUndividedCmd_16
   \   00021C                ; Setup parameters for call to function zclReadAttrData
   \   00021C   85..82       MOV     DPL,?XSP + 0
   \   00021F   85..83       MOV     DPH,?XSP + 1
   \   000222   8582..       MOV     ?V0 + 8,DPL
   \   000225   8583..       MOV     ?V0 + 9,DPH
   \   000228   78..         MOV     R0,#?V0 + 8
   \   00022A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00022D   7406         MOV     A,#0x6
   \   00022F   12....       LCALL   ?XSTACK_DISP0_8
   \   000232   AC82         MOV     R4,DPL
   \   000234   AD83         MOV     R5,DPH
   \   000236   AA..         MOV     R2,?V0 + 2
   \   000238   AB..         MOV     R3,?V0 + 3
   \   00023A   12....       LCALL   ??zclReadAttrData?relay
   \   00023D   7402         MOV     A,#0x2
   \   00023F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000242   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_321:
   \   000245                ; Setup parameters for call to function zclWriteAttrData
   \   000245   78..         MOV     R0,#?V0 + 6
   \   000247   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00024A   7406         MOV     A,#0x6
   \   00024C   12....       LCALL   ?XSTACK_DISP0_8
   \   00024F   AC82         MOV     R4,DPL
   \   000251   AD83         MOV     R5,DPH
   \   000253   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   000256   12....       LCALL   ??Subroutine136_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_265:
   \   000259   12....       LCALL   ??zclWriteAttrData?relay
   \   00025C   8050         SJMP    ??zclProcessInWriteUndividedCmd_17
   \                     ??zclProcessInWriteUndividedCmd_16:
   \   00025E   85..82       MOV     DPL,?V0 + 4
   \   000261   85..83       MOV     DPH,?V0 + 5
   \   000264   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   000267   8582..       MOV     ?V0 + 10,DPL
   \   00026A   8583..       MOV     ?V0 + 11,DPH
   \   00026D   78..         MOV     R0,#?V0 + 10
   \   00026F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000272   78..         MOV     R0,#?V0 + 2
   \   000274   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000277   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_261:
   \   00027A   12....       LCALL   ??zclReadAttrDataUsingCB?relay
   \   00027D   7404         MOV     A,#0x4
   \   00027F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000282   85..82       MOV     DPL,?V0 + 4
   \   000285   85..83       MOV     DPH,?V0 + 5
   \   000288   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_285:
   \   00028B                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   00028B   85..82       MOV     DPL,?V0 + 6
   \   00028E   85..83       MOV     DPH,?V0 + 7
   \   000291   A3           INC     DPTR
   \   000292   A3           INC     DPTR
   \   000293   A3           INC     DPTR
   \   000294   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000297   7406         MOV     A,#0x6
   \   000299   12....       LCALL   ?XSTACK_DISP0_8
   \   00029C   AC82         MOV     R4,DPL
   \   00029E   AD83         MOV     R5,DPH
   \   0002A0   E8           MOV     A,R0
   \   0002A1   2406         ADD     A,#0x6
   \   0002A3   FA           MOV     R2,A
   \   0002A4   E9           MOV     A,R1
   \   0002A5   3400         ADDC    A,#0x0
   \   0002A7   FB           MOV     R3,A
   \   0002A8   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_270:
   \   0002AB   12....       LCALL   ??zclWriteAttrDataUsingCB?relay
   \                     ??zclProcessInWriteUndividedCmd_17:
   \   0002AE   7402         MOV     A,#0x2
   \   0002B0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0002B3   E9           MOV     A,R1
   \   0002B4   FB           MOV     R3,A
   \   0002B5   EB           MOV     A,R3
   \   0002B6   7003         JNZ     $+5
   \   0002B8   02....       LJMP    ??zclProcessInWriteUndividedCmd_14 & 0xFFFF
   \   0002BB   EE           MOV     A,R6
   \   0002BC   75F003       MOV     B,#0x3
   \   0002BF   A4           MUL     AB
   \   0002C0   F8           MOV     R0,A
   \   0002C1   A9F0         MOV     R1,B
   \   0002C3   E5..         MOV     A,?V0 + 0
   \   0002C5   28           ADD     A,R0
   \   0002C6   F8           MOV     R0,A
   \   0002C7   E5..         MOV     A,?V0 + 1
   \   0002C9   39           ADDC    A,R1
   \   0002CA   F9           MOV     R1,A
   \   0002CB   EB           MOV     A,R3
   \   0002CC   8882         MOV     DPL,R0
   \   0002CE   8983         MOV     DPH,R1
   \   0002D0   A3           INC     DPTR
   \   0002D1   F0           MOVX    @DPTR,A
   \   0002D2   85..82       MOV     DPL,?V0 + 6
   \   0002D5   85..83       MOV     DPH,?V0 + 7
   \   0002D8   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   0002DB   EA           MOV     A,R2
   \   0002DC   F0           MOVX    @DPTR,A
   \   0002DD   A3           INC     DPTR
   \   0002DE   EB           MOV     A,R3
   \   0002DF   F0           MOVX    @DPTR,A
   \   0002E0   0E           INC     R6
   \   0002E1                ; Setup parameters for call to function zclRevertWriteUndividedCmd
   \   0002E1   8F..         MOV     ?V0 + 2,R7
   \   0002E3   75..00       MOV     ?V0 + 3,#0x0
   \   0002E6   78..         MOV     R0,#?V0 + 2
   \   0002E8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002EB   AC..         MOV     R4,?V0 + 14
   \   0002ED   AD..         MOV     R5,?V0 + 15
   \   0002EF   AA..         MOV     R2,?V0 + 4
   \   0002F1   AB..         MOV     R3,?V0 + 5
   \   0002F3   12....       LCALL   ??zclRevertWriteUndividedCmd?relay
   \   0002F6   7402         MOV     A,#0x2
   \   0002F8   12....       LCALL   ?DEALLOC_XSTACK8
   4436              } // for loop
   4437          
   4438              writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_15:
   \   0002FB   EE           MOV     A,R6
   \   0002FC   85..82       MOV     DPL,?V0 + 0
   \   0002FF   85..83       MOV     DPH,?V0 + 1
   \   000302   F0           MOVX    @DPTR,A
   4439              if ( writeRspCmd->numAttr  == 0 )
   \   000303   7003         JNZ     ??CrossCallReturnLabel_30
   4440              {
   4441                // Since all records were written successful, include a single status record
   4442                // in the resonse command with the status field set to SUCCESS and the
   4443                // attribute ID field omitted.
   4444                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   000305   12....       LCALL   ?Subroutine29 & 0xFFFF
   4445                writeRspCmd->numAttr = 1;
   4446              }
   4447          
   4448              zcl_mem_free( curWriteRec );
   \                     ??CrossCallReturnLabel_30:
   \   000308                ; Setup parameters for call to function osal_mem_free
   \   000308   AA..         MOV     R2,?V0 + 14
   \   00030A   AB..         MOV     R3,?V0 + 15
   \   00030C   12....       LCALL   ??osal_mem_free?relay
   4449            }
   4450          
   4451            zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4452                              pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction,
   4453                              true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInWriteUndividedCmd_7:
   \   00030F   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000312   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000315   75..01       MOV     ?V0 + 2,#0x1
   \   000318   78..         MOV     R0,#?V0 + 2
   \   00031A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00031D   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_255:
   \   000320   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000323   78..         MOV     R0,#?V0 + 0
   \   000325   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000328   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   00032B   12....       LCALL   ??zcl_SendWriteRsp?relay
   \   00032E   7405         MOV     A,#0x5
   \   000330   12....       LCALL   ?DEALLOC_XSTACK8
   4454            zcl_mem_free( writeRspCmd );
   \   000333                ; Setup parameters for call to function osal_mem_free
   \   000333   AA..         MOV     R2,?V0 + 0
   \   000335   AB..         MOV     R3,?V0 + 1
   \   000337   12....       LCALL   ??osal_mem_free?relay
   4455          
   4456            return TRUE;
   \   00033A   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteUndividedCmd_9:
   \   00033C   740C         MOV     A,#0xc
   \   00033E   02....       LJMP    ?Subroutine4 & 0xFFFF
   4457          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine83:
   \   000000   2401         ADD     A,#0x1
   \   000002   F0           MOVX    @DPTR,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   3400         ADDC    A,#0x0
   \   000007   F0           MOVX    @DPTR,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_135:
   \   000003   EF           MOV     A,R7
   \   000004   C3           CLR     C
   \   000005   98           SUBB    A,R0
   \   000006   22           RET

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for zcl_RegisteredMsgTaskID>`:
   \   000000   FF           DB 255

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_event_loop?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_event_loop

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerForMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerForMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_HandleExternal?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_HandleExternal

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_getRawAFMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getRawAFMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerPlugin?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerPlugin

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerAttrList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerAttrList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerClusterOptionList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerClusterOptionList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerValidateAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerValidateAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerReadWriteCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerReadWriteCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_DeviceOperational?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_DeviceOperational

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendCommand?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendCommand

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReadRsp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendWriteRequest?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRequest

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendWriteRsp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendDefaultRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_ProcessMessageMSG?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_ProcessMessageMSG

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseHdr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclBuildHdr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclBuildHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclFindAttrRecsList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindAttrRecsList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclFindAttrRec?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindAttrRec

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetReadWriteCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetReadWriteCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetAuthorizeCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAuthorizeCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclFindClusterOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSetSecurityOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSetSecurityOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSerializeData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSerializeData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetDataTypeLength?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetDataTypeLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetAttrDataLength?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAttrDataLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclReadAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclReadAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_ReadAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_ReadAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetAttrDataLengthUsingCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAttrDataLengthUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclReadAttrDataUsingCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclReadAttrDataUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclWriteAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclWriteAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclWriteAttrDataUsingCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclWriteAttrDataUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclAuthorizeWrite?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclAuthorizeWrite

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInWriteCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInWriteRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInDefaultRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInReadCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInWriteCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclRevertWriteUndividedCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclRevertWriteUndividedCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInWriteUndividedCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteUndividedCmd
   4458          #endif // ZCL_WRITE
   4459          
   4460          #ifdef ZCL_DISCOVER
   4461          /*********************************************************************
   4462           * @fn      zclProcessInDiscAttrs
   4463           *
   4464           * @brief   Process the "Profile" Discover Attributes Commands
   4465           *
   4466           * @param   pInMsg - incoming message to process
   4467           *
   4468           * @return  TRUE if command processed. FALSE, otherwise.
   4469           */
   4470          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg )
   4471          {
   4472            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   4473            zclAttrRec_t attrRec;
   4474            uint16 attrID;
   4475            uint8 numAttrs;
   4476            uint8 i;
   4477          
   4478            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)pInMsg->attrCmd;
   4479          
   4480            // Find out the number of attributes supported within the specified range
   4481            for ( i = 0, attrID = pDiscoverCmd->startAttr; i < pDiscoverCmd->maxAttrIDs; i++, attrID++ )
   4482            {
   4483              // finds the next attribute on this endpoint/cluster after the range.
   4484              // attributes must be in numerical order in the list.
   4485              if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4486              {
   4487                break;
   4488              }
   4489            }
   4490          
   4491            numAttrs = i;  // store range of attributes in buffer
   4492          
   4493              // Process message for either attributes or extended attributes
   4494            if( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS )
   4495            {
   4496              zclProcessInDiscAttrsCmd( pInMsg, pDiscoverCmd, numAttrs );
   4497            }
   4498            else if ( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS_EXT )
   4499            {
   4500              zclProcessInDiscAttrsExtCmd( pInMsg, pDiscoverCmd, numAttrs );
   4501            }
   4502          
   4503            return TRUE;
   4504          }
   4505          
   4506          /*********************************************************************
   4507           * @fn      zclProcessInDiscAttrsCmd
   4508           *
   4509           * @brief   Process the Discover Attributes Command
   4510           *
   4511           * @param   pInMsg - incoming message to process
   4512           *
   4513           * @param   pDiscoverCmd - structure from requesting command
   4514           *
   4515           * @param   attrLenBuf - describes the amount of attributes to be processed
   4516           *
   4517           * @return  none
   4518           */
   4519          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   4520          {
   4521            zclDiscoverAttrsRspCmd_t *pDiscoverRsp;
   4522            uint8 discComplete = TRUE;
   4523            zclAttrRec_t attrRec;
   4524            uint16 attrID;
   4525            uint8 i;
   4526          
   4527            // Allocate space for the response command
   4528            pDiscoverRsp = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsRspCmd_t)
   4529                                                                    + sizeof ( zclDiscoverAttrInfo_t ) * numAttrs );
   4530            if ( pDiscoverRsp == NULL )
   4531            {
   4532              return; // EMEDDED RETURN
   4533            }
   4534          
   4535            if ( numAttrs != 0 )
   4536            {
   4537              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   4538              {
   4539                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4540                {
   4541                  break; // should not happen, as numAttrs already calculated
   4542                }
   4543          
   4544                pDiscoverRsp->attrList[i].attrID = attrRec.attr.attrId;
   4545                pDiscoverRsp->attrList[i].dataType = attrRec.attr.dataType;
   4546              }
   4547          
   4548              // Are there more attributes to be discovered?
   4549              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4550              {
   4551                discComplete = FALSE;
   4552              }
   4553            }
   4554          
   4555            pDiscoverRsp->discComplete = discComplete;
   4556            pDiscoverRsp->numAttr = numAttrs;
   4557          
   4558            zcl_SendDiscoverAttrsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4559                                         pInMsg->msg->clusterId, pDiscoverRsp, !(pInMsg->hdr.fc.direction),
   4560                                         true, pInMsg->hdr.transSeqNum );
   4561            zcl_mem_free( pDiscoverRsp );
   4562          
   4563            return;
   4564          }
   4565          
   4566          /*********************************************************************
   4567           * @fn      zclProcessInDiscAttrsExtCmd
   4568           *
   4569           * @brief   Process the Discover Attributes Extended Command
   4570           *
   4571           * @param   pInMsg - incoming message to process
   4572           *
   4573           * @param   pDiscoverCmd - structure from requesting command
   4574           *
   4575           * @param   attrLenBuf - describes the amount of attributes to be processed
   4576           *
   4577           * @return  none
   4578           */
   4579          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   4580          {
   4581            zclDiscoverAttrsExtRsp_t *pDiscoverExtRsp;
   4582            uint8 discComplete = TRUE;
   4583            zclAttrRec_t attrRec;
   4584            uint16 attrID;
   4585            uint8 i;
   4586          
   4587              // Allocate space for the response command
   4588            pDiscoverExtRsp = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsExtRsp_t)
   4589                                                                   + sizeof ( zclExtAttrInfo_t ) * numAttrs );
   4590            if ( pDiscoverExtRsp == NULL )
   4591            {
   4592              return; // EMEDDED RETURN
   4593            }
   4594          
   4595          
   4596            if ( numAttrs != 0 )
   4597            {
   4598              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   4599              {
   4600                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4601                {
   4602                  break; // Should not happen, as numAttrs already calculated
   4603                }
   4604          
   4605                pDiscoverExtRsp->aExtAttrInfo[i].attrID = attrRec.attr.attrId;
   4606                pDiscoverExtRsp->aExtAttrInfo[i].attrDataType = attrRec.attr.dataType;
   4607                pDiscoverExtRsp->aExtAttrInfo[i].attrAccessControl = attrRec.attr.accessControl & ACCESS_CONTROLEXT_MASK;
   4608              }
   4609          
   4610              // Are there more attributes to be discovered?
   4611              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4612              {
   4613                discComplete = FALSE;
   4614              }
   4615            }
   4616          
   4617            pDiscoverExtRsp->discComplete = discComplete;
   4618            pDiscoverExtRsp->numAttr = numAttrs;
   4619          
   4620            zcl_SendDiscoverAttrsExtRsp( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4621                                         pInMsg->msg->clusterId, pDiscoverExtRsp, !(pInMsg->hdr.fc.direction),
   4622                                         true, pInMsg->hdr.transSeqNum );
   4623          
   4624            zcl_mem_free( pDiscoverExtRsp );
   4625          
   4626            return;
   4627          }
   4628          
   4629          /*********************************************************************
   4630           * @fn      zclProcessInDiscCmd
   4631           *
   4632           * @brief   Process the "Profile" Discover Command
   4633           *
   4634           * @param   pInMsg - incoming message to process
   4635           *
   4636           * @return  TRUE if command processed. FALSE, otherwise.
   4637           */
   4638          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg )
   4639          {
   4640            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   4641            zclDiscoverCmdsCmdRsp_t cmdRsp;
   4642            ZStatus_t status;
   4643            zclCommandRec_t cmdRec;
   4644            uint8 cmdID;
   4645            uint8 i;
   4646            uint8 j;
   4647          
   4648            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)pInMsg->attrCmd;
   4649          
   4650            // Find out the number of commands supported within the specified range
   4651            for ( i = 0, cmdID = pDiscoverCmd->startCmdID; i < pDiscoverCmd->maxCmdID; i++, cmdID++ )
   4652            {
   4653              if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4654              {
   4655                break;  // Command not supported
   4656              }
   4657            }
   4658          
   4659            // Allocate space for the response command
   4660            cmdRsp.pCmdID = zcl_mem_alloc( i ); // size of number of commands returned
   4661          
   4662            if ( cmdRsp.pCmdID == NULL )
   4663            {
   4664              return FALSE; // EMEDDED RETURN
   4665            }
   4666          
   4667            if ( i != 0 )
   4668            {
   4669              for ( j = 0, cmdID = pDiscoverCmd->startCmdID; j < i; j++, cmdID++ )
   4670              {
   4671                if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4672                {
   4673                  break; // Attribute not supported
   4674                }
   4675          
   4676                cmdRsp.pCmdID[j] = cmdRec.cmdID;
   4677              }
   4678            }
   4679          
   4680            // Are there more commands to be discovered?
   4681            if ( zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4682            {
   4683              cmdRsp.discComplete = FALSE;
   4684            }
   4685            else
   4686            {
   4687              cmdRsp.discComplete = TRUE;
   4688            }
   4689          
   4690            // pass the command requested
   4691            cmdRsp.cmdType = pInMsg->hdr.commandID;
   4692          
   4693            // store number of commands returned
   4694            cmdRsp.numCmd = j;
   4695          
   4696            status = zcl_SendDiscoverCmdsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4697                                                pInMsg->msg->clusterId, &cmdRsp, !(pInMsg->hdr.fc.direction),
   4698                                                true, pInMsg->hdr.transSeqNum );
   4699          
   4700            zcl_mem_free( cmdRsp.pCmdID );
   4701          
   4702            if ( status == ZSuccess )
   4703            {
   4704              return TRUE;
   4705            }
   4706            else
   4707            {
   4708              return FALSE;
   4709            }
   4710          }
   4711          
   4712          #endif // ZCL_DISCOVER
   4713          
   4714          /*********************************************************************
   4715          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK PSTACK XSTACK Function
   ------ ------ ------ --------
       0      0     30  zclAuthorizeWrite
                          0 0 14 -> zclGetAuthorizeCB
       1      0     42  zclBuildHdr
       0      0     54  zclFindAttrRec
                          0 0 16 -> zclFindAttrRecsList
       2      0     16  zclFindAttrRecsList
       0      0     46  zclFindClusterOption
       0      0     45  zclGetAttrDataLength
                          0 0  9 -> zclGetDataTypeLength
       0      0     58  zclGetAttrDataLengthUsingCB
                          0 0 18 -> zclGetReadWriteCB
       0      0     42  zclGetAuthorizeCB
                          0 0 10 -> zclFindAttrRecsList
       0      0      9  zclGetDataTypeLength
       0      0     28  zclGetReadWriteCB
                          0 0 10 -> zclFindAttrRecsList
       1      0     49  zclParseHdr
                          0 0 12 -> osal_memset
       1      0     10  zclParseInDefaultRspCmd
                          0 0 10 -> osal_mem_alloc
       1      0     12  zclParseInReadCmd
                          0 0 12 -> osal_mem_alloc
       1      0     25  zclParseInReadRspCmd
                          0 0 22 -> osal_mem_alloc
                          0 0 25 -> osal_memcpy
                          0 0 22 -> zclGetAttrDataLength
       1      0     25  zclParseInWriteCmd
                          0 0 22 -> osal_mem_alloc
                          0 0 25 -> osal_memcpy
                          0 0 22 -> zclGetAttrDataLength
       1      0     16  zclParseInWriteRspCmd
                          0 0 16 -> osal_mem_alloc
       1      0     37  zclProcessInReadCmd
                          0 0 32 -> osal_mem_alloc
                          0 0 32 -> osal_mem_free
                          0 0 34 -> zclFindAttrRec
                          0 0 32 -> zclGetAuthorizeCB
                          0 0 37 -> zcl_SendReadRsp
       1      0     39  zclProcessInWriteCmd
                          0 0 34 -> osal_mem_alloc
                          0 0 34 -> osal_mem_free
                          0 0 36 -> zclFindAttrRec
                          0 0 36 -> zclWriteAttrData
                          0 0 36 -> zclWriteAttrDataUsingCB
                          0 0 39 -> zcl_SendWriteRsp
       1      0     41  zclProcessInWriteUndividedCmd
                          0 0 36 -> osal_mem_alloc
                          0 0 36 -> osal_mem_free
                          0 0 38 -> zclFindAttrRec
                          0 0 36 -> zclGetAttrDataLength
                          0 0 36 -> zclGetAttrDataLengthUsingCB
                          0 0 38 -> zclReadAttrData
                          0 0 40 -> zclReadAttrDataUsingCB
                          0 0 38 -> zclRevertWriteUndividedCmd
                          0 0 38 -> zclWriteAttrData
                          0 0 38 -> zclWriteAttrDataUsingCB
                          0 0 41 -> zcl_SendWriteRsp
       0      0     56  zclReadAttrData
                          0 0 18 -> osal_memcpy
                          0 0 15 -> zclGetAttrDataLength
       0      0     62  zclReadAttrDataUsingCB
                          0 0 18 -> zclGetReadWriteCB
       0      0     69  zclRevertWriteUndividedCmd
                          0 0 31 -> osal_memcpy
                          0 0 30 -> zclFindAttrRec
                          0 0 28 -> zclGetAttrDataLength
                          0 0 30 -> zclWriteAttrDataUsingCB
       1      0     45  zclSerializeData
                          0 0 18 -> osal_buffer_uint32
                          0 0 17 -> osal_memcpy
       0      0     47  zclSetSecurityOption
                          0 0 10 -> zclFindClusterOption
       0      0     56  zclWriteAttrData
                          0 0 18 -> osal_memcpy
                          0 0 15 -> zclAuthorizeWrite
                          0 0 15 -> zclGetAttrDataLength
       0      0     58  zclWriteAttrDataUsingCB
                          0 0 16 -> zclAuthorizeWrite
                          0 0 16 -> zclGetReadWriteCB
       0      0     61  zcl_DeviceOperational
                          0 0 22 -> zclFindAttrRec
                          0 0 22 -> zclReadAttrData
       1      0     10  zcl_HandleExternal
                          0 0 10 -> osal_msg_allocate
                          0 0 10 -> osal_msg_send
       2      0      0  zcl_Init
       1      0     56  zcl_ProcessMessageMSG
                          0 0 37 -> StubAPS_InterPan
                          0 0 37 -> afFindEndPointDesc
                          0 0 37 -> osal_mem_free
                          0 0 37 -> zclFindClusterOption
                          0 0 37 -> zclParseHdr
                          0 0 37 -> zclSetSecurityOption
                          0 0 39 -> zcl_DeviceOperational
                          0 0 44 -> zcl_SendDefaultRspCmd
       0      0     32  zcl_ReadAttrData
                          0 0 26 -> zclFindAttrRec
                          0 0 26 -> zclReadAttrData
                          0 0 28 -> zclReadAttrDataUsingCB
       1      0     77  zcl_SendCommand
                          0 0 39 -> AF_DataRequest
                          0 0 30 -> StubAPS_InterPan
                          0 0 30 -> afFindEndPointDesc
                          0 0 30 -> osal_mem_alloc
                          0 0 30 -> osal_mem_free
                          0 0 33 -> osal_memcpy
                          0 0 30 -> osal_memset
                          0 0 33 -> zclBuildHdr
                          0 0 30 -> zclFindClusterOption
                          0 0 32 -> zcl_DeviceOperational
       1      0     71  zcl_SendDefaultRspCmd
                          0 0 27 -> zcl_SendCommand
       1      0     38  zcl_SendRead
                          0 0 22 -> osal_mem_alloc
                          0 0 22 -> osal_mem_free
                          0 0 33 -> zcl_SendCommand
       1      0     75  zcl_SendReadRsp
                          0 0 27 -> osal_mem_alloc
                          0 0 27 -> osal_mem_free
                          0 0 27 -> zclGetAttrDataLength
                          0 0 27 -> zclGetAttrDataLengthUsingCB
                          0 0 31 -> zclReadAttrDataUsingCB
                          0 0 27 -> zclSerializeData
                          0 0 38 -> zcl_SendCommand
       1      0     41  zcl_SendWriteRequest
                          0 0 24 -> osal_mem_alloc
                          0 0 24 -> osal_mem_free
                          0 0 24 -> zclGetAttrDataLength
                          0 0 24 -> zclSerializeData
                          0 0 35 -> zcl_SendCommand
       1      0     74  zcl_SendWriteRsp
                          0 0 22 -> osal_mem_alloc
                          0 0 22 -> osal_mem_free
                          0 0 33 -> zcl_SendCommand
       0      0     12  zcl_event_loop
                          0 0 12 -> osal_msg_deallocate
                          0 0 12 -> osal_msg_receive
                          0 0 12 -> osal_msg_send
                          0 0 12 -> zcl_ProcessMessageMSG
       2      0      0  zcl_getRawAFMsg
       1      0     12  zcl_registerAttrList
                          0 0 12 -> osal_mem_alloc
       1      0     12  zcl_registerClusterOptionList
                          0 0 12 -> osal_mem_alloc
       2      0      0  zcl_registerForMsg
       0      0     16  zcl_registerPlugin
                          0 0 14 -> osal_mem_alloc
       0      0     14  zcl_registerReadWriteCB
                          0 0 14 -> zclFindAttrRecsList
       2      0      0  zcl_registerValidateAttrData


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for zcl_RegisteredMsgTaskID>
      11  ??Subroutine112_0
       5  ??Subroutine113_0
       9  ??Subroutine114_0
       8  ??Subroutine115_0
       6  ??Subroutine116_0
       5  ??Subroutine117_0
       5  ??Subroutine118_0
       7  ??Subroutine119_0
      11  ??Subroutine120_0
       5  ??Subroutine121_0
       5  ??Subroutine122_0
       2  ??Subroutine123_0
       6  ??Subroutine124_0
       4  ??Subroutine125_0
       2  ??Subroutine126_0
       6  ??Subroutine127_0
       6  ??Subroutine128_0
       7  ??Subroutine129_0
       1  ??Subroutine130_0
       5  ??Subroutine131_0
       5  ??Subroutine132_0
      10  ??Subroutine133_0
      27  ??Subroutine134_0
       4  ??Subroutine135_0
       4  ??Subroutine136_0
       4  ??Subroutine137_0
       1  ??Subroutine138_0
       3  ??Subroutine139_0
       4  ??Subroutine140_0
       8  ??Subroutine141_0
       1  ??Subroutine142_0
       2  ??Subroutine143_0
       4  ??Subroutine144_0
       5  ??Subroutine145_0
       5  ??Subroutine146_0
       6  ??zclAuthorizeWrite?relay
       6  ??zclBuildHdr?relay
       6  ??zclFindAttrRec?relay
       6  ??zclFindAttrRecsList?relay
       6  ??zclFindClusterOption?relay
       6  ??zclGetAttrDataLength?relay
       6  ??zclGetAttrDataLengthUsingCB?relay
       6  ??zclGetAuthorizeCB?relay
       6  ??zclGetDataTypeLength?relay
       6  ??zclGetReadWriteCB?relay
       6  ??zclParseHdr?relay
       6  ??zclParseInDefaultRspCmd?relay
       6  ??zclParseInReadCmd?relay
       6  ??zclParseInReadRspCmd?relay
       6  ??zclParseInWriteCmd?relay
       6  ??zclParseInWriteRspCmd?relay
       6  ??zclProcessInReadCmd?relay
       6  ??zclProcessInWriteCmd?relay
       6  ??zclProcessInWriteUndividedCmd?relay
       6  ??zclReadAttrData?relay
       6  ??zclReadAttrDataUsingCB?relay
       6  ??zclRevertWriteUndividedCmd?relay
       6  ??zclSerializeData?relay
       6  ??zclSetSecurityOption?relay
       6  ??zclWriteAttrData?relay
       6  ??zclWriteAttrDataUsingCB?relay
       6  ??zcl_DeviceOperational?relay
       6  ??zcl_HandleExternal?relay
       6  ??zcl_Init?relay
       6  ??zcl_ProcessMessageMSG?relay
       6  ??zcl_ReadAttrData?relay
       6  ??zcl_SendCommand?relay
       6  ??zcl_SendDefaultRspCmd?relay
       6  ??zcl_SendRead?relay
       6  ??zcl_SendReadRsp?relay
       6  ??zcl_SendWriteRequest?relay
       6  ??zcl_SendWriteRsp?relay
       6  ??zcl_event_loop?relay
       6  ??zcl_getRawAFMsg?relay
       6  ??zcl_registerAttrList?relay
       6  ??zcl_registerClusterOptionList?relay
       6  ??zcl_registerForMsg?relay
       6  ??zcl_registerPlugin?relay
       6  ??zcl_registerReadWriteCB?relay
       6  ??zcl_registerValidateAttrData?relay
       7  ?Subroutine0
       5  ?Subroutine1
      11  ?Subroutine10
       9  ?Subroutine100
      14  ?Subroutine101
       7  ?Subroutine102
       3  ?Subroutine103
      14  ?Subroutine104
       4  ?Subroutine105
      10  ?Subroutine106
      10  ?Subroutine107
       6  ?Subroutine108
       9  ?Subroutine109
      45  ?Subroutine11
       5  ?Subroutine110
       3  ?Subroutine111
       9  ?Subroutine12
       9  ?Subroutine13
       6  ?Subroutine14
      11  ?Subroutine15
       6  ?Subroutine16
       8  ?Subroutine17
       3  ?Subroutine18
      10  ?Subroutine19
       5  ?Subroutine2
      12  ?Subroutine20
       4  ?Subroutine21
      11  ?Subroutine22
       8  ?Subroutine23
      14  ?Subroutine24
       2  ?Subroutine25
      12  ?Subroutine26
       6  ?Subroutine27
       7  ?Subroutine28
      12  ?Subroutine29
       5  ?Subroutine3
       4  ?Subroutine30
       6  ?Subroutine31
       3  ?Subroutine32
       5  ?Subroutine33
      14  ?Subroutine34
       6  ?Subroutine35
      13  ?Subroutine36
      18  ?Subroutine37
      29  ?Subroutine38
      13  ?Subroutine39
       3  ?Subroutine4
      11  ?Subroutine40
      10  ?Subroutine41
       9  ?Subroutine42
       1  ?Subroutine43
      10  ?Subroutine44
      15  ?Subroutine45
       6  ?Subroutine46
       6  ?Subroutine47
       8  ?Subroutine48
       7  ?Subroutine49
       4  ?Subroutine5
       8  ?Subroutine50
      10  ?Subroutine51
      14  ?Subroutine52
       6  ?Subroutine53
       9  ?Subroutine54
      10  ?Subroutine55
       1  ?Subroutine56
      10  ?Subroutine57
       2  ?Subroutine58
       4  ?Subroutine59
       3  ?Subroutine6
      12  ?Subroutine60
       8  ?Subroutine61
      12  ?Subroutine62
      11  ?Subroutine63
       6  ?Subroutine64
       4  ?Subroutine65
       4  ?Subroutine66
       5  ?Subroutine67
       8  ?Subroutine68
      21  ?Subroutine69
       5  ?Subroutine7
       8  ?Subroutine70
       4  ?Subroutine71
       9  ?Subroutine72
       1  ?Subroutine73
      12  ?Subroutine74
       1  ?Subroutine75
      18  ?Subroutine76
       3  ?Subroutine77
       9  ?Subroutine78
       7  ?Subroutine79
       5  ?Subroutine8
       9  ?Subroutine80
      11  ?Subroutine81
      10  ?Subroutine82
       9  ?Subroutine83
      12  ?Subroutine84
      18  ?Subroutine85
      11  ?Subroutine86
       5  ?Subroutine87
       9  ?Subroutine88
      16  ?Subroutine89
       4  ?Subroutine9
      13  ?Subroutine90
       4  ?Subroutine91
       8  ?Subroutine92
       6  ?Subroutine93
      12  ?Subroutine94
       6  ?Subroutine95
       4  ?Subroutine96
      11  ?Subroutine97
      10  ?Subroutine98
       6  ?Subroutine99
       2  attrList
       2  clusterOptionList
       2  plugins
       2  rawAFMsg
      60  zclAuthorizeWrite
      83  zclBuildHdr
      92  zclCmdTable
     157  zclFindAttrRec
      37  zclFindAttrRecsList
     103  zclFindClusterOption
      62  zclGetAttrDataLength
     105  zclGetAttrDataLengthUsingCB
      28  zclGetAuthorizeCB
     166  zclGetDataTypeLength
      29  zclGetReadWriteCB
     209  zclParseHdr
      44  zclParseInDefaultRspCmd
     107  zclParseInReadCmd
     272  zclParseInReadRspCmd
     236  zclParseInWriteCmd
     120  zclParseInWriteRspCmd
     415  zclProcessInReadCmd
     446  zclProcessInWriteCmd
     833  zclProcessInWriteUndividedCmd
     102  zclReadAttrData
     100  zclReadAttrDataUsingCB
     252  zclRevertWriteUndividedCmd
     339  zclSerializeData
      46  zclSetSecurityOption
     148  zclWriteAttrData
     109  zclWriteAttrDataUsingCB
     136  zcl_DeviceOperational
     166  zcl_HandleExternal
      12  zcl_Init
    1157  zcl_ProcessMessageMSG
     137  zcl_ReadAttrData
       1  zcl_RegisteredMsgTaskID
     531  zcl_SendCommand
     164  zcl_SendDefaultRspCmd
     218  zcl_SendRead
     442  zcl_SendReadRsp
     317  zcl_SendWriteRequest
     254  zcl_SendWriteRsp
       1  zcl_SeqNum
       1  zcl_TaskID
       1  zcl_TransID
       2  zcl_ValidateAttrDataCB
      93  zcl_event_loop
      10  zcl_getRawAFMsg
      89  zcl_registerAttrList
      78  zcl_registerClusterOptionList
      24  zcl_registerForMsg
     111  zcl_registerPlugin
      58  zcl_registerReadWriteCB
      17  zcl_registerValidateAttrData

 
 9 792 bytes in segment BANKED_CODE
   270 bytes in segment BANK_RELAYS
    92 bytes in segment CODE_C
     1 byte  in segment XDATA_I
     1 byte  in segment XDATA_ID
    13 bytes in segment XDATA_Z
 
 10 155 bytes of CODE  memory
     14 bytes of XDATA memory

Errors: none
Warnings: none
