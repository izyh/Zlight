###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.20.2.41139 for 8051             27/May/2014  19:14:29 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  D:\Texas Instruments\Z-Stack Lighting              #
#                          1.0.2\Projects\zstack\ZLL\Source\zll.c             #
#    Command line       =  -f "D:\Texas Instruments\Z-Stack Lighting          #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\Tools\CC2530DB\f8wRouter.cfg" (-DCPU32MHZ        #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8       #
#                          -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f "D:\Texas         #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\Tools\CC2530DB\f8wConfig.cfg" (-DZIGBEEPRO       #
#                          -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR       #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100    #
#                          -DREJOIN_POLL_RATE=440) -f "D:\Texas               #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\Tools\CC2530DB\f8wZCL.cfg" "D:\Texas             #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\Source\zll.c" -D         #
#                          FEATURE_GREEN_POWER -D SECURE=1 -D                 #
#                          TC_LINKKEY_JOIN -D ZDSECMGR_TC_DEVICE_MAX=2 -D     #
#                          NV_RESTORE -D HOLD_AUTO_START -D INTER_PAN -D      #
#                          LCD_SUPPORTED=DEBUG -D ZCL_BASIC -D ZCL_READ -D    #
#                          ZCL_WRITE -D ZCL_IDENTIFY -D ZCL_ON_OFF -D         #
#                          ZCL_SCENES -D ZCL_GROUPS -D                        #
#                          ZCL_LIGHT_LINK_ENHANCE -D ZCL_LEVEL_CTRL -D        #
#                          ZCL_COLOR_CTRL -D MAX_CHANNELS_24GHZ=0x02108800    #
#                          -D xPWM_ALT2 -D xTHERMAL_SHUTDOWN -D               #
#                          ZLL_1_0_HUB_COMPATIBILITY -D DALI_LIGHT -lC        #
#                          "D:\Texas Instruments\Z-Stack Lighting             #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\Zlight  #
#                          - Router\List\" -lA "D:\Texas Instruments\Z-Stack  #
#                          Lighting 1.0.2\Projects\zstack\ZLL\SampleApp\CC253 #
#                          x\Zlight - Router\List\" --diag_suppress           #
#                          Pe001,Pa010 -o "D:\Texas Instruments\Z-Stack       #
#                          Lighting 1.0.2\Projects\zstack\ZLL\SampleApp\CC253 #
#                          x\Zlight - Router\Obj\" -e --debug --core=plain    #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "D:\Texas                  #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\" -I    #
#                          "D:\Texas Instruments\Z-Stack Lighting             #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\Sour #
#                          ce\" -I "D:\Texas Instruments\Z-Stack Lighting     #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\S #
#                          ource\" -I "D:\Texas Instruments\Z-Stack Lighting  #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\HomeAutomation\Source\" -I "D:\Texas             #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\HomeAutomation\SampleLight\Source\" -I           #
#                          "D:\Texas Instruments\Z-Stack Lighting             #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\ZMain\TI2530DB\" -I "D:\Texas                    #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\hal\include\" -I "D:\Texas      #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\hal\target\CC2530PMP4712\" -I   #
#                          "D:\Texas Instruments\Z-Stack Lighting             #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mac\include\" -I "D:\Texas      #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mac\high_level\" -I "D:\Texas   #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mac\low_level\srf04\" -I        #
#                          "D:\Texas Instruments\Z-Stack Lighting             #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mac\low_level\srf04\single_chip #
#                          \" -I "D:\Texas Instruments\Z-Stack Lighting       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\mt\" -I "D:\Texas               #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\osal\include\" -I "D:\Texas     #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\services\saddr\" -I "D:\Texas   #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\services\sdata\" -I "D:\Texas   #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\af\" -I "D:\Texas         #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\nwk\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\sapi\" -I "D:\Texas       #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\sec\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\sys\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\zcl\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\stack\zdo\" -I "D:\Texas        #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\zmac\" -I "D:\Texas             #
#                          Instruments\Z-Stack Lighting                       #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\..\..\. #
#                          .\..\..\Components\zmac\f8w\" -Ohz                 #
#                          --require_prototypes                               #
#    List file          =  D:\Texas Instruments\Z-Stack Lighting              #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\Zlight  #
#                          - Router\List\zll.lst                              #
#    Object file        =  D:\Texas Instruments\Z-Stack Lighting              #
#                          1.0.2\Projects\zstack\ZLL\SampleApp\CC253x\Zlight  #
#                          - Router\Obj\zll.r51                               #
#                                                                             #
#                                                                             #
###############################################################################

D:\Texas Instruments\Z-Stack Lighting 1.0.2\Projects\zstack\ZLL\Source\zll.c
      1          /**************************************************************************************************
      2            Filename:       zll.c
      3            Revised:        $Date: 2013-12-06 15:53:38 -0800 (Fri, 06 Dec 2013) $
      4            Revision:       $Revision: 36460 $
      5          
      6            Description:    Zigbee Cluster Library - Light Link Profile.
      7          
      8          
      9            Copyright 2011-2013 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "OSAL_Nv.h"
     44          #include "hal_aes.h"
     45          #include "nwk_util.h"
     46          #include "ZDSecMgr.h"
     47          #include "ZDObject.h"
     48          
     49          #if defined( INTER_PAN )
     50            #include "stub_aps.h"
     51          #endif
     52          
     53          #include "zcl_ll.h"
     54          #include "zll.h"
     55          
     56          /*********************************************************************
     57           * MACROS
     58           */
     59          #define ZLL_NEW_MIN( min, max )                  ( ( (uint32)(max) + (uint32)(min) + 1 ) / 2 )
     60          
     61          /*********************************************************************
     62           * CONSTANTS
     63           */
     64          
     65          #define ZLL_NUM_DEVICE_INFO_ENTRIES              5
     66          
     67          
     68          /*********************************************************************
     69           * TYPEDEFS
     70           */
     71          
     72          /*********************************************************************
     73           * GLOBAL VARIABLES
     74           */
     75          
     76          // Used for Network Discovery

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     77          zllDiscoveredNwkParam_t *pDiscoveredNwkParamList = NULL;
   \                     pDiscoveredNwkParamList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     78          
     79          // Current Touch Link Transaction ID

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     80          uint32 zllTransID;
   \                     zllTransID:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
     81          
     82          // Scan Response ID

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     83          uint32 zllResponseID;
   \                     zllResponseID:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
     84          
     85          // Our group ID range

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     86          uint16 zllGrpIDsBegin;
   \                     zllGrpIDsBegin:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     87          uint16 zllGrpIDsEnd;
   \                     zllGrpIDsEnd:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     88          
     89          // Flag for leave

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     90          uint8 zllLeaveInitiated;
   \                     zllLeaveInitiated:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     91          
     92          // Flags for Classical Commissioning

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     93          uint8 zllHAScanInitiated;
   \                     zllHAScanInitiated:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     94          bool zllJoinedHANetwork;
   \                     zllJoinedHANetwork:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     95          
     96          /*********************************************************************
     97           * EXTERNAL VARIABLES
     98           */
     99          
    100          /*********************************************************************
    101           * EXTERNAL FUNCTIONS
    102           */
    103          
    104          /*********************************************************************
    105           * LOCAL VARIABLES
    106           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    107          static uint32 zllLastAcceptedTransID;
   \                     zllLastAcceptedTransID:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
    108          
    109          // ZLL Profile attributes - Our free network address and group ID ranges

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    110          static uint16 zllFreeNwkAddrBegin;
   \                     zllFreeNwkAddrBegin:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    111          static uint16 zllFreeNwkAddrEnd;
   \                     zllFreeNwkAddrEnd:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    112          static uint16 zllFreeGrpIdBegin;
   \                     zllFreeGrpIdBegin:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    113          static uint16 zllFreeGrpIdEnd;
   \                     zllFreeGrpIdEnd:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    114          
    115          // Device Information Table

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    116          static zclLLDeviceInfo_t *zllSubDevicesTbl[ZLL_NUM_DEVICE_INFO_ENTRIES];
   \                     zllSubDevicesTbl:
   \   000000                DS 10
   \   00000A                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    117          static bool zllIsInitiator;
   \                     zllIsInitiator:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    118          static uint8 zllTaskId;
   \                     zllTaskId:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    119          
    120          // This is the Cluster ID List and should be filled with Application
    121          // specific cluster IDs.
    122          #define ZLL_EP_MAX_INCLUSTERS       1

   \                                 In  segment XDATA_ROM_C, align 1
    123          static const cId_t zll_EP_InClusterList[ZLL_EP_MAX_INCLUSTERS] =
   \                     zll_EP_InClusterList:
   \   000000   0010         DW 4096
    124          {
    125            ZCL_CLUSTER_ID_LIGHT_LINK
    126          };
    127          
    128          #define ZLL_EP_MAX_OUTCLUSTERS       1

   \                                 In  segment XDATA_ROM_C, align 1
    129          static const cId_t zll_EP_OutClusterList[ZLL_EP_MAX_OUTCLUSTERS] =
   \                     zll_EP_OutClusterList:
   \   000000   0010         DW 4096
    130          {
    131            ZCL_CLUSTER_ID_LIGHT_LINK
    132          };
    133          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    134          static SimpleDescriptionFormat_t zll_EP_SimpleDesc =
   \                     zll_EP_SimpleDesc:
   \   000000                DS 12
   \   00000C                REQUIRE `?<Initializer for zll_EP_SimpleDesc>`
   \   00000C                REQUIRE __INIT_XDATA_I
    135          {
    136            ZLL_INTERNAL_ENDPOINT,         //  int Endpoint;
    137            ZLL_PROFILE_ID,                //  uint16 AppProfId[2];
    138            ZLL_INTERNAL_DEVICE_ID,        //  uint16 AppDeviceId[2];
    139            ZLL_DEVICE_VERSION,            //  int   AppDevVer:4;
    140            ZLL_INTERNAL_FLAGS,            //  int   AppFlags:4;
    141            ZLL_EP_MAX_INCLUSTERS,         //  byte  AppNumInClusters;
    142            (cId_t *)zll_EP_InClusterList, //  byte *pAppInClusterList;
    143            ZLL_EP_MAX_OUTCLUSTERS,        //  byte  AppNumInClusters;
    144            (cId_t *)zll_EP_OutClusterList //  byte *pAppInClusterList;
    145          };
    146          
    147          #if defined( INTER_PAN )
    148          // Define endpoint structure to register with STUB APS for INTER-PAN support

   \                                 In  segment XDATA_I, align 1, keep-with-next
    149          static endPointDesc_t zll_EP =
   \                     zll_EP:
   \   000000                DS 6
   \   000006                REQUIRE `?<Initializer for zll_EP>`
   \   000006                REQUIRE __INIT_XDATA_I
    150          {
    151            ZLL_INTERNAL_ENDPOINT,
    152            &zllTaskId,
    153            (SimpleDescriptionFormat_t *)NULL,  // No Simple description for this endpoint
    154            (afNetworkLatencyReq_t)0            // No Network Latency req
    155          };
    156          #endif
    157          
    158          
    159          /*********************************************************************
    160           * LOCAL FUNCTIONS
    161           */
    162          static void zll_BuildAesKey( uint8 *pAesKey, uint32 transID, uint32 responseID, uint8 keyIndex );
    163          static void zll_InitFreeRanges( bool initiator );
    164          void zll_ItemInit( uint16 id, uint16 len, void *pBuf );
    165          static void *zll_BeaconIndCB ( void *param );
    166          static void *zll_NwkDiscoveryCnfCB ( void *param );
    167          static void zll_InitNV( void );
    168          static void zll_SetTCLK( void );
    169          static ZStatus_t zll_ClassicalCommissioningNetworkDisc( void );
    170          
    171          /*********************************************************************
    172           * PUBLIC FUNCTIONS
    173           */
    174          
    175          /*********************************************************************
    176           * @fn      zll_RegisterSimpleDesc
    177           *
    178           * @brief   Register the Simple descriptor with the AF.
    179           *
    180           * @param   simpleDesc - a pointer to a valid SimpleDescriptionFormat_t, must not be NULL.
    181           *
    182           * @return  status
    183           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    184          ZStatus_t zll_RegisterSimpleDesc( SimpleDescriptionFormat_t *simpleDesc )
   \                     zll_RegisterSimpleDesc:
    185          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    186            endPointDesc_t *epDesc;
    187          
    188            // Register the application's endpoint descriptor
    189            //  - This memory is allocated and never freed.
    190            epDesc = osal_mem_alloc( sizeof ( endPointDesc_t ) );
   \   000009                ; Setup parameters for call to function osal_mem_alloc
   \   000009   7A06         MOV     R2,#0x6
   \   00000B   7B00         MOV     R3,#0x0
   \   00000D   12....       LCALL   ??osal_mem_alloc?relay
    191            if ( epDesc )
   \   000010   EA           MOV     A,R2
   \   000011   4B           ORL     A,R3
   \   000012   6022         JZ      ??zll_RegisterSimpleDesc_0
    192            {
    193              // Fill out the endpoint description.
    194              epDesc->endPoint = simpleDesc->EndPoint;
   \   000014   8E82         MOV     DPL,R6
   \   000016   8F83         MOV     DPH,R7
   \   000018   E0           MOVX    A,@DPTR
   \   000019   8A82         MOV     DPL,R2
   \   00001B   8B83         MOV     DPH,R3
   \   00001D   F0           MOVX    @DPTR,A
    195              epDesc->task_id = &zcl_TaskID;   // all messages get sent to ZCL first
   \   00001E   A3           INC     DPTR
   \   00001F   74..         MOV     A,#zcl_TaskID & 0xff
   \   000021   F0           MOVX    @DPTR,A
   \   000022   A3           INC     DPTR
   \   000023   74..         MOV     A,#(zcl_TaskID >> 8) & 0xff
   \   000025   12....       LCALL   ?Subroutine34 & 0xFFFF
    196              epDesc->simpleDesc = simpleDesc;
   \                     ??CrossCallReturnLabel_45:
   \   000028   EE           MOV     A,R6
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   A3           INC     DPTR
   \   00002B   EF           MOV     A,R7
   \   00002C   12....       LCALL   ?Subroutine22 & 0xFFFF
    197              epDesc->latencyReq = noLatencyReqs;
   \                     ??CrossCallReturnLabel_26:
   \   00002F   E4           CLR     A
   \   000030   F0           MOVX    @DPTR,A
    198          
    199              // Register the endpoint description with the AF
    200              return afRegister( epDesc );
   \   000031                ; Setup parameters for call to function afRegister
   \   000031   12....       LCALL   ??afRegister?relay
   \   000034   8002         SJMP    ??zll_RegisterSimpleDesc_1
    201            }
    202            return ZMemError;
   \                     ??zll_RegisterSimpleDesc_0:
   \   000036   7910         MOV     R1,#0x10
   \                     ??zll_RegisterSimpleDesc_1:
   \   000038   02....       LJMP    ??Subroutine36_0 & 0xFFFF
    203          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine36_0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   22           RET
    204          
    205          /*********************************************************************
    206           * @fn      zll_InitVariables
    207           *
    208           * @brief   Initialize the ZLL global and local variables.
    209           *
    210           * @param   initiator - if caller is Initiator
    211           *
    212           * @return  none
    213           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    214          void zll_InitVariables( bool initiator )
   \                     zll_InitVariables:
    215          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    216            zllTransID = 0;
   \   000007   90....       MOV     DPTR,#zllTransID
   \   00000A   E4           CLR     A
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   A3           INC     DPTR
   \   00000D   F0           MOVX    @DPTR,A
   \   00000E   A3           INC     DPTR
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   A3           INC     DPTR
   \   000011   F0           MOVX    @DPTR,A
    217            zllJoinedHANetwork = FALSE;
   \   000012   90....       MOV     DPTR,#zllJoinedHANetwork
   \   000015   F0           MOVX    @DPTR,A
    218            zllIsInitiator = initiator;
   \   000016   EE           MOV     A,R6
   \   000017   90....       MOV     DPTR,#zllIsInitiator
   \   00001A   F0           MOVX    @DPTR,A
    219          
    220            if ( zll_IsFactoryNew() )
   \   00001B                ; Setup parameters for call to function zll_IsFactoryNew
   \   00001B   12....       LCALL   ??zll_IsFactoryNew?relay
   \   00001E   E9           MOV     A,R1
   \   00001F   600A         JZ      ??zll_InitVariables_0
    221            {
    222              _NIB.nwkDevAddress = INVALID_NODE_ADDR;
   \   000021   90....       MOV     DPTR,#_NIB + 20
   \   000024   74FE         MOV     A,#-0x2
   \   000026   F0           MOVX    @DPTR,A
   \   000027   A3           INC     DPTR
   \   000028   04           INC     A
   \   000029   800B         SJMP    ??zll_InitVariables_1
    223            }
    224            else
    225            {
    226              if ( !APSME_IsDistributedSecurity() )
   \                     ??zll_InitVariables_0:
   \   00002B                ; Setup parameters for call to function APSME_IsDistributedSecurity
   \   00002B   12....       LCALL   ??APSME_IsDistributedSecurity?relay
   \   00002E   E9           MOV     A,R1
   \   00002F   7006         JNZ     ??zll_InitVariables_2
    227              {
    228                zllJoinedHANetwork = TRUE;
   \   000031   90....       MOV     DPTR,#zllJoinedHANetwork
   \   000034   7401         MOV     A,#0x1
   \                     ??zll_InitVariables_1:
   \   000036   F0           MOVX    @DPTR,A
    229              }
    230            }
    231          
    232            // verify groups communication is initiated by broadcasts rather than multicasts
    233            _NIB.nwkUseMultiCast = FALSE;
   \                     ??zll_InitVariables_2:
   \   000037   90....       MOV     DPTR,#_NIB + 100
   \   00003A   E4           CLR     A
   \   00003B   F0           MOVX    @DPTR,A
    234            // detect and remove stored deprecated end device children after power up
    235            zgRouterOffAssocCleanup = TRUE;
   \   00003C   90....       MOV     DPTR,#zgRouterOffAssocCleanup
   \   00003F   04           INC     A
   \   000040   F0           MOVX    @DPTR,A
    236            osal_nv_write(ZCD_NV_ROUTER_OFF_ASSOC_CLEANUP, 0, sizeof(zgRouterOffAssocCleanup), &zgRouterOffAssocCleanup);
   \   000041                ; Setup parameters for call to function osal_nv_write
   \   000041   75....       MOV     ?V0 + 0,#zgRouterOffAssocCleanup & 0xff
   \   000044   75....       MOV     ?V0 + 1,#(zgRouterOffAssocCleanup >> 8) & 0xff
   \   000047   78..         MOV     R0,#?V0 + 0
   \   000049   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004C   75..01       MOV     ?V0 + 0,#0x1
   \   00004F   75..00       MOV     ?V0 + 1,#0x0
   \   000052   78..         MOV     R0,#?V0 + 0
   \   000054   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000057   7C00         MOV     R4,#0x0
   \   000059   7D00         MOV     R5,#0x0
   \   00005B   7A3C         MOV     R2,#0x3c
   \   00005D   7B00         MOV     R3,#0x0
   \   00005F   12....       LCALL   ??osal_nv_write?relay
   \   000062   7404         MOV     A,#0x4
   \   000064   12....       LCALL   ?DEALLOC_XSTACK8
    237          
    238            zll_InitFreeRanges( initiator );
   \   000067                ; Setup parameters for call to function zll_InitFreeRanges
   \   000067   EE           MOV     A,R6
   \   000068   F9           MOV     R1,A
   \   000069   12....       LCALL   ??zll_InitFreeRanges?relay
    239          
    240            zll_InitNV();
   \   00006C                ; Setup parameters for call to function zll_ItemInit
   \   00006C   75....       MOV     ?V0 + 0,#zllFreeNwkAddrBegin & 0xff
   \   00006F   75....       MOV     ?V0 + 1,#(zllFreeNwkAddrBegin >> 8) & 0xff
   \   000072   78..         MOV     R0,#?V0 + 0
   \   000074   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000077   7C02         MOV     R4,#0x2
   \   000079   7D00         MOV     R5,#0x0
   \   00007B   7A92         MOV     R2,#-0x6e
   \   00007D   7B00         MOV     R3,#0x0
   \   00007F   12....       LCALL   ??zll_ItemInit?relay
   \   000082   7402         MOV     A,#0x2
   \   000084   12....       LCALL   ?DEALLOC_XSTACK8
   \   000087                ; Setup parameters for call to function zll_ItemInit
   \   000087   75....       MOV     ?V0 + 0,#zllFreeNwkAddrEnd & 0xff
   \   00008A   75....       MOV     ?V0 + 1,#(zllFreeNwkAddrEnd >> 8) & 0xff
   \   00008D   78..         MOV     R0,#?V0 + 0
   \   00008F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000092   7C02         MOV     R4,#0x2
   \   000094   7D00         MOV     R5,#0x0
   \   000096   7A93         MOV     R2,#-0x6d
   \   000098   7B00         MOV     R3,#0x0
   \   00009A   12....       LCALL   ??zll_ItemInit?relay
   \   00009D   7402         MOV     A,#0x2
   \   00009F   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A2                ; Setup parameters for call to function zll_ItemInit
   \   0000A2   75....       MOV     ?V0 + 0,#zllFreeGrpIdBegin & 0xff
   \   0000A5   75....       MOV     ?V0 + 1,#(zllFreeGrpIdBegin >> 8) & 0xff
   \   0000A8   78..         MOV     R0,#?V0 + 0
   \   0000AA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AD   7C02         MOV     R4,#0x2
   \   0000AF   7D00         MOV     R5,#0x0
   \   0000B1   7A94         MOV     R2,#-0x6c
   \   0000B3   7B00         MOV     R3,#0x0
   \   0000B5   12....       LCALL   ??zll_ItemInit?relay
   \   0000B8   7402         MOV     A,#0x2
   \   0000BA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000BD                ; Setup parameters for call to function zll_ItemInit
   \   0000BD   75....       MOV     ?V0 + 0,#zllFreeGrpIdEnd & 0xff
   \   0000C0   75....       MOV     ?V0 + 1,#(zllFreeGrpIdEnd >> 8) & 0xff
   \   0000C3   78..         MOV     R0,#?V0 + 0
   \   0000C5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C8   7C02         MOV     R4,#0x2
   \   0000CA   7D00         MOV     R5,#0x0
   \   0000CC   7A95         MOV     R2,#-0x6b
   \   0000CE   7B00         MOV     R3,#0x0
   \   0000D0   12....       LCALL   ??zll_ItemInit?relay
   \   0000D3   7402         MOV     A,#0x2
   \   0000D5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D8                ; Setup parameters for call to function zll_ItemInit
   \   0000D8   75....       MOV     ?V0 + 0,#zllGrpIDsBegin & 0xff
   \   0000DB   75....       MOV     ?V0 + 1,#(zllGrpIDsBegin >> 8) & 0xff
   \   0000DE   78..         MOV     R0,#?V0 + 0
   \   0000E0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000E3   7C02         MOV     R4,#0x2
   \   0000E5   7D00         MOV     R5,#0x0
   \   0000E7   7A96         MOV     R2,#-0x6a
   \   0000E9   7B00         MOV     R3,#0x0
   \   0000EB   12....       LCALL   ??zll_ItemInit?relay
   \   0000EE   7402         MOV     A,#0x2
   \   0000F0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F3                ; Setup parameters for call to function zll_ItemInit
   \   0000F3   75....       MOV     ?V0 + 0,#zllGrpIDsEnd & 0xff
   \   0000F6   75....       MOV     ?V0 + 1,#(zllGrpIDsEnd >> 8) & 0xff
   \   0000F9   78..         MOV     R0,#?V0 + 0
   \   0000FB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000FE   7C02         MOV     R4,#0x2
   \   000100   7D00         MOV     R5,#0x0
   \   000102   7A97         MOV     R2,#-0x69
   \   000104   7B00         MOV     R3,#0x0
   \   000106   12....       LCALL   ??zll_ItemInit?relay
   \   000109   7402         MOV     A,#0x2
   \   00010B   12....       LCALL   ?DEALLOC_XSTACK8
    241          
    242            zllLeaveInitiated = FALSE;
   \   00010E   90....       MOV     DPTR,#zllLeaveInitiated
   \   000111   E4           CLR     A
   \   000112   F0           MOVX    @DPTR,A
    243            zllHAScanInitiated = FALSE;
   \   000113   90....       MOV     DPTR,#zllHAScanInitiated
   \   000116   F0           MOVX    @DPTR,A
    244          
    245            // Initialize device info table
    246            osal_memset( zllSubDevicesTbl, 0, sizeof( zllSubDevicesTbl ) );
   \   000117                ; Setup parameters for call to function osal_memset
   \   000117   7C0A         MOV     R4,#0xa
   \   000119   FD           MOV     R5,A
   \   00011A   F9           MOV     R1,A
   \   00011B   7A..         MOV     R2,#zllSubDevicesTbl & 0xff
   \   00011D   7B..         MOV     R3,#(zllSubDevicesTbl >> 8) & 0xff
   \   00011F   12....       LCALL   ??osal_memset?relay
    247          
    248            //set ZLL default Link Key
    249            zll_SetTCLK();
   \   000122                ; Setup parameters for call to function zll_SetTCLK
   \   000122   12....       LCALL   ??zll_SetTCLK?relay
    250          
    251            // set broadcast address mask to support broadcast filtering
    252            NLME_SetBroadcastFilter( ZDO_Config_Node_Descriptor.CapabilityFlags );
   \   000125                ; Setup parameters for call to function NLME_SetBroadcastFilter
   \   000125   90....       MOV     DPTR,#ZDO_Config_Node_Descriptor + 2
   \   000128   E0           MOVX    A,@DPTR
   \   000129   F9           MOV     R1,A
   \   00012A   12....       LCALL   ??NLME_SetBroadcastFilter?relay
    253          }
   \   00012D   02....       LJMP    ??Subroutine36_0 & 0xFFFF
    254          
    255          /*********************************************************************
    256           * @fn      zll_InitFreeRanges
    257           *
    258           * @brief   Initialize the ZLL free range global variables.
    259           *
    260           * @param   initiator - if caller is link initiator
    261           *
    262           * @return  none
    263           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    264          static void zll_InitFreeRanges( bool initiator )
   \                     zll_InitFreeRanges:
    265          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    266            // Initialize our free network address and group ID ranges
    267            if ( initiator )
   \   000004   E9           MOV     A,R1
   \   000005   6026         JZ      ??zll_InitFreeRanges_0
    268            {
    269              zllFreeNwkAddrBegin = ZLL_ADDR_MIN;
   \   000007   90....       MOV     DPTR,#zllFreeNwkAddrBegin
   \   00000A   7401         MOV     A,#0x1
   \   00000C   F0           MOVX    @DPTR,A
   \   00000D   A3           INC     DPTR
   \   00000E   E4           CLR     A
   \   00000F   F0           MOVX    @DPTR,A
    270              zllFreeNwkAddrEnd = ZLL_ADDR_MAX;
   \   000010   90....       MOV     DPTR,#zllFreeNwkAddrEnd
   \   000013   74F7         MOV     A,#-0x9
   \   000015   F0           MOVX    @DPTR,A
   \   000016   A3           INC     DPTR
   \   000017   74FF         MOV     A,#-0x1
   \   000019   F0           MOVX    @DPTR,A
    271          
    272              zllFreeGrpIdBegin = ZLL_GRP_ID_MIN;
   \   00001A   90....       MOV     DPTR,#zllFreeGrpIdBegin
   \   00001D   7401         MOV     A,#0x1
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   A3           INC     DPTR
   \   000021   E4           CLR     A
   \   000022   F0           MOVX    @DPTR,A
    273              zllFreeGrpIdEnd = ZLL_GRP_ID_MAX;
   \   000023   90....       MOV     DPTR,#zllFreeGrpIdEnd
   \   000026   74FF         MOV     A,#-0x1
   \   000028   F0           MOVX    @DPTR,A
   \   000029   A3           INC     DPTR
   \   00002A   14           DEC     A
   \   00002B   800D         SJMP    ??CrossCallReturnLabel_32
    274            }
    275            else
    276            {
    277              zllFreeNwkAddrBegin = zllFreeNwkAddrEnd = 0;
   \                     ??zll_InitFreeRanges_0:
   \   00002D   90....       MOV     DPTR,#zllFreeNwkAddrEnd
   \   000030   E4           CLR     A
   \   000031   12....       LCALL   ?Subroutine23 & 0xFFFF
    278              zllFreeGrpIdBegin = zllFreeGrpIdEnd = 0;
   \                     ??CrossCallReturnLabel_28:
   \   000034   90....       MOV     DPTR,#zllFreeGrpIdEnd
   \   000037   12....       LCALL   ?Subroutine25 & 0xFFFF
    279            }
   \                     ??CrossCallReturnLabel_32:
   \   00003A   F0           MOVX    @DPTR,A
    280          
    281            // Initialize our local group ID range
    282            zllGrpIDsBegin = zllGrpIDsEnd = 0;
   \   00003B   90....       MOV     DPTR,#zllGrpIDsEnd
   \   00003E   E4           CLR     A
   \   00003F   F0           MOVX    @DPTR,A
   \   000040   A3           INC     DPTR
   \   000041   F0           MOVX    @DPTR,A
   \   000042   90....       MOV     DPTR,#zllGrpIDsBegin
   \   000045   F0           MOVX    @DPTR,A
   \   000046   A3           INC     DPTR
   \   000047   F0           MOVX    @DPTR,A
    283          }
   \   000048   02....       LJMP    ??Subroutine39_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine39_0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   F0           MOVX    @DPTR,A
   \   000003   90....       MOV     DPTR,#zllFreeGrpIdBegin
   \   000006   F0           MOVX    @DPTR,A
   \   000007   A3           INC     DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   F0           MOVX    @DPTR,A
   \   000003   90....       MOV     DPTR,#zllFreeNwkAddrBegin
   \   000006   F0           MOVX    @DPTR,A
   \   000007   A3           INC     DPTR
   \   000008   F0           MOVX    @DPTR,A
   \   000009   22           RET
    284          
    285          /*********************************************************************
    286           * @fn      zll_RegisterApp
    287           *
    288           * @brief   Register an Application's EndPoint with the ZLL.
    289           *
    290           * @param   simpleDesc - application simple description
    291           * @param   numGrpIDs - number of unique group IDs required by application
    292           *
    293           * @return  ZSuccess - Registered
    294           *          ZInvalidParameter - invalid or duplicate endpoint
    295           *          ZMemError - not enough memory to add
    296           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    297          ZStatus_t zll_RegisterApp( SimpleDescriptionFormat_t *simpleDesc, zclLLDeviceInfo_t *pDeviceInfo )
   \                     zll_RegisterApp:
    298          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   8C..         MOV     ?V0 + 0,R4
   \   000007   8D..         MOV     ?V0 + 1,R5
    299            zclLLDeviceInfo_t **pSubDevice = NULL;
    300            ZStatus_t status;
    301          
    302            // Make sure the endpoint is valid
    303            if ( ( simpleDesc->EndPoint != pDeviceInfo->endpoint ) || ( pDeviceInfo->profileID != ZLL_PROFILE_ID ) )
   \   000009   8A82         MOV     DPL,R2
   \   00000B   8B83         MOV     DPH,R3
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F8           MOV     R0,A
   \   00000F   8C82         MOV     DPL,R4
   \   000011   8D83         MOV     DPH,R5
   \   000013   E0           MOVX    A,@DPTR
   \   000014   68           XRL     A,R0
   \   000015   700C         JNZ     ??zll_RegisterApp_0
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   645E         XRL     A,#0x5e
   \   00001B   7004         JNZ     ??zll_RegisterApp_1
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   64C0         XRL     A,#0xc0
   \                     ??zll_RegisterApp_1:
   \   000021   6004         JZ      ??zll_RegisterApp_2
    304            {
    305              return ( ZInvalidParameter ); // invalid endpoint
   \                     ??zll_RegisterApp_0:
   \   000023   7902         MOV     R1,#0x2
   \   000025   8033         SJMP    ??zll_RegisterApp_3
    306            }
    307          
    308            // find the first empty entry in the device info table
    309            for ( uint8 i = 0; i < ZLL_NUM_DEVICE_INFO_ENTRIES; i++ )
   \                     ??zll_RegisterApp_2:
   \   000027   7E00         MOV     R6,#0x0
    310            {
    311              if ( zllSubDevicesTbl[i] == NULL )
   \                     ??zll_RegisterApp_4:
   \   000029   EE           MOV     A,R6
   \   00002A   C3           CLR     C
   \   00002B   33           RLC     A
   \   00002C   F8           MOV     R0,A
   \   00002D   E4           CLR     A
   \   00002E   33           RLC     A
   \   00002F   F9           MOV     R1,A
   \   000030   74..         MOV     A,#zllSubDevicesTbl & 0xff
   \   000032   28           ADD     A,R0
   \   000033   F8           MOV     R0,A
   \   000034   74..         MOV     A,#(zllSubDevicesTbl >> 8) & 0xff
   \   000036   39           ADDC    A,R1
   \   000037   F9           MOV     R1,A
   \   000038   8882         MOV     DPL,R0
   \   00003A   8983         MOV     DPH,R1
   \   00003C   12....       LCALL   ??Subroutine44_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_105:
   \   00003F   EC           MOV     A,R4
   \   000040   4D           ORL     A,R5
   \   000041   701A         JNZ     ??zll_RegisterApp_5
    312              {
    313                 pSubDevice = zllSubDevicesTbl+i;
   \   000043   E8           MOV     A,R0
   \   000044   FE           MOV     R6,A
   \   000045   E9           MOV     A,R1
   \   000046   FF           MOV     R7,A
    314                 break;
    315              }
    316            }
    317            if ( pSubDevice == NULL )
    318            {
    319              // Device info table is full
    320              return ( ZMemError );
    321            }
    322          
    323            status = zll_RegisterSimpleDesc( simpleDesc );
   \   000047                ; Setup parameters for call to function zll_RegisterSimpleDesc
   \   000047   12....       LCALL   ??zll_RegisterSimpleDesc?relay
   \   00004A   E9           MOV     A,R1
    324            if ( status != ZSuccess )
   \   00004B   700D         JNZ     ??zll_RegisterApp_3
    325            {
    326              return status;
    327            }
    328          
    329            // Add the device info to the table
    330            *pSubDevice = pDeviceInfo;
   \   00004D   8E82         MOV     DPL,R6
   \   00004F   8F83         MOV     DPH,R7
   \   000051   E5..         MOV     A,?V0 + 0
   \   000053   F0           MOVX    @DPTR,A
   \   000054   A3           INC     DPTR
   \   000055   E5..         MOV     A,?V0 + 1
   \   000057   F0           MOVX    @DPTR,A
    331          
    332            return ( ZSuccess );
   \   000058   7900         MOV     R1,#0x0
   \                     ??zll_RegisterApp_3:
   \   00005A   02....       LJMP    ??Subroutine36_0 & 0xFFFF
   \                     ??zll_RegisterApp_5:
   \   00005D   0E           INC     R6
   \   00005E   EE           MOV     A,R6
   \   00005F   C3           CLR     C
   \   000060   9405         SUBB    A,#0x5
   \   000062   40C5         JC      ??zll_RegisterApp_4
   \   000064   7910         MOV     R1,#0x10
   \   000066   80F2         SJMP    ??zll_RegisterApp_3
    333          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine44_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   22           RET
    334          
    335          /*********************************************************************
    336           * @fn      zll_IsFactoryNew
    337           *
    338           * @brief   Check to see if the device is factory new.
    339           *
    340           * @param   none
    341           *
    342           * @return  TRUE if factory new. FALSE, otherwise.
    343           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    344          bool zll_IsFactoryNew( void )
   \                     zll_IsFactoryNew:
    345          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    346            uint16 nwkAddr = INVALID_NODE_ADDR;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   12....       LCALL   ?Subroutine26 & 0xFFFF
    347          
    348            osal_nv_read( ZCD_NV_NIB, osal_offsetof( nwkIB_t, nwkDevAddress ),
    349                          sizeof( uint16), &nwkAddr );
   \                     ??CrossCallReturnLabel_49:
   \   000013                ; Setup parameters for call to function osal_nv_read
   \   000013   85..82       MOV     DPL,?XSP + 0
   \   000016   85..83       MOV     DPH,?XSP + 1
   \   000019   8582..       MOV     ?V0 + 0,DPL
   \   00001C   8583..       MOV     ?V0 + 1,DPH
   \   00001F   78..         MOV     R0,#?V0 + 0
   \   000021   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000024   75..02       MOV     ?V0 + 0,#0x2
   \   000027   75..00       MOV     ?V0 + 1,#0x0
   \   00002A   78..         MOV     R0,#?V0 + 0
   \   00002C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002F   7C14         MOV     R4,#0x14
   \   000031   7D00         MOV     R5,#0x0
   \   000033   7A21         MOV     R2,#0x21
   \   000035   7B00         MOV     R3,#0x0
   \   000037   12....       LCALL   ??osal_nv_read?relay
   \   00003A   7404         MOV     A,#0x4
   \   00003C   12....       LCALL   ?DEALLOC_XSTACK8
    350          
    351            // Does the NIB have anything more than default?
    352            return ( nwkAddr == INVALID_NODE_ADDR ? TRUE : FALSE );
   \   00003F   85..82       MOV     DPL,?XSP + 0
   \   000042   85..83       MOV     DPH,?XSP + 1
   \   000045   E0           MOVX    A,@DPTR
   \   000046   64FE         XRL     A,#0xfe
   \   000048   7003         JNZ     ??zll_IsFactoryNew_0
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   F4           CPL     A
   \                     ??zll_IsFactoryNew_0:
   \   00004D   7004         JNZ     ??zll_IsFactoryNew_1
   \   00004F   7901         MOV     R1,#0x1
   \   000051   8002         SJMP    ??zll_IsFactoryNew_2
   \                     ??zll_IsFactoryNew_1:
   \   000053   7900         MOV     R1,#0x0
   \                     ??zll_IsFactoryNew_2:
   \   000055   7402         MOV     A,#0x2
   \   000057   02....       LJMP    ?Subroutine0 & 0xFFFF
    353          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   74FE         MOV     A,#-0x2
   \   000002                REQUIRE ??Subroutine35_0
   \   000002                ; // Fall through to label ??Subroutine35_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine35_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   04           INC     A
   \   000003   F0           MOVX    @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine36_0
   \   000003                ; // Fall through to label ??Subroutine36_0
    354          
    355          /*********************************************************************
    356           * @fn      zll_UpdateFreeRanges
    357           *
    358           * @brief   Update the ZLL free range global variables.
    359           *
    360           * @param   pParams - new parameters
    361           *
    362           * @return  none
    363           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    364          void zll_UpdateFreeRanges( zclLLNwkParams_t *pParams )
   \                     zll_UpdateFreeRanges:
    365          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    366            // Set our free network address and group ID ranges
    367            zllFreeNwkAddrBegin = pParams->freeNwkAddrBegin;
   \   000004   EA           MOV     A,R2
   \   000005   2422         ADD     A,#0x22
   \   000007   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   00000A   90....       MOV     DPTR,#zllFreeNwkAddrBegin
   \   00000D   12....       LCALL   ?Subroutine18 & 0xFFFF
    368            zllFreeNwkAddrEnd = pParams->freeNwkAddrEnd;
   \                     ??CrossCallReturnLabel_17:
   \   000010   2424         ADD     A,#0x24
   \   000012   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   000015   90....       MOV     DPTR,#zllFreeNwkAddrEnd
   \   000018   12....       LCALL   ?Subroutine18 & 0xFFFF
    369            zllFreeGrpIdBegin = pParams->freeGrpIDBegin;
   \                     ??CrossCallReturnLabel_18:
   \   00001B   2426         ADD     A,#0x26
   \   00001D   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   000020   90....       MOV     DPTR,#zllFreeGrpIdBegin
   \   000023   12....       LCALL   ?Subroutine18 & 0xFFFF
    370            zllFreeGrpIdEnd = pParams->freeGrpIDEnd;
   \                     ??CrossCallReturnLabel_19:
   \   000026   2428         ADD     A,#0x28
   \   000028   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   00002B   90....       MOV     DPTR,#zllFreeGrpIdEnd
   \   00002E   12....       LCALL   ?Subroutine18 & 0xFFFF
    371          
    372            // Set our group ID range
    373            zllGrpIDsBegin = pParams->grpIDsBegin;
   \                     ??CrossCallReturnLabel_20:
   \   000031   241E         ADD     A,#0x1e
   \   000033   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   000036   90....       MOV     DPTR,#zllGrpIDsBegin
   \   000039   12....       LCALL   ?Subroutine18 & 0xFFFF
    374            zllGrpIDsEnd = pParams->grpIDsEnd;
   \                     ??CrossCallReturnLabel_21:
   \   00003C   2420         ADD     A,#0x20
   \   00003E   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   000041   90....       MOV     DPTR,#zllGrpIDsEnd
   \   000044   12....       LCALL   ?Subroutine19 & 0xFFFF
    375          }
   \                     ??CrossCallReturnLabel_56:
   \   000047   02....       LJMP    ??Subroutine39_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   EA           MOV     A,R2
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   E8           MOV     A,R0
   \   000001                REQUIRE ??Subroutine37_0
   \   000001                ; // Fall through to label ??Subroutine37_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine37_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   F582         MOV     DPL,A
   \   000002   EB           MOV     A,R3
   \   000003   3400         ADDC    A,#0x0
   \   000005                REQUIRE ??Subroutine42_0
   \   000005                ; // Fall through to label ??Subroutine42_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine42_0:
   \   000000   F583         MOV     DPH,A
   \   000002                REQUIRE ??Subroutine43_0
   \   000002                ; // Fall through to label ??Subroutine43_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine43_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET
    376          
    377          /*********************************************************************
    378           * @fn      zll_IsValidSplitFreeRanges
    379           *
    380           * @brief   Checks to see if the resulting two ranges are not smaller
    381           *          than the threshold after division of a network address or
    382           *          group ID range. The Initiator splits its own free range
    383           *          in half and assigns the top half to the new device.
    384           *
    385           *          Note: A range (Nmin...Nmax) is split as follows:
    386           *
    387           *                N'min = (Nmax + Nmin + 1)/2
    388           *                N'max = Nmax
    389           *                Nmax = N'min - 1
    390           *
    391           * @param   totalGrpIDs - total number of group IDs needed
    392           *
    393           * @return  TRUE if split possible. FALSE, otherwise.
    394           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    395          bool zll_IsValidSplitFreeRanges( uint8 totalGrpIDs )
   \                     zll_IsValidSplitFreeRanges:
    396          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FA           MOV     R2,A
    397            if ( ( zllFreeNwkAddrBegin != 0 ) && ( zllFreeGrpIdBegin != 0 ) )
   \   000007   90....       MOV     DPTR,#zllFreeNwkAddrBegin
   \   00000A   12....       LCALL   ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_116:
   \   00000D   6054         JZ      ??zll_IsValidSplitFreeRanges_0
   \   00000F   90....       MOV     DPTR,#zllFreeGrpIdBegin
   \   000012   12....       LCALL   ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_117:
   \   000015   604C         JZ      ??zll_IsValidSplitFreeRanges_0
    398            {
    399                return ( ( ( ( zllFreeNwkAddrEnd - zllFreeNwkAddrBegin ) / 2 ) >= ZLL_ADDR_THRESHOLD ) &&
    400                         ( ( ( zllFreeGrpIdEnd - ( zllFreeGrpIdBegin + totalGrpIDs - 1 ) ) / 2 ) >= ZLL_GRP_ID_THRESHOLD ) );
   \   000017   90....       MOV     DPTR,#zllFreeNwkAddrBegin
   \   00001A   12....       LCALL   ??Subroutine43_0 & 0xFFFF
    401          
    402            }
   \                     ??CrossCallReturnLabel_92:
   \   00001D   7583..       MOV     DPH,#(zllFreeNwkAddrEnd >> 8) & 0xff
   \   000020   7582..       MOV     DPL,#zllFreeNwkAddrEnd & 0xff
   \   000023   E0           MOVX    A,@DPTR
   \   000024   C3           CLR     C
   \   000025   98           SUBB    A,R0
   \   000026   F8           MOV     R0,A
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   99           SUBB    A,R1
   \   00002A   C3           CLR     C
   \   00002B   13           RRC     A
   \   00002C   F9           MOV     R1,A
   \   00002D   E8           MOV     A,R0
   \   00002E   13           RRC     A
   \   00002F   C3           CLR     C
   \   000030   940A         SUBB    A,#0xa
   \   000032   E9           MOV     A,R1
   \   000033   9400         SUBB    A,#0x0
   \   000035   402C         JC      ??zll_IsValidSplitFreeRanges_0
   \   000037   90....       MOV     DPTR,#zllFreeGrpIdBegin
   \   00003A   12....       LCALL   ??Subroutine43_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   00003D   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000040   8A..         MOV     ?V0 + 0,R2
   \   000042   E8           MOV     A,R0
   \   000043   C3           CLR     C
   \   000044   95..         SUBB    A,?V0 + 0
   \   000046   F8           MOV     R0,A
   \   000047   E9           MOV     A,R1
   \   000048   9400         SUBB    A,#0x0
   \   00004A   F9           MOV     R1,A
   \   00004B   E8           MOV     A,R0
   \   00004C   2401         ADD     A,#0x1
   \   00004E   08           INC     R0
   \   00004F   E9           MOV     A,R1
   \   000050   3400         ADDC    A,#0x0
   \   000052   C3           CLR     C
   \   000053   13           RRC     A
   \   000054   F9           MOV     R1,A
   \   000055   E8           MOV     A,R0
   \   000056   13           RRC     A
   \   000057   C3           CLR     C
   \   000058   940A         SUBB    A,#0xa
   \   00005A   E9           MOV     A,R1
   \   00005B   9400         SUBB    A,#0x0
   \   00005D   4004         JC      ??zll_IsValidSplitFreeRanges_0
   \   00005F   7901         MOV     R1,#0x1
   \   000061   8002         SJMP    ??zll_IsValidSplitFreeRanges_1
    403          
    404            return ( FALSE );
   \                     ??zll_IsValidSplitFreeRanges_0:
   \   000063   7900         MOV     R1,#0x0
   \                     ??zll_IsValidSplitFreeRanges_1:
   \   000065   80..         SJMP    ??Subroutine36_0
    405          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   7583..       MOV     DPH,#(zllFreeGrpIdEnd >> 8) & 0xff
   \   000003   7582..       MOV     DPL,#zllFreeGrpIdEnd & 0xff
   \   000006   E0           MOVX    A,@DPTR
   \   000007   C3           CLR     C
   \   000008   98           SUBB    A,R0
   \   000009   F8           MOV     R0,A
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   99           SUBB    A,R1
   \   00000D   F9           MOV     R1,A
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine46_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   E8           MOV     A,R0
   \   000006   49           ORL     A,R1
   \   000007   22           RET
    406          
    407          /*********************************************************************
    408           * @fn      zll_SplitFreeRanges
    409           *
    410           * @brief   Split our own free network address and group ID ranges
    411           *          in half and assign the top half to the new device.
    412           *
    413           *          Note: A range (Nmin...Nmax) is split as follows:
    414           *
    415           *                N'min = (Nmax + Nmin + 1)/2
    416           *                N'max = Nmax
    417           *                Nmax = N'min - 1
    418           *
    419           * output parameters
    420           *
    421           * @param   pAddrBegin - new address range begin
    422           * @param   pAddrEnd - new address range end
    423           * @param   pGrpIdBegin - new group id range begin
    424           * @param   pGrpIdEnd - new group id range end
    425           *
    426           * @return  none
    427           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    428          void zll_SplitFreeRanges( uint16 *pAddrBegin, uint16 *pAddrEnd,
   \                     zll_SplitFreeRanges:
    429                                  uint16 *pGrpIdBegin, uint16 *pGrpIdEnd )
    430          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 0
   \   000005   8C..         MOV     ?V0 + 8,R4
   \   000007   8D..         MOV     ?V0 + 9,R5
   \   000009   7412         MOV     A,#0x12
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   12....       LCALL   ??Subroutine44_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_106:
   \   000011   7414         MOV     A,#0x14
   \   000013   12....       LCALL   ?XSTACK_DISP0_8
   \   000016   12....       LCALL   ?Subroutine14 & 0xFFFF
    431            if ( ( zllFreeNwkAddrBegin != 0 ) && ( zllFreeGrpIdBegin != 0 ) )
   \                     ??CrossCallReturnLabel_7:
   \   000019   90....       MOV     DPTR,#zllFreeNwkAddrBegin
   \   00001C   12....       LCALL   ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   00001F   7003         JNZ     $+5
   \   000021   02....       LJMP    ??zll_SplitFreeRanges_0 & 0xFFFF
   \   000024   90....       MOV     DPTR,#zllFreeGrpIdBegin
   \   000027   12....       LCALL   ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_119:
   \   00002A   7003         JNZ     $+5
   \   00002C   02....       LJMP    ??zll_SplitFreeRanges_0 & 0xFFFF
    432            {
    433              *pAddrBegin = ZLL_NEW_MIN( zllFreeNwkAddrBegin, zllFreeNwkAddrEnd );
   \   00002F   90....       MOV     DPTR,#zllFreeNwkAddrEnd
   \   000032   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000035   90....       MOV     DPTR,#zllFreeNwkAddrBegin
   \   000038   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   00003B   E4           CLR     A
   \   00003C   F5..         MOV     ?V0 + 2,A
   \   00003E   F5..         MOV     ?V0 + 3,A
   \   000040   78..         MOV     R0,#?V0 + 4
   \   000042   79..         MOV     R1,#?V0 + 0
   \   000044   12....       LCALL   ?L_ADD
   \   000047   90....       MOV     DPTR,#__Constant_1
   \   00004A   78..         MOV     R0,#?V0 + 4
   \   00004C   12....       LCALL   ?L_ADD_X
   \   00004F   7401         MOV     A,#0x1
   \   000051   78..         MOV     R0,#?V0 + 4
   \   000053   12....       LCALL   ?UL_SHR
   \   000056   8A82         MOV     DPL,R2
   \   000058   8B83         MOV     DPH,R3
   \   00005A   E5..         MOV     A,?V0 + 4
   \   00005C   F0           MOVX    @DPTR,A
   \   00005D   A3           INC     DPTR
   \   00005E   E5..         MOV     A,?V0 + 5
   \   000060   F0           MOVX    @DPTR,A
    434              *pGrpIdBegin = ZLL_NEW_MIN( zllFreeGrpIdBegin, zllFreeGrpIdEnd );
   \   000061   90....       MOV     DPTR,#zllFreeGrpIdEnd
   \   000064   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000067   90....       MOV     DPTR,#zllFreeGrpIdBegin
   \   00006A   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   00006D   78..         MOV     R0,#?V0 + 4
   \   00006F   79..         MOV     R1,#?V0 + 0
   \   000071   12....       LCALL   ?L_ADD
   \   000074   90....       MOV     DPTR,#__Constant_1
   \   000077   78..         MOV     R0,#?V0 + 4
   \   000079   12....       LCALL   ?L_ADD_X
   \   00007C   7401         MOV     A,#0x1
   \   00007E   78..         MOV     R0,#?V0 + 4
   \   000080   12....       LCALL   ?UL_SHR
   \   000083   8C82         MOV     DPL,R4
   \   000085   8D83         MOV     DPH,R5
   \   000087   E5..         MOV     A,?V0 + 4
   \   000089   F0           MOVX    @DPTR,A
   \   00008A   A3           INC     DPTR
   \   00008B   E5..         MOV     A,?V0 + 5
   \   00008D   F0           MOVX    @DPTR,A
    435          
    436              *pAddrEnd = zllFreeNwkAddrEnd;
   \   00008E   90....       MOV     DPTR,#zllFreeNwkAddrEnd
   \   000091   12....       LCALL   ??Subroutine43_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   000094   85..82       MOV     DPL,?V0 + 8
   \   000097   85..83       MOV     DPH,?V0 + 9
   \   00009A   12....       LCALL   ?Subroutine19 & 0xFFFF
    437              *pGrpIdEnd = zllFreeGrpIdEnd;
   \                     ??CrossCallReturnLabel_57:
   \   00009D   90....       MOV     DPTR,#zllFreeGrpIdEnd
   \   0000A0   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   0000A3   12....       LCALL   ?Subroutine19 & 0xFFFF
    438          
    439              // Update our max
    440              zllFreeNwkAddrEnd = *pAddrBegin - 1;
   \                     ??CrossCallReturnLabel_58:
   \   0000A6   8A82         MOV     DPL,R2
   \   0000A8   8B83         MOV     DPH,R3
   \   0000AA   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   0000AD   90....       MOV     DPTR,#zllFreeNwkAddrEnd
   \   0000B0   12....       LCALL   ?Subroutine19 & 0xFFFF
    441              zllFreeGrpIdEnd = *pGrpIdBegin - 1;
   \                     ??CrossCallReturnLabel_59:
   \   0000B3   8C82         MOV     DPL,R4
   \   0000B5   8D83         MOV     DPH,R5
   \   0000B7   12....       LCALL   ?Subroutine9 & 0xFFFF
    442            }
   \                     ??CrossCallReturnLabel_1:
   \   0000BA   90....       MOV     DPTR,#zllFreeGrpIdEnd
   \   0000BD   E8           MOV     A,R0
   \   0000BE   F0           MOVX    @DPTR,A
   \   0000BF   A3           INC     DPTR
   \   0000C0   E9           MOV     A,R1
   \   0000C1   8017         SJMP    ??zll_SplitFreeRanges_1
    443            else
    444            {
    445              *pAddrBegin = *pAddrEnd = 0;
   \                     ??zll_SplitFreeRanges_0:
   \   0000C3   85..82       MOV     DPL,?V0 + 8
   \   0000C6   85..83       MOV     DPH,?V0 + 9
   \   0000C9   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   0000CC   F0           MOVX    @DPTR,A
    446              *pGrpIdBegin = *pGrpIdEnd = 0;
   \   0000CD   8E82         MOV     DPL,R6
   \   0000CF   8F83         MOV     DPH,R7
   \   0000D1   F0           MOVX    @DPTR,A
   \   0000D2   A3           INC     DPTR
   \   0000D3   F0           MOVX    @DPTR,A
   \   0000D4   8C82         MOV     DPL,R4
   \   0000D6   8D83         MOV     DPH,R5
   \   0000D8   F0           MOVX    @DPTR,A
   \   0000D9   A3           INC     DPTR
   \                     ??zll_SplitFreeRanges_1:
   \   0000DA   F0           MOVX    @DPTR,A
    447            }
    448          }
   \   0000DB   7F0A         MOV     R7,#0xa
   \   0000DD   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 5,A
   \   000007   E4           CLR     A
   \   000008   F5..         MOV     ?V0 + 6,A
   \   00000A   F5..         MOV     ?V0 + 7,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   E4           CLR     A
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   F0           MOVX    @DPTR,A
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   24FF         ADD     A,#-0x1
   \   000003   F8           MOV     R0,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   34FF         ADDC    A,#-0x1
   \   000008   F9           MOV     R1,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FE           MOV     R6,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FF           MOV     R7,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   8E82         MOV     DPL,R6
   \   000007   8F83         MOV     DPH,R7
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 1,A
   \   000007   22           RET
    449          
    450          /*********************************************************************
    451           * @fn      zll_PopGrpIDRange
    452           *
    453           * @brief   Pop the requested number of group IDs out of the free group IDs range.
    454           *
    455           * input parameters
    456           *
    457           * @param   numGrpIDs - number of group IDs needed
    458           *
    459           * output parameters
    460           *
    461           * @param   pGrpIdBegin - new group id range begin, or 0 if unavaialable
    462           * @param   pGrpIdEnd - new group id range end, , or 0 if unavaialable
    463           *
    464           * @return  none
    465           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    466          void zll_PopGrpIDRange( uint8 numGrpIDs, uint16 *pGrpIDsBegin, uint16 *pGrpIDsEnd )
   \                     zll_PopGrpIDRange:
    467          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
    468            if ( ( zllFreeGrpIdBegin != 0 )
    469                 && ( zllFreeGrpIdBegin <= zllFreeGrpIdEnd )
    470                 && ( ( zllFreeGrpIdEnd - zllFreeGrpIdBegin ) >= numGrpIDs ) )
   \   000007   90....       MOV     DPTR,#zllFreeGrpIdBegin
   \   00000A   12....       LCALL   ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   00000D   6048         JZ      ??zll_PopGrpIDRange_0
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F9           MOV     R1,A
   \   000011   7583..       MOV     DPH,#(zllFreeGrpIdEnd >> 8) & 0xff
   \   000014   7582..       MOV     DPL,#zllFreeGrpIdEnd & 0xff
   \   000017   C3           CLR     C
   \   000018   E0           MOVX    A,@DPTR
   \   000019   98           SUBB    A,R0
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   99           SUBB    A,R1
   \   00001D   4038         JC      ??zll_PopGrpIDRange_0
   \   00001F   85..82       MOV     DPL,?V0 + 0
   \   000022   AE82         MOV     R6,DPL
   \   000024   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   000027   C3           CLR     C
   \   000028   E8           MOV     A,R0
   \   000029   9E           SUBB    A,R6
   \   00002A   E9           MOV     A,R1
   \   00002B   9400         SUBB    A,#0x0
   \   00002D   4028         JC      ??zll_PopGrpIDRange_0
    471            {
    472              *pGrpIDsBegin = zllFreeGrpIdBegin;
   \   00002F   90....       MOV     DPTR,#zllFreeGrpIdBegin
   \   000032   12....       LCALL   ??Subroutine43_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   000035   8A82         MOV     DPL,R2
   \   000037   8B83         MOV     DPH,R3
   \   000039   12....       LCALL   ?Subroutine19 & 0xFFFF
    473          
    474              // Update min free group id
    475              zllFreeGrpIdBegin += numGrpIDs;
   \                     ??CrossCallReturnLabel_60:
   \   00003C   90....       MOV     DPTR,#zllFreeGrpIdBegin
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   2E           ADD     A,R6
   \   000041   F0           MOVX    @DPTR,A
   \   000042   A3           INC     DPTR
   \   000043   E0           MOVX    A,@DPTR
   \   000044   3400         ADDC    A,#0x0
   \   000046   F0           MOVX    @DPTR,A
    476          
    477              *pGrpIDsEnd = zllFreeGrpIdBegin - 1;
   \   000047   90....       MOV     DPTR,#zllFreeGrpIdBegin
   \   00004A   12....       LCALL   ?Subroutine9 & 0xFFFF
    478            }
   \                     ??CrossCallReturnLabel_2:
   \   00004D   8C82         MOV     DPL,R4
   \   00004F   8D83         MOV     DPH,R5
   \   000051   E8           MOV     A,R0
   \   000052   F0           MOVX    @DPTR,A
   \   000053   A3           INC     DPTR
   \   000054   E9           MOV     A,R1
   \   000055   8007         SJMP    ??CrossCallReturnLabel_31
    479            else
    480            {
    481              *pGrpIDsBegin = *pGrpIDsEnd = 0;
   \                     ??zll_PopGrpIDRange_0:
   \   000057   8C82         MOV     DPL,R4
   \   000059   8D83         MOV     DPH,R5
   \   00005B   12....       LCALL   ?Subroutine24 & 0xFFFF
    482            }
   \                     ??CrossCallReturnLabel_31:
   \   00005E   F0           MOVX    @DPTR,A
    483          }
   \   00005F   02....       LJMP    ??Subroutine36_0 & 0xFFFF
    484          
    485          /*********************************************************************
    486           * @fn      zll_PopNwkAddress
    487           *
    488           * @brief   Pop an avaialble short address out of the free network addresses range.
    489           *
    490           * @param   none
    491           *
    492           * @return  free address if available. 0, otherwise.
    493           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    494          uint16 zll_PopNwkAddress( void )
   \                     zll_PopNwkAddress:
    495          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    496            if ( ( zllFreeNwkAddrBegin == 0 ) || ( zllFreeNwkAddrBegin > zllFreeNwkAddrEnd ) )
   \   000004   90....       MOV     DPTR,#zllFreeNwkAddrBegin
   \   000007   12....       LCALL   ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_121:
   \   00000A   600E         JZ      ??zll_PopNwkAddress_0
   \   00000C   7583..       MOV     DPH,#(zllFreeNwkAddrEnd >> 8) & 0xff
   \   00000F   7582..       MOV     DPL,#zllFreeNwkAddrEnd & 0xff
   \   000012   C3           CLR     C
   \   000013   E0           MOVX    A,@DPTR
   \   000014   98           SUBB    A,R0
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   99           SUBB    A,R1
   \   000018   5006         JNC     ??zll_PopNwkAddress_1
    497            {
    498              return ( 0 );
   \                     ??zll_PopNwkAddress_0:
   \   00001A   7A00         MOV     R2,#0x0
   \   00001C   7B00         MOV     R3,#0x0
   \   00001E   8014         SJMP    ??CrossCallReturnLabel_61
    499            }
    500          
    501            return ( zllFreeNwkAddrBegin++ );
   \                     ??zll_PopNwkAddress_1:
   \   000020   90....       MOV     DPTR,#zllFreeNwkAddrBegin
   \   000023   12....       LCALL   ??Subroutine38_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   000026   EA           MOV     A,R2
   \   000027   2401         ADD     A,#0x1
   \   000029   08           INC     R0
   \   00002A   EB           MOV     A,R3
   \   00002B   3400         ADDC    A,#0x0
   \   00002D   F9           MOV     R1,A
   \   00002E   90....       MOV     DPTR,#zllFreeNwkAddrBegin
   \   000031   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   000034   80..         SJMP    ??Subroutine39_0
    502          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine38_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
    503          
    504          /*********************************************************************
    505           * @fn      zll_GetNumSubDevices
    506           *
    507           * @brief   Get the total number of sub-devices (endpoints) registered.
    508           *
    509           * @param   startIndex - starting index
    510           *
    511           * @return  number of sub-devices
    512           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    513          uint8 zll_GetNumSubDevices( uint8 startIndex )
   \                     zll_GetNumSubDevices:
    514          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
    515            uint8 numEPs = 0;
   \   000005   7900         MOV     R1,#0x0
    516          
    517            for ( uint8 i = startIndex; i < ZLL_NUM_DEVICE_INFO_ENTRIES; i++ )
   \   000007   F8           MOV     R0,A
   \   000008   8009         SJMP    ??zll_GetNumSubDevices_0
    518            {
    519              if ( zllSubDevicesTbl[i] != NULL )
   \                     ??zll_GetNumSubDevices_1:
   \   00000A   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   00000D   EA           MOV     A,R2
   \   00000E   4B           ORL     A,R3
   \   00000F   6001         JZ      ??zll_GetNumSubDevices_2
    520              numEPs++;
   \   000011   09           INC     R1
    521            }
   \                     ??zll_GetNumSubDevices_2:
   \   000012   08           INC     R0
   \                     ??zll_GetNumSubDevices_0:
   \   000013   E8           MOV     A,R0
   \   000014   C3           CLR     C
   \   000015   9405         SUBB    A,#0x5
   \   000017   40F1         JC      ??zll_GetNumSubDevices_1
    522          
    523            return ( numEPs );
   \   000019   80..         SJMP    ??Subroutine39_0
    524          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   E8           MOV     A,R0
   \   000001   C3           CLR     C
   \   000002   33           RLC     A
   \   000003   FA           MOV     R2,A
   \   000004   E4           CLR     A
   \   000005   33           RLC     A
   \   000006   FB           MOV     R3,A
   \   000007   74..         MOV     A,#zllSubDevicesTbl & 0xff
   \   000009   2A           ADD     A,R2
   \   00000A   F582         MOV     DPL,A
   \   00000C   74..         MOV     A,#(zllSubDevicesTbl >> 8) & 0xff
   \   00000E   3B           ADDC    A,R3
   \   00000F   F583         MOV     DPH,A
   \   000011                REQUIRE ??Subroutine38_0
   \   000011                ; // Fall through to label ??Subroutine38_0
    525          
    526          /*********************************************************************
    527           * @fn      zll_GetNumGrpIDs
    528           *
    529           * @brief   Get the total number of group IDs required by this device.
    530           *
    531           * @param   none
    532           *
    533           * @return  number of group IDs
    534           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    535          uint8 zll_GetNumGrpIDs( void )
   \                     zll_GetNumGrpIDs:
    536          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    537            uint8 numGrpIDs = 0;
   \   000004   7900         MOV     R1,#0x0
    538          
    539            for ( uint8 i = 0; i < ZLL_NUM_DEVICE_INFO_ENTRIES; i++ )
   \   000006   7800         MOV     R0,#0x0
    540            {
    541              if ( zllSubDevicesTbl[i] != NULL )
   \                     ??zll_GetNumGrpIDs_0:
   \   000008   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   00000B   8A82         MOV     DPL,R2
   \   00000D   8B83         MOV     DPH,R3
   \   00000F   E582         MOV     A,DPL
   \   000011   4583         ORL     A,DPH
   \   000013   6009         JZ      ??zll_GetNumGrpIDs_1
    542              {
    543                numGrpIDs += zllSubDevicesTbl[i]->grpIdCnt;
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   29           ADD     A,R1
   \   00001D   F9           MOV     R1,A
    544              }
    545            }
   \                     ??zll_GetNumGrpIDs_1:
   \   00001E   08           INC     R0
   \   00001F   E8           MOV     A,R0
   \   000020   C3           CLR     C
   \   000021   9405         SUBB    A,#0x5
   \   000023   40E3         JC      ??zll_GetNumGrpIDs_0
    546          
    547            return ( numGrpIDs );
   \   000025   80..         SJMP    ??Subroutine39_0
    548          }
    549          
    550          /*********************************************************************
    551           * @fn      zll_GetSubDeviceInfo
    552           *
    553           * @brief   Get the sub-device information.
    554           *
    555           * input parameter
    556           *
    557           * @param   index - index of sub-device
    558           *
    559           * output parameter
    560           *
    561           * @param   pInfo - sub-device info (to be returned)
    562           *
    563           * @return  none
    564           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    565          void zll_GetSubDeviceInfo( uint8 index, zclLLDeviceInfo_t *pInfo )
   \                     zll_GetSubDeviceInfo:
    566          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    567            if ( pInfo == NULL )
   \   000009   EE           MOV     A,R6
   \   00000A   4F           ORL     A,R7
   \   00000B   6051         JZ      ??zll_GetSubDeviceInfo_0
    568            {
    569              return;
    570            }
    571            if ( ( index < ZLL_NUM_DEVICE_INFO_ENTRIES ) &&
    572                 ( zllSubDevicesTbl[index] != NULL ) )
   \   00000D   E9           MOV     A,R1
   \   00000E   C3           CLR     C
   \   00000F   9405         SUBB    A,#0x5
   \   000011   5042         JNC     ??zll_GetSubDeviceInfo_1
   \   000013   E9           MOV     A,R1
   \   000014   C3           CLR     C
   \   000015   33           RLC     A
   \   000016   F8           MOV     R0,A
   \   000017   E4           CLR     A
   \   000018   33           RLC     A
   \   000019   F9           MOV     R1,A
   \   00001A   74..         MOV     A,#zllSubDevicesTbl & 0xff
   \   00001C   28           ADD     A,R0
   \   00001D   F8           MOV     R0,A
   \   00001E   74..         MOV     A,#(zllSubDevicesTbl >> 8) & 0xff
   \   000020   39           ADDC    A,R1
   \   000021   F9           MOV     R1,A
   \   000022   88..         MOV     ?V0 + 0,R0
   \   000024   89..         MOV     ?V0 + 1,R1
   \   000026   8882         MOV     DPL,R0
   \   000028   12....       LCALL   ??Subroutine42_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   00002B   8882         MOV     DPL,R0
   \   00002D   8983         MOV     DPH,R1
   \   00002F   E582         MOV     A,DPL
   \   000031   4583         ORL     A,DPH
   \   000033   6020         JZ      ??zll_GetSubDeviceInfo_1
    573            {
    574              endPointDesc_t *epDesc = afFindEndPointDesc( zllSubDevicesTbl[index]->endpoint );
    575              if ( epDesc != NULL )
   \   000035                ; Setup parameters for call to function afFindEndPointDesc
   \   000035   E0           MOVX    A,@DPTR
   \   000036   F9           MOV     R1,A
   \   000037   12....       LCALL   ??afFindEndPointDesc?relay
   \   00003A   8B..         MOV     ?V0 + 5,R3
   \   00003C   EA           MOV     A,R2
   \   00003D   45..         ORL     A,?V0 + 5
   \   00003F   601D         JZ      ??zll_GetSubDeviceInfo_0
    576              {
    577                // Copy sub-device info
    578                *pInfo = *(zllSubDevicesTbl[index]);
   \   000041   85..82       MOV     DPL,?V0 + 0
   \   000044   85..83       MOV     DPH,?V0 + 1
   \   000047   12....       LCALL   ?Subroutine16 & 0xFFFF
    579              }
    580            }
   \                     ??CrossCallReturnLabel_13:
   \   00004A   EE           MOV     A,R6
   \   00004B   FC           MOV     R4,A
   \   00004C   EF           MOV     A,R7
   \   00004D   FD           MOV     R5,A
   \   00004E   7407         MOV     A,#0x7
   \   000050   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   \   000053   8009         SJMP    ??zll_GetSubDeviceInfo_0
    581            else
    582            {
    583              osal_memset( pInfo, 0, sizeof( zclLLDeviceInfo_t ) );
   \                     ??zll_GetSubDeviceInfo_1:
   \   000055                ; Setup parameters for call to function osal_memset
   \   000055   7C07         MOV     R4,#0x7
   \   000057   7D00         MOV     R5,#0x0
   \   000059   7900         MOV     R1,#0x0
   \   00005B   12....       LCALL   ??osal_memset?relay
   \                     ??zll_GetSubDeviceInfo_0:
   \   00005E   7F06         MOV     R7,#0x6
   \   000060   02....       LJMP    ?BANKED_LEAVE_XDATA
    584            }
    585          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET
    586          
    587          
    588          /*********************************************************************
    589           * @fn      zll_EncryptNwkKey
    590           *
    591           * @brief   Encrypt the current network key to be sent to a Target.
    592           *          In case of Factory New device generate new key.
    593           *
    594           * output parameter
    595           *
    596           * @param   pNwkKey - pointer to encrypted network key
    597           *
    598           * input parameters
    599           *
    600           * @param   keyIndex - key index
    601           * @param   transID - transaction id
    602           * @param   responseID - response id
    603           *
    604           * @return  none
    605           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    606          void zll_EncryptNwkKey( uint8 *pNwkKey, uint8 keyIndex, uint32 transID, uint32 responseID )
   \                     zll_EncryptNwkKey:
    607          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 69
   \   000005   74BB         MOV     A,#-0x45
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 12,R2
   \   00000C   8B..         MOV     ?V0 + 13,R3
   \   00000E   E9           MOV     A,R1
   \   00000F   FE           MOV     R6,A
   \   000010   745B         MOV     A,#0x5b
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   78..         MOV     R0,#?V0 + 0
   \   000017   12....       LCALL   ?L_MOV_X
   \   00001A   745F         MOV     A,#0x5f
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   78..         MOV     R0,#?V0 + 4
   \   000021   12....       LCALL   ?L_MOV_X
    608            uint8 aesKeyKey[SEC_KEY_LEN] = ZLL_DEFAULT_AES_KEY;
   \   000024   7410         MOV     A,#0x10
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   AC82         MOV     R4,DPL
   \   00002B   AD83         MOV     R5,DPH
   \   00002D   7583..       MOV     DPH,#(`?<Constant {80, 104, 76, 105, 234, 156, 209, 5` >> 8) & 0xff
   \   000030   7582..       MOV     DPL,#`?<Constant {80, 104, 76, 105, 234, 156, 209, 5` & 0xff
   \   000033   7410         MOV     A,#0x10
   \   000035   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    609            uint8 masterKey[SEC_KEY_LEN] = ZLL_ENC_KEY;
   \   000038   7435         MOV     A,#0x35
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   AC82         MOV     R4,DPL
   \   00003F   AD83         MOV     R5,DPH
   \   000041   7583..       MOV     DPH,#(`?<Constant {192, 193, 194, 195, 196, 197, 198,` >> 8) & 0xff
   \   000044   7582..       MOV     DPL,#`?<Constant {192, 193, 194, 195, 196, 197, 198,` & 0xff
   \   000047   7410         MOV     A,#0x10
   \   000049   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    610          #ifdef ZLL_DEV_FIXED_NWK_KEY
    611          uint8 nwkKey[SEC_KEY_LEN] = ZLL_DEV_FIXED_NWK_KEY;
    612          #else
    613            uint8 nwkKey[SEC_KEY_LEN];
    614            if ( zll_IsFactoryNew() )
   \   00004C                ; Setup parameters for call to function zll_IsFactoryNew
   \   00004C   12....       LCALL   ??zll_IsFactoryNew?relay
   \   00004F   E9           MOV     A,R1
   \   000050   6011         JZ      ??zll_EncryptNwkKey_0
    615            {
    616              zll_GenerateRandNum( nwkKey, SEC_KEY_LEN );
   \   000052                ; Setup parameters for call to function zll_GenerateRandNum
   \   000052   7910         MOV     R1,#0x10
   \   000054   85..82       MOV     DPL,?XSP + 0
   \   000057   85..83       MOV     DPH,?XSP + 1
   \   00005A   AA82         MOV     R2,DPL
   \   00005C   AB83         MOV     R3,DPH
   \   00005E   12....       LCALL   ??zll_GenerateRandNum?relay
   \   000061   8036         SJMP    ??zll_EncryptNwkKey_1
    617            }
    618            else
    619            {
    620              nwkActiveKeyItems keyItems;
    621              SSP_ReadNwkActiveKey( &keyItems );
   \                     ??zll_EncryptNwkKey_0:
   \   000063                ; Setup parameters for call to function SSP_ReadNwkActiveKey
   \   000063   7420         MOV     A,#0x20
   \   000065   12....       LCALL   ?XSTACK_DISP0_8
   \   000068   AA82         MOV     R2,DPL
   \   00006A   AB83         MOV     R3,DPH
   \   00006C   12....       LCALL   ??SSP_ReadNwkActiveKey?relay
    622              osal_memcpy( nwkKey, keyItems.active.key , SEC_KEY_LEN);
   \   00006F                ; Setup parameters for call to function osal_memcpy
   \   00006F   7421         MOV     A,#0x21
   \   000071   12....       LCALL   ?XSTACK_DISP0_8
   \   000074   A982         MOV     R1,DPL
   \   000076   AA83         MOV     R2,DPH
   \   000078   89..         MOV     ?V0 + 8,R1
   \   00007A   8A..         MOV     ?V0 + 9,R2
   \   00007C   75..00       MOV     ?V0 + 10,#0x0
   \   00007F   78..         MOV     R0,#?V0 + 8
   \   000081   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000084   7C10         MOV     R4,#0x10
   \   000086   7D00         MOV     R5,#0x0
   \   000088   7403         MOV     A,#0x3
   \   00008A   12....       LCALL   ?XSTACK_DISP0_8
   \   00008D   AA82         MOV     R2,DPL
   \   00008F   AB83         MOV     R3,DPH
   \   000091   12....       LCALL   ??osal_memcpy?relay
   \   000094   7403         MOV     A,#0x3
   \   000096   12....       LCALL   ?DEALLOC_XSTACK8
    623            }
    624          #endif
    625            // Build the AES key
    626            zll_BuildAesKey( aesKeyKey, transID, responseID, keyIndex );
   \                     ??zll_EncryptNwkKey_1:
   \   000099                ; Setup parameters for call to function zll_BuildAesKey
   \   000099   78..         MOV     R0,#?V0 + 4
   \   00009B   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   00009E   78..         MOV     R0,#?V0 + 0
   \   0000A0   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   0000A3   EE           MOV     A,R6
   \   0000A4   F9           MOV     R1,A
   \   0000A5   7418         MOV     A,#0x18
   \   0000A7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AA   AA82         MOV     R2,DPL
   \   0000AC   AB83         MOV     R3,DPH
   \   0000AE   12....       LCALL   ??zll_BuildAesKey?relay
   \   0000B1   7408         MOV     A,#0x8
   \   0000B3   12....       LCALL   ?DEALLOC_XSTACK8
    627          
    628            if ( ( keyIndex == ZLL_KEY_INDEX_MASTER ) || ( keyIndex == ZLL_KEY_INDEX_CERT ) )
   \   0000B6   7404         MOV     A,#0x4
   \   0000B8   6E           XRL     A,R6
   \   0000B9   6005         JZ      ??zll_EncryptNwkKey_2
   \   0000BB   740F         MOV     A,#0xf
   \   0000BD   6E           XRL     A,R6
   \   0000BE   7015         JNZ     ??zll_EncryptNwkKey_3
    629            {
    630              // Encypt with the master key
    631              sspAesEncrypt( masterKey, aesKeyKey );
   \                     ??zll_EncryptNwkKey_2:
   \   0000C0                ; Setup parameters for call to function sspAesEncrypt
   \   0000C0   7410         MOV     A,#0x10
   \   0000C2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C5   AC82         MOV     R4,DPL
   \   0000C7   AD83         MOV     R5,DPH
   \   0000C9   7435         MOV     A,#0x35
   \   0000CB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CE   AA82         MOV     R2,DPL
   \   0000D0   AB83         MOV     R3,DPH
   \   0000D2   12....       LCALL   ??sspAesEncrypt?relay
    632            }
    633            // Encrypt the network key with the AES key
    634            sspAesEncrypt( aesKeyKey, nwkKey );
   \                     ??zll_EncryptNwkKey_3:
   \   0000D5                ; Setup parameters for call to function sspAesEncrypt
   \   0000D5   85..82       MOV     DPL,?XSP + 0
   \   0000D8   85..83       MOV     DPH,?XSP + 1
   \   0000DB   AC82         MOV     R4,DPL
   \   0000DD   AD83         MOV     R5,DPH
   \   0000DF   7410         MOV     A,#0x10
   \   0000E1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E4   AA82         MOV     R2,DPL
   \   0000E6   AB83         MOV     R3,DPH
   \   0000E8   12....       LCALL   ??sspAesEncrypt?relay
    635          
    636            // Copy in the encrypted network key
    637            osal_memcpy( pNwkKey, nwkKey, SEC_KEY_LEN );
   \   0000EB                ; Setup parameters for call to function osal_memcpy
   \   0000EB   85..82       MOV     DPL,?XSP + 0
   \   0000EE   85..83       MOV     DPH,?XSP + 1
   \   0000F1   A982         MOV     R1,DPL
   \   0000F3   AA83         MOV     R2,DPH
   \   0000F5   89..         MOV     ?V0 + 0,R1
   \   0000F7   8A..         MOV     ?V0 + 1,R2
   \   0000F9   75..00       MOV     ?V0 + 2,#0x0
   \   0000FC   78..         MOV     R0,#?V0 + 0
   \   0000FE   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000101   7C10         MOV     R4,#0x10
   \   000103   7D00         MOV     R5,#0x0
   \   000105   AA..         MOV     R2,?V0 + 12
   \   000107   AB..         MOV     R3,?V0 + 13
   \   000109   12....       LCALL   ??osal_memcpy?relay
   \   00010C   7403         MOV     A,#0x3
   \   00010E   12....       LCALL   ?DEALLOC_XSTACK8
    638          }
   \   000111   7445         MOV     A,#0x45
   \   000113   12....       LCALL   ?DEALLOC_XSTACK8
   \   000116                REQUIRE ?Subroutine2
   \   000116                ; // Fall through to label ?Subroutine2

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7F0E         MOV     R7,#0xe
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    639          
    640          /*********************************************************************
    641           * @fn      zll_DecryptNwkKey
    642           *
    643           * @brief   Decrypt the received network key and update.
    644           *
    645           * @param   pNwkKey - pointer to the encrypted network key
    646           * @param   keyIndex - key index
    647           * @param   transID - transaction id
    648           * @param   responseID - response id
    649           *
    650           * @return  none
    651           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    652          void zll_DecryptNwkKey( uint8 *pNwkKey, uint8 keyIndex, uint32 transID, uint32 responseID )
   \                     zll_DecryptNwkKey:
    653          {
   \   000000   74ED         MOV     A,#-0x13
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 19
   \   000005                ; Auto size: 48
   \   000005   74D0         MOV     A,#-0x30
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   7443         MOV     A,#0x43
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   78..         MOV     R0,#?V0 + 0
   \   000013   12....       LCALL   ?L_MOV_X
   \   000016   7447         MOV     A,#0x47
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   78..         MOV     R0,#?V0 + 4
   \   00001D   12....       LCALL   ?L_MOV_X
    654            uint8 aesKeyKey[SEC_KEY_LEN] = ZLL_DEFAULT_AES_KEY;
   \   000020   7410         MOV     A,#0x10
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   AC82         MOV     R4,DPL
   \   000027   AD83         MOV     R5,DPH
   \   000029   7583..       MOV     DPH,#(`?<Constant {80, 104, 76, 105, 234, 156, 209, 5_1` >> 8) & 0xff
   \   00002C   7582..       MOV     DPL,#`?<Constant {80, 104, 76, 105, 234, 156, 209, 5_1` & 0xff
   \   00002F   7410         MOV     A,#0x10
   \   000031   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    655          
    656            uint8 nwkKey[SEC_KEY_LEN];
    657          
    658            uint8 masterKey[SEC_KEY_LEN] = ZLL_ENC_KEY;
   \   000034   7583..       MOV     DPH,#(`?<Constant {192, 193, 194, 195, 196, 197, 198,_1` >> 8) & 0xff
   \   000037   7582..       MOV     DPL,#`?<Constant {192, 193, 194, 195, 196, 197, 198,_1` & 0xff
   \   00003A   7410         MOV     A,#0x10
   \   00003C   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    659          
    660            // Copy in the encrypted network key
    661            osal_memcpy( nwkKey, pNwkKey, SEC_KEY_LEN );
   \   00003F                ; Setup parameters for call to function osal_memcpy
   \   00003F   8A..         MOV     ?V0 + 8,R2
   \   000041   8B..         MOV     ?V0 + 9,R3
   \   000043   F5..         MOV     ?V0 + 10,A
   \   000045   78..         MOV     R0,#?V0 + 8
   \   000047   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00004A   7C10         MOV     R4,#0x10
   \   00004C   7D00         MOV     R5,#0x0
   \   00004E   7403         MOV     A,#0x3
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   AA82         MOV     R2,DPL
   \   000055   AB83         MOV     R3,DPH
   \   000057   12....       LCALL   ??osal_memcpy?relay
   \   00005A   7403         MOV     A,#0x3
   \   00005C   12....       LCALL   ?DEALLOC_XSTACK8
    662          
    663            zll_BuildAesKey( aesKeyKey, transID, responseID, keyIndex );
   \   00005F                ; Setup parameters for call to function zll_BuildAesKey
   \   00005F   78..         MOV     R0,#?V0 + 4
   \   000061   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   000064   78..         MOV     R0,#?V0 + 0
   \   000066   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   000069   EE           MOV     A,R6
   \   00006A   F9           MOV     R1,A
   \   00006B   7418         MOV     A,#0x18
   \   00006D   12....       LCALL   ?XSTACK_DISP0_8
   \   000070   AA82         MOV     R2,DPL
   \   000072   AB83         MOV     R3,DPH
   \   000074   12....       LCALL   ??zll_BuildAesKey?relay
   \   000077   7408         MOV     A,#0x8
   \   000079   12....       LCALL   ?DEALLOC_XSTACK8
    664          
    665            if ( ( keyIndex == ZLL_KEY_INDEX_MASTER ) || ( keyIndex == ZLL_KEY_INDEX_CERT ) )
   \   00007C   7404         MOV     A,#0x4
   \   00007E   6E           XRL     A,R6
   \   00007F   6005         JZ      ??zll_DecryptNwkKey_0
   \   000081   740F         MOV     A,#0xf
   \   000083   6E           XRL     A,R6
   \   000084   7015         JNZ     ??zll_DecryptNwkKey_1
    666            {
    667              //encypt with the master key
    668              sspAesEncrypt( masterKey, aesKeyKey );
   \                     ??zll_DecryptNwkKey_0:
   \   000086                ; Setup parameters for call to function sspAesEncrypt
   \   000086   7410         MOV     A,#0x10
   \   000088   12....       LCALL   ?XSTACK_DISP0_8
   \   00008B   AC82         MOV     R4,DPL
   \   00008D   AD83         MOV     R5,DPH
   \   00008F   7420         MOV     A,#0x20
   \   000091   12....       LCALL   ?XSTACK_DISP0_8
   \   000094   AA82         MOV     R2,DPL
   \   000096   AB83         MOV     R3,DPH
   \   000098   12....       LCALL   ??sspAesEncrypt?relay
    669            }
    670            // Decrypt the network key with the AES key
    671            sspAesDecrypt( aesKeyKey, nwkKey );
   \                     ??zll_DecryptNwkKey_1:
   \   00009B                ; Setup parameters for call to function sspAesDecrypt
   \   00009B   85..82       MOV     DPL,?XSP + 0
   \   00009E   85..83       MOV     DPH,?XSP + 1
   \   0000A1   AC82         MOV     R4,DPL
   \   0000A3   AD83         MOV     R5,DPH
   \   0000A5   7410         MOV     A,#0x10
   \   0000A7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AA   AA82         MOV     R2,DPL
   \   0000AC   AB83         MOV     R3,DPH
   \   0000AE   12....       LCALL   ??sspAesDecrypt?relay
    672          
    673            zll_UpdateNwkKey( nwkKey, keyIndex );
   \   0000B1                ; Setup parameters for call to function zll_UpdateNwkKey
   \   0000B1   EE           MOV     A,R6
   \   0000B2   F9           MOV     R1,A
   \   0000B3   85..82       MOV     DPL,?XSP + 0
   \   0000B6   85..83       MOV     DPH,?XSP + 1
   \   0000B9   AA82         MOV     R2,DPL
   \   0000BB   AB83         MOV     R3,DPH
   \   0000BD   12....       LCALL   ??zll_UpdateNwkKey?relay
    674          }
   \   0000C0   7430         MOV     A,#0x30
   \   0000C2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C5   7F0B         MOV     R7,#0xb
   \   0000C7   02....       LJMP    ?BANKED_LEAVE_XDATA
    675          
    676          /*********************************************************************
    677           * @fn      zll_BuildAesKey
    678           *
    679           * @brief   Build an AES key using Transaction ID and Response ID.
    680           *
    681           * @param   pAesKey - pointer to AES to be built
    682           * @param   transID - transaction id
    683           * @param   responseID - response id
    684           *
    685           * @return  none
    686           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    687          static void zll_BuildAesKey( uint8 *pAesKey, uint32 transID, uint32 responseID, uint8 keyIndex )
   \                     zll_BuildAesKey:
    688          {
   \   000000   74EB         MOV     A,#-0x15
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 21
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 12,R1
   \   000007   7419         MOV     A,#0x19
   \   000009   12....       LCALL   ?XSTACK_DISP0_8
   \   00000C   78..         MOV     R0,#?V0 + 0
   \   00000E   12....       LCALL   ?L_MOV_X
    689          
    690            if ( ( keyIndex == ZLL_KEY_INDEX_MASTER ) || ( keyIndex == ZLL_KEY_INDEX_CERT ) )
   \   000011   AF..         MOV     R7,?V0 + 1
   \   000013   7415         MOV     A,#0x15
   \   000015   12....       LCALL   ?XSTACK_DISP0_8
   \   000018   78..         MOV     R0,#?V0 + 4
   \   00001A   12....       LCALL   ?L_MOV_X
   \   00001D   AD..         MOV     R5,?V0 + 5
   \   00001F   85....       MOV     ?V0 + 8,?V0 + 0
   \   000022   8F..         MOV     ?V0 + 9,R7
   \   000024   85....       MOV     ?V0 + 10,?V0 + 2
   \   000027   85....       MOV     ?V0 + 11,?V0 + 3
   \   00002A   7410         MOV     A,#0x10
   \   00002C   78..         MOV     R0,#?V0 + 8
   \   00002E   12....       LCALL   ?UL_SHR
   \   000031   AE..         MOV     R6,?V0 + 8
   \   000033   85....       MOV     ?V0 + 8,?V0 + 0
   \   000036   8F..         MOV     ?V0 + 9,R7
   \   000038   8E..         MOV     ?V0 + 10,R6
   \   00003A   85....       MOV     ?V0 + 11,?V0 + 3
   \   00003D   7418         MOV     A,#0x18
   \   00003F   78..         MOV     R0,#?V0 + 8
   \   000041   12....       LCALL   ?UL_SHR
   \   000044   AC..         MOV     R4,?V0 + 8
   \   000046   85....       MOV     ?V0 + 8,?V0 + 4
   \   000049   8D..         MOV     ?V0 + 9,R5
   \   00004B   85....       MOV     ?V0 + 10,?V0 + 6
   \   00004E   85....       MOV     ?V0 + 11,?V0 + 7
   \   000051   7410         MOV     A,#0x10
   \   000053   78..         MOV     R0,#?V0 + 8
   \   000055   12....       LCALL   ?UL_SHR
   \   000058   A9..         MOV     R1,?V0 + 8
   \   00005A   85....       MOV     ?V0 + 8,?V0 + 4
   \   00005D   8D..         MOV     ?V0 + 9,R5
   \   00005F   89..         MOV     ?V0 + 10,R1
   \   000061   85....       MOV     ?V0 + 11,?V0 + 7
   \   000064   7418         MOV     A,#0x18
   \   000066   78..         MOV     R0,#?V0 + 8
   \   000068   12....       LCALL   ?UL_SHR
   \   00006B   A8..         MOV     R0,?V0 + 8
   \   00006D   7404         MOV     A,#0x4
   \   00006F   65..         XRL     A,?V0 + 12
   \   000071   6006         JZ      ??zll_BuildAesKey_0
   \   000073   740F         MOV     A,#0xf
   \   000075   65..         XRL     A,?V0 + 12
   \   000077   7054         JNZ     ??zll_BuildAesKey_1
    691            {
    692              // Copy transaction identifier to 1st byte
    693              pAesKey[0] = BREAK_UINT32( transID, 3 );
   \                     ??zll_BuildAesKey_0:
   \   000079   E8           MOV     A,R0
   \   00007A   8A82         MOV     DPL,R2
   \   00007C   8B83         MOV     DPH,R3
   \   00007E   F0           MOVX    @DPTR,A
    694              pAesKey[1] = BREAK_UINT32( transID, 2 );
   \   00007F   E9           MOV     A,R1
   \   000080   12....       LCALL   ?Subroutine27 & 0xFFFF
    695              pAesKey[2] = BREAK_UINT32( transID, 1 );
   \                     ??CrossCallReturnLabel_34:
   \   000083   F0           MOVX    @DPTR,A
    696              pAesKey[3] = BREAK_UINT32( transID, 0 );
   \   000084   85....       MOV     ?V0 + 8,?V0 + 4
   \   000087   8A82         MOV     DPL,R2
   \   000089   8B83         MOV     DPH,R3
   \   00008B   A3           INC     DPTR
   \   00008C   A3           INC     DPTR
   \   00008D   A3           INC     DPTR
   \   00008E   E5..         MOV     A,?V0 + 8
   \   000090   F0           MOVX    @DPTR,A
    697          
    698              // Copy response identifier 3rd bute
    699              pAesKey[8] = BREAK_UINT32( responseID, 3 );
   \   000091   EC           MOV     A,R4
   \   000092   8A82         MOV     DPL,R2
   \   000094   8B83         MOV     DPH,R3
   \   000096   A3           INC     DPTR
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   A3           INC     DPTR
   \   00009A   A3           INC     DPTR
   \   00009B   A3           INC     DPTR
   \   00009C   A3           INC     DPTR
   \   00009D   A3           INC     DPTR
   \   00009E   F0           MOVX    @DPTR,A
    700              pAesKey[9] = BREAK_UINT32( responseID, 2 );
   \   00009F   EE           MOV     A,R6
   \   0000A0   8A82         MOV     DPL,R2
   \   0000A2   8B83         MOV     DPH,R3
   \   0000A4   A3           INC     DPTR
   \   0000A5   A3           INC     DPTR
   \   0000A6   A3           INC     DPTR
   \   0000A7   A3           INC     DPTR
   \   0000A8   A3           INC     DPTR
   \   0000A9   A3           INC     DPTR
   \   0000AA   A3           INC     DPTR
   \   0000AB   A3           INC     DPTR
   \   0000AC   A3           INC     DPTR
   \   0000AD   F0           MOVX    @DPTR,A
    701              pAesKey[10] = BREAK_UINT32( responseID, 1 );
   \   0000AE   EF           MOV     A,R7
   \   0000AF   8A82         MOV     DPL,R2
   \   0000B1   8B83         MOV     DPH,R3
   \   0000B3   A3           INC     DPTR
   \   0000B4   A3           INC     DPTR
   \   0000B5   A3           INC     DPTR
   \   0000B6   A3           INC     DPTR
   \   0000B7   A3           INC     DPTR
   \   0000B8   A3           INC     DPTR
   \   0000B9   A3           INC     DPTR
   \   0000BA   A3           INC     DPTR
   \   0000BB   A3           INC     DPTR
   \   0000BC   A3           INC     DPTR
   \   0000BD   F0           MOVX    @DPTR,A
    702              pAesKey[11] = BREAK_UINT32( responseID, 0 );
   \   0000BE   85....       MOV     ?V0 + 8,?V0 + 0
   \   0000C1   EA           MOV     A,R2
   \   0000C2   240B         ADD     A,#0xb
   \   0000C4   F582         MOV     DPL,A
   \   0000C6   EB           MOV     A,R3
   \   0000C7   12....       LCALL   ??Subroutine41_0 & 0xFFFF
    703            }
   \                     ??CrossCallReturnLabel_71:
   \   0000CA   E5..         MOV     A,?V0 + 8
   \   0000CC   F0           MOVX    @DPTR,A
    704          
    705            // Copy in the transaction identifier
    706            pAesKey[4] = BREAK_UINT32( transID, 3 );
   \                     ??zll_BuildAesKey_1:
   \   0000CD   E8           MOV     A,R0
   \   0000CE   8A82         MOV     DPL,R2
   \   0000D0   8B83         MOV     DPH,R3
   \   0000D2   A3           INC     DPTR
   \   0000D3   A3           INC     DPTR
   \   0000D4   A3           INC     DPTR
   \   0000D5   A3           INC     DPTR
   \   0000D6   F0           MOVX    @DPTR,A
    707            pAesKey[5] = BREAK_UINT32( transID, 2 );
   \   0000D7   E9           MOV     A,R1
   \   0000D8   8A82         MOV     DPL,R2
   \   0000DA   8B83         MOV     DPH,R3
   \   0000DC   A3           INC     DPTR
   \   0000DD   A3           INC     DPTR
   \   0000DE   A3           INC     DPTR
   \   0000DF   A3           INC     DPTR
   \   0000E0   12....       LCALL   ?Subroutine27 & 0xFFFF
    708            pAesKey[6] = BREAK_UINT32( transID, 1 );
   \                     ??CrossCallReturnLabel_35:
   \   0000E3   A3           INC     DPTR
   \   0000E4   A3           INC     DPTR
   \   0000E5   A3           INC     DPTR
   \   0000E6   A3           INC     DPTR
   \   0000E7   12....       LCALL   ?Subroutine22 & 0xFFFF
    709            pAesKey[7] = BREAK_UINT32( transID, 0 );
   \                     ??CrossCallReturnLabel_27:
   \   0000EA   A3           INC     DPTR
   \   0000EB   A3           INC     DPTR
   \   0000EC   E5..         MOV     A,?V0 + 4
   \   0000EE   F0           MOVX    @DPTR,A
    710          
    711            // Copy in the response identifier
    712            pAesKey[12] = BREAK_UINT32( responseID, 3 );
   \   0000EF   EA           MOV     A,R2
   \   0000F0   240C         ADD     A,#0xc
   \   0000F2   F582         MOV     DPL,A
   \   0000F4   EB           MOV     A,R3
   \   0000F5   12....       LCALL   ??Subroutine41_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   0000F8   EC           MOV     A,R4
   \   0000F9   F0           MOVX    @DPTR,A
    713            pAesKey[13] = BREAK_UINT32( responseID, 2 );
   \   0000FA   EA           MOV     A,R2
   \   0000FB   240D         ADD     A,#0xd
   \   0000FD   F582         MOV     DPL,A
   \   0000FF   EB           MOV     A,R3
   \   000100   12....       LCALL   ??Subroutine41_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   000103   EE           MOV     A,R6
   \   000104   F0           MOVX    @DPTR,A
    714            pAesKey[14] = BREAK_UINT32( responseID, 1 );
   \   000105   EA           MOV     A,R2
   \   000106   240E         ADD     A,#0xe
   \   000108   F582         MOV     DPL,A
   \   00010A   EB           MOV     A,R3
   \   00010B   12....       LCALL   ??Subroutine41_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   00010E   EF           MOV     A,R7
   \   00010F   F0           MOVX    @DPTR,A
    715            pAesKey[15] = BREAK_UINT32( responseID, 0 );
   \   000110   EA           MOV     A,R2
   \   000111   240F         ADD     A,#0xf
   \   000113   F582         MOV     DPL,A
   \   000115   EB           MOV     A,R3
   \   000116   12....       LCALL   ??Subroutine41_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   000119   E5..         MOV     A,?V0 + 0
   \   00011B   F0           MOVX    @DPTR,A
    716          }
   \   00011C   7F0D         MOV     R7,#0xd
   \   00011E   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   A3           INC     DPTR
   \   000001   F0           MOVX    @DPTR,A
   \   000002   ED           MOV     A,R5
   \   000003   8A82         MOV     DPL,R2
   \   000005   8B83         MOV     DPH,R3
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine41_0:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F583         MOV     DPH,A
   \   000004   22           RET
    717          
    718          /*********************************************************************
    719           * @fn      zll_UpdateNwkKey
    720           *
    721           * @brief   Update the network key.
    722           *
    723           * @param   pNwkParams - pointer to new network key
    724           * @param   keyIndex - key index
    725           *
    726           * @return  none
    727           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    728          void zll_UpdateNwkKey( uint8 *pNwkKey, uint8 keyIndex )
   \                     zll_UpdateNwkKey:
    729          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    730            uint32 nwkFrameCounterTmp;
    731            (void)keyIndex;
    732          
    733            // To prevent Framecounter out of sync issues, store the lastkey
    734            nwkFrameCounterTmp = nwkFrameCounter;  // (Global in SSP).
   \   000005   90....       MOV     DPTR,#nwkFrameCounter
   \   000008   78..         MOV     R0,#?V0 + 0
   \   00000A   12....       LCALL   ?L_MOV_X
    735          
    736            // Update the network key
    737            SSP_UpdateNwkKey( pNwkKey, 0 );
   \   00000D                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   00000D   7900         MOV     R1,#0x0
   \   00000F   12....       LCALL   ??SSP_UpdateNwkKey?relay
    738          
    739            SSP_SwitchNwkKey( 0 );
   \   000012                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000012   7900         MOV     R1,#0x0
   \   000014   12....       LCALL   ??SSP_SwitchNwkKey?relay
    740          
    741            nwkFrameCounter  = nwkFrameCounterTmp; // restore
   \   000017   90....       MOV     DPTR,#nwkFrameCounter
   \   00001A   78..         MOV     R0,#?V0 + 0
   \   00001C   12....       LCALL   ?L_MOV_TO_X
    742          
    743            // Save off the security
    744            ZDApp_SaveNwkKey();
   \   00001F                ; Setup parameters for call to function ZDApp_SaveNwkKey
   \   00001F   12....       LCALL   ??ZDApp_SaveNwkKey?relay
    745          }
   \   000022   02....       LJMP    ?Subroutine3 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    746          
    747          /*********************************************************************
    748           * @fn      zll_GetNwkKeyBitmask
    749           *
    750           * @brief   Get the supported network key bitmask.
    751           *
    752           * @param   none
    753           *
    754           * @return  network key bitmask
    755           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    756          uint16 zll_GetNwkKeyBitmask( void )
   \                     zll_GetNwkKeyBitmask:
    757          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    758            return ( (uint16)1 << ZLL_KEY_INDEX );
   \   000000   7A00         MOV     R2,#0x0
   \   000002   7B80         MOV     R3,#-0x80
   \   000004   02....       LJMP    ?BRET
    759          }
    760          
    761          /*********************************************************************
    762           * @fn      zll_GenerateRandNum
    763           *
    764           * @brief   Fill buffer with random bytes.
    765           *
    766           * input parameter
    767           *
    768           * @param   numSize - size of buffer in bytes
    769           *
    770           * output parameter
    771           *
    772           * @param   pNum - pointer to buffer to be filled with random values
    773           *
    774           * @return  none
    775           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    776          void zll_GenerateRandNum( uint8 *pNum, uint8 numSize )
   \                     zll_GenerateRandNum:
    777          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   89..         MOV     ?V0 + 4,R1
    778            if ( pNum && numSize )
   \   00000B   EE           MOV     A,R6
   \   00000C   4F           ORL     A,R7
   \   00000D   603C         JZ      ??zll_GenerateRandNum_0
   \   00000F   E9           MOV     A,R1
   \   000010   6039         JZ      ??zll_GenerateRandNum_0
    779            {
    780              uint8 lastByte = ( numSize - 1 );
   \   000012   74FF         MOV     A,#-0x1
   \   000014   25..         ADD     A,?V0 + 4
   \   000016   F5..         MOV     ?V0 + 2,A
    781              for ( uint8 i = 0; i < lastByte; i += 2 )
   \   000018   75..00       MOV     ?V0 + 3,#0x0
   \   00001B   8016         SJMP    ??zll_GenerateRandNum_1
    782              {
    783                uint16 rand = osal_rand();
   \                     ??zll_GenerateRandNum_2:
   \   00001D                ; Setup parameters for call to function osal_rand
   \   00001D   12....       LCALL   ??osal_rand?relay
   \   000020   8A..         MOV     ?V0 + 0,R2
   \   000022   A8..         MOV     R0,?V0 + 0
    784                pNum[i]   = LO_UINT16( rand );
   \   000024   85....       MOV     ?V0 + 0,?V0 + 3
   \   000027   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   00002A   E8           MOV     A,R0
   \   00002B   F0           MOVX    @DPTR,A
    785                pNum[i+1] = HI_UINT16( rand );
   \   00002C   EB           MOV     A,R3
   \   00002D   A3           INC     DPTR
   \   00002E   F0           MOVX    @DPTR,A
    786              }
   \   00002F   05..         INC     ?V0 + 3
   \   000031   05..         INC     ?V0 + 3
   \                     ??zll_GenerateRandNum_1:
   \   000033   E5..         MOV     A,?V0 + 3
   \   000035   C3           CLR     C
   \   000036   95..         SUBB    A,?V0 + 2
   \   000038   40E3         JC      ??zll_GenerateRandNum_2
    787          
    788              // In case the number is odd
    789              if ( numSize % 2 )
   \   00003A   E5..         MOV     A,?V0 + 4
   \   00003C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00003E   500B         JNC     ??zll_GenerateRandNum_0
    790              {
    791                pNum[lastByte] = LO_UINT16( osal_rand() );
   \   000040                ; Setup parameters for call to function osal_rand
   \   000040   12....       LCALL   ??osal_rand?relay
   \   000043   85....       MOV     ?V0 + 0,?V0 + 2
   \   000046   12....       LCALL   ?Subroutine29 & 0xFFFF
    792              }
    793            }
   \                     ??CrossCallReturnLabel_91:
   \   000049   EA           MOV     A,R2
   \   00004A   F0           MOVX    @DPTR,A
    794          }
   \                     ??zll_GenerateRandNum_0:
   \   00004B                REQUIRE ?Subroutine4
   \   00004B                ; // Fall through to label ?Subroutine4

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   7F05         MOV     R7,#0x5
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   EE           MOV     A,R6
   \   000001   25..         ADD     A,?V0 + 0
   \   000003                REQUIRE ??Subroutine40_0
   \   000003                ; // Fall through to label ??Subroutine40_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine40_0:
   \   000000   F582         MOV     DPL,A
   \   000002   EF           MOV     A,R7
   \   000003                REQUIRE ??Subroutine41_0
   \   000003                ; // Fall through to label ??Subroutine41_0
    795          
    796          /*********************************************************************
    797           * @fn      zll_GetRandPrimaryChannel
    798           *
    799           * @brief   Get randomly chosen ZLL primary channel.
    800           *
    801           * @return  channel
    802           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    803          uint8 zll_GetRandPrimaryChannel()
   \                     zll_GetRandPrimaryChannel:
    804          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    805            uint8 channel = osal_rand() & 0x1F;
   \   000004                ; Setup parameters for call to function osal_rand
   \   000004   12....       LCALL   ??osal_rand?relay
   \   000007   EA           MOV     A,R2
   \   000008   541F         ANL     A,#0x1f
   \   00000A   F9           MOV     R1,A
    806            if ( channel <= ZLL_FIRST_CHANNEL )
   \   00000B   C3           CLR     C
   \   00000C   940C         SUBB    A,#0xc
   \   00000E   5004         JNC     ??zll_GetRandPrimaryChannel_0
    807            {
    808              channel = ZLL_FIRST_CHANNEL;
   \   000010   790B         MOV     R1,#0xb
   \   000012   8016         SJMP    ??zll_GetRandPrimaryChannel_1
    809            }
    810            else if ( channel <= ZLL_SECOND_CHANNEL )
   \                     ??zll_GetRandPrimaryChannel_0:
   \   000014   E9           MOV     A,R1
   \   000015   C3           CLR     C
   \   000016   9410         SUBB    A,#0x10
   \   000018   5004         JNC     ??zll_GetRandPrimaryChannel_2
    811            {
    812              channel = ZLL_SECOND_CHANNEL;
   \   00001A   790F         MOV     R1,#0xf
   \   00001C   800C         SJMP    ??zll_GetRandPrimaryChannel_1
    813            }
    814            else if ( channel <= ZLL_THIRD_CHANNEL )
   \                     ??zll_GetRandPrimaryChannel_2:
   \   00001E   E9           MOV     A,R1
   \   00001F   C3           CLR     C
   \   000020   9415         SUBB    A,#0x15
   \   000022   5004         JNC     ??zll_GetRandPrimaryChannel_3
    815            {
    816              channel = ZLL_THIRD_CHANNEL;
   \   000024   7914         MOV     R1,#0x14
   \   000026   8002         SJMP    ??zll_GetRandPrimaryChannel_1
    817            }
    818            else
    819            {
    820              channel = ZLL_FOURTH_CHANNEL;
   \                     ??zll_GetRandPrimaryChannel_3:
   \   000028   7919         MOV     R1,#0x19
    821            }
    822          #ifdef ZLL_DEV_SELECT_FIRST_CHANNEL
    823          #warning The device will always select the first primary channel
    824            channel = ZLL_FIRST_CHANNEL;
    825          #endif
    826            return channel;
   \                     ??zll_GetRandPrimaryChannel_1:
   \   00002A   02....       LJMP    ??Subroutine39_0 & 0xFFFF
    827          }
    828          
    829          /*********************************************************************
    830           * @fn      zll_SetNIB
    831           *
    832           * @brief   Copy new Network Parameters to the NIB.
    833           *
    834           * @param   nwkState - network state
    835           * @param   nwkAddr - short address
    836           * @param   pExtendedPANID - pointer to extended PAN ID
    837           * @param   logicalChannel - channel
    838           * @param   panId - PAN identifier
    839           * @param   nwkUpdateId - nwtwork update identifier
    840           *
    841           * @return      void
    842           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    843          void zll_SetNIB( nwk_states_t nwkState, uint16 nwkAddr, uint8 *pExtendedPANID,
   \                     zll_SetNIB:
    844                           uint8 logicalChannel, uint16 panId, uint8 nwkUpdateId )
    845          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 4,R1
   \   000007   EC           MOV     A,R4
   \   000008   FE           MOV     R6,A
   \   000009   ED           MOV     A,R5
   \   00000A   FF           MOV     R7,A
   \   00000B   740E         MOV     A,#0xe
   \   00000D   12....       LCALL   ?XSTACK_DISP0_8
   \   000010   12....       LCALL   ??Subroutine44_0 & 0xFFFF
    846            // Copy the new network parameters to NIB
    847            _NIB.nwkState = nwkState;
   \                     ??CrossCallReturnLabel_107:
   \   000013   E9           MOV     A,R1
   \   000014   90....       MOV     DPTR,#_NIB + 35
   \   000017   F0           MOVX    @DPTR,A
    848            _NIB.nwkDevAddress = nwkAddr;
   \   000018   90....       MOV     DPTR,#_NIB + 20
   \   00001B   EA           MOV     A,R2
   \   00001C   F0           MOVX    @DPTR,A
   \   00001D   A3           INC     DPTR
   \   00001E   EB           MOV     A,R3
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   740D         MOV     A,#0xd
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   E0           MOVX    A,@DPTR
   \   000026   F8           MOV     R0,A
    849            _NIB.nwkLogicalChannel = logicalChannel;
   \   000027   90....       MOV     DPTR,#_NIB + 22
   \   00002A   F0           MOVX    @DPTR,A
    850            _NIB.nwkCoordAddress = INVALID_NODE_ADDR;
   \   00002B   A3           INC     DPTR
   \   00002C   12....       LCALL   ?Subroutine26 & 0xFFFF
    851            _NIB.channelList = (uint32)1 << logicalChannel;
   \                     ??CrossCallReturnLabel_50:
   \   00002F   75..01       MOV     ?V0 + 0,#0x1
   \   000032   75..00       MOV     ?V0 + 1,#0x0
   \   000035   75..00       MOV     ?V0 + 2,#0x0
   \   000038   75..00       MOV     ?V0 + 3,#0x0
   \   00003B   E8           MOV     A,R0
   \   00003C   78..         MOV     R0,#?V0 + 0
   \   00003E   12....       LCALL   ?L_SHL
   \   000041   90....       MOV     DPTR,#_NIB + 36
   \   000044   78..         MOV     R0,#?V0 + 0
   \   000046   12....       LCALL   ?L_MOV_TO_X
    852            _NIB.nwkPanId = panId;
   \   000049   90....       MOV     DPTR,#_NIB + 33
   \   00004C   EC           MOV     A,R4
   \   00004D   F0           MOVX    @DPTR,A
   \   00004E   A3           INC     DPTR
   \   00004F   ED           MOV     A,R5
   \   000050   F0           MOVX    @DPTR,A
    853            _NIB.nodeDepth = 1;
   \   000051   90....       MOV     DPTR,#_NIB + 52
   \   000054   7401         MOV     A,#0x1
   \   000056   F0           MOVX    @DPTR,A
    854            _NIB.MaxRouters = (uint8)gNWK_MAX_DEVICE_LIST;
   \   000057   90....       MOV     DPTR,#gNWK_MAX_DEVICE_LIST
   \   00005A   E4           CLR     A
   \   00005B   93           MOVC    A,@A+DPTR
   \   00005C   90....       MOV     DPTR,#_NIB + 5
   \   00005F   F0           MOVX    @DPTR,A
    855            _NIB.MaxChildren = (uint8)gNWK_MAX_DEVICE_LIST;
   \   000060   90....       MOV     DPTR,#gNWK_MAX_DEVICE_LIST
   \   000063   E4           CLR     A
   \   000064   93           MOVC    A,@A+DPTR
   \   000065   90....       MOV     DPTR,#_NIB + 3
   \   000068   F0           MOVX    @DPTR,A
    856            _NIB.allocatedRouterAddresses = 1;
   \   000069   90....       MOV     DPTR,#_NIB + 44
   \   00006C   7401         MOV     A,#0x1
   \   00006E   F0           MOVX    @DPTR,A
   \   00006F   A3           INC     DPTR
   \   000070   E4           CLR     A
   \   000071   F0           MOVX    @DPTR,A
   \   000072   A3           INC     DPTR
   \   000073   F0           MOVX    @DPTR,A
   \   000074   A3           INC     DPTR
   \   000075   12....       LCALL   ??Subroutine35_0 & 0xFFFF
    857            _NIB.allocatedEndDeviceAddresses = 1;
   \                     ??CrossCallReturnLabel_47:
   \   000078   A3           INC     DPTR
   \   000079   E4           CLR     A
   \   00007A   F0           MOVX    @DPTR,A
   \   00007B   A3           INC     DPTR
   \   00007C   F0           MOVX    @DPTR,A
   \   00007D   A3           INC     DPTR
   \   00007E   F0           MOVX    @DPTR,A
   \   00007F   7410         MOV     A,#0x10
   \   000081   12....       LCALL   ?XSTACK_DISP0_8
   \   000084   E0           MOVX    A,@DPTR
   \   000085   F9           MOV     R1,A
    858          
    859            if ( _NIB.nwkUpdateId != nwkUpdateId )
   \   000086   90....       MOV     DPTR,#_NIB + 109
   \   000089   E0           MOVX    A,@DPTR
   \   00008A   69           XRL     A,R1
   \   00008B   6003         JZ      ??zll_SetNIB_0
    860            {
    861              NLME_SetUpdateID( nwkUpdateId );
   \   00008D                ; Setup parameters for call to function NLME_SetUpdateID
   \   00008D   12....       LCALL   ??NLME_SetUpdateID?relay
    862            }
    863          
    864            osal_cpyExtAddr( _NIB.extendedPANID, pExtendedPANID );
   \                     ??zll_SetNIB_0:
   \   000090                ; Setup parameters for call to function sAddrExtCpy
   \   000090   EE           MOV     A,R6
   \   000091   FC           MOV     R4,A
   \   000092   EF           MOV     A,R7
   \   000093   FD           MOV     R5,A
   \   000094   7A..         MOV     R2,#(_NIB + 53) & 0xff
   \   000096   7B..         MOV     R3,#((_NIB + 53) >> 8) & 0xff
   \   000098   12....       LCALL   ??sAddrExtCpy?relay
    865          
    866            // Save the NIB
    867            if ( nwkState == NWK_ROUTER )
   \   00009B   7408         MOV     A,#0x8
   \   00009D   65..         XRL     A,?V0 + 4
   \   00009F   7005         JNZ     ??zll_SetNIB_1
    868            {
    869              zll_UpdateNV( ZLL_UPDATE_NV_NIB );
   \   0000A1                ; Setup parameters for call to function zll_UpdateNV
   \   0000A1   7901         MOV     R1,#0x1
   \   0000A3   12....       LCALL   ??zll_UpdateNV?relay
    870            }
    871            // else will be updated when ED joins its parent
    872          }
   \                     ??zll_SetNIB_1:
   \   0000A6   02....       LJMP    ?Subroutine4 & 0xFFFF
    873          
    874          /*********************************************************************
    875           * @fn      zll_ProcessNwkUpdate
    876           *
    877           * @brief   Update our local network update id and logical channel.
    878           *
    879           * @param   nwkUpdateId - new network update id
    880           * @param   logicalChannel - new logical channel
    881           *
    882           * @return  void
    883           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    884          void zll_ProcessNwkUpdate( uint8 nwkUpdateId, uint8 logicalChannel )
   \                     zll_ProcessNwkUpdate:
    885          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
    886            // Update the network update id
    887            NLME_SetUpdateID( nwkUpdateId );
   \   000007                ; Setup parameters for call to function NLME_SetUpdateID
   \   000007   12....       LCALL   ??NLME_SetUpdateID?relay
    888          
    889            // Switch channel
    890            if ( _NIB.nwkLogicalChannel != logicalChannel )
   \   00000A   90....       MOV     DPTR,#_NIB + 22
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   6E           XRL     A,R6
   \   00000F   6006         JZ      ??zll_ProcessNwkUpdate_0
    891            {
    892              _NIB.nwkLogicalChannel = logicalChannel;
   \   000011   EE           MOV     A,R6
   \   000012   F0           MOVX    @DPTR,A
    893              zll_SetChannel( logicalChannel );
   \   000013                ; Setup parameters for call to function zll_SetChannel
   \   000013   F9           MOV     R1,A
   \   000014   12....       LCALL   ??zll_SetChannel?relay
    894            }
    895          
    896            // Update channel list
    897            _NIB.channelList = (uint32)1 << logicalChannel;
   \                     ??zll_ProcessNwkUpdate_0:
   \   000017   75..01       MOV     ?V0 + 0,#0x1
   \   00001A   75..00       MOV     ?V0 + 1,#0x0
   \   00001D   75..00       MOV     ?V0 + 2,#0x0
   \   000020   75..00       MOV     ?V0 + 3,#0x0
   \   000023   EE           MOV     A,R6
   \   000024   78..         MOV     R0,#?V0 + 0
   \   000026   12....       LCALL   ?L_SHL
   \   000029   90....       MOV     DPTR,#_NIB + 36
   \   00002C   78..         MOV     R0,#?V0 + 0
   \   00002E   12....       LCALL   ?L_MOV_TO_X
    898          
    899            // Our Channel has been changed -- notify to save info into NV
    900            ZDApp_NwkStateUpdateCB();
   \   000031                ; Setup parameters for call to function ZDApp_NwkStateUpdateCB
   \   000031   12....       LCALL   ??ZDApp_NwkStateUpdateCB?relay
    901            //zll_UpdateNV();
    902          
    903            // Reset the total transmit count and the transmit failure counters
    904            _NIB.nwkTotalTransmissions = 0;
   \   000034   90....       MOV     DPTR,#_NIB + 107
   \   000037   E4           CLR     A
   \   000038   F0           MOVX    @DPTR,A
   \   000039   A3           INC     DPTR
   \   00003A   F0           MOVX    @DPTR,A
    905            nwkTransmissionFailures( TRUE );
   \   00003B                ; Setup parameters for call to function nwkTransmissionFailures
   \   00003B   7901         MOV     R1,#0x1
   \   00003D   12....       LCALL   ??nwkTransmissionFailures?relay
    906          }
   \   000040   02....       LJMP    ?Subroutine3 & 0xFFFF
    907          
    908          /*********************************************************************
    909           * @fn      zll_UpdateNV
    910           *
    911           * @brief   Updates NV with NIB and free ranges items
    912           *
    913           * @param   enables - specifies what to update
    914           *
    915           * @return  none
    916           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    917          void zll_UpdateNV( uint8 enables )
   \                     zll_UpdateNV:
    918          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    919          #if defined ( NV_RESTORE )
    920          
    921           #if defined ( NV_TURN_OFF_RADIO )
    922            // Turn off the radio's receiver during an NV update
    923            uint8 RxOnIdle;
    924            uint8 x = FALSE;
    925            ZMacGetReq( ZMacRxOnIdle, &RxOnIdle );
    926            ZMacSetReq( ZMacRxOnIdle, &x );
    927           #endif
    928          
    929            if ( enables & ZLL_UPDATE_NV_NIB )
   \   000007   A2E0         MOV     C,0xE0 /* A   */.0
   \   000009   502D         JNC     ??zll_UpdateNV_0
    930            {
    931              // Update NIB in NV
    932              osal_nv_write( ZCD_NV_NIB, 0, sizeof( nwkIB_t ), &_NIB );
   \   00000B                ; Setup parameters for call to function osal_nv_write
   \   00000B   75....       MOV     ?V0 + 0,#_NIB & 0xff
   \   00000E   75....       MOV     ?V0 + 1,#(_NIB >> 8) & 0xff
   \   000011   78..         MOV     R0,#?V0 + 0
   \   000013   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000016   75..6E       MOV     ?V0 + 0,#0x6e
   \   000019   75..00       MOV     ?V0 + 1,#0x0
   \   00001C   78..         MOV     R0,#?V0 + 0
   \   00001E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000021   7C00         MOV     R4,#0x0
   \   000023   7D00         MOV     R5,#0x0
   \   000025   7A21         MOV     R2,#0x21
   \   000027   7B00         MOV     R3,#0x0
   \   000029   12....       LCALL   ??osal_nv_write?relay
   \   00002C   7404         MOV     A,#0x4
   \   00002E   12....       LCALL   ?DEALLOC_XSTACK8
    933          
    934              // Reset the NV startup option to resume from NV by clearing
    935              // the "New" join option.
    936              zgWriteStartupOptions( ZG_STARTUP_CLEAR, ZCD_STARTOPT_DEFAULT_NETWORK_STATE );
   \   000031                ; Setup parameters for call to function zgWriteStartupOptions
   \   000031   7A02         MOV     R2,#0x2
   \   000033   7900         MOV     R1,#0x0
   \   000035   12....       LCALL   ??zgWriteStartupOptions?relay
    937            }
    938          
    939            if ( enables & ZLL_UPDATE_NV_RANGES )
   \                     ??zll_UpdateNV_0:
   \   000038   EE           MOV     A,R6
   \   000039   A2E1         MOV     C,0xE0 /* A   */.1
   \   00003B   4003         JC      $+5
   \   00003D   02....       LJMP    ??zll_UpdateNV_1 & 0xFFFF
    940            {
    941              // Store our free network address and group ID ranges
    942              osal_nv_write( ZCD_NV_MIN_FREE_NWK_ADDR, 0, sizeof( zllFreeNwkAddrBegin ), &zllFreeNwkAddrBegin );
   \   000040                ; Setup parameters for call to function osal_nv_write
   \   000040   75....       MOV     ?V0 + 0,#zllFreeNwkAddrBegin & 0xff
   \   000043   75....       MOV     ?V0 + 1,#(zllFreeNwkAddrBegin >> 8) & 0xff
   \   000046   78..         MOV     R0,#?V0 + 0
   \   000048   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004B   75..02       MOV     ?V0 + 0,#0x2
   \   00004E   75..00       MOV     ?V0 + 1,#0x0
   \   000051   78..         MOV     R0,#?V0 + 0
   \   000053   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000056   7C00         MOV     R4,#0x0
   \   000058   7D00         MOV     R5,#0x0
   \   00005A   7A92         MOV     R2,#-0x6e
   \   00005C   7B00         MOV     R3,#0x0
   \   00005E   12....       LCALL   ??osal_nv_write?relay
   \   000061   7404         MOV     A,#0x4
   \   000063   12....       LCALL   ?DEALLOC_XSTACK8
    943              osal_nv_write( ZCD_NV_MAX_FREE_NWK_ADDR, 0, sizeof( zllFreeNwkAddrEnd ), &zllFreeNwkAddrEnd );
   \   000066                ; Setup parameters for call to function osal_nv_write
   \   000066   75....       MOV     ?V0 + 0,#zllFreeNwkAddrEnd & 0xff
   \   000069   75....       MOV     ?V0 + 1,#(zllFreeNwkAddrEnd >> 8) & 0xff
   \   00006C   78..         MOV     R0,#?V0 + 0
   \   00006E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000071   75..02       MOV     ?V0 + 0,#0x2
   \   000074   75..00       MOV     ?V0 + 1,#0x0
   \   000077   78..         MOV     R0,#?V0 + 0
   \   000079   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007C   7C00         MOV     R4,#0x0
   \   00007E   7D00         MOV     R5,#0x0
   \   000080   7A93         MOV     R2,#-0x6d
   \   000082   7B00         MOV     R3,#0x0
   \   000084   12....       LCALL   ??osal_nv_write?relay
   \   000087   7404         MOV     A,#0x4
   \   000089   12....       LCALL   ?DEALLOC_XSTACK8
    944              osal_nv_write( ZCD_NV_MIN_FREE_GRP_ID, 0, sizeof( zllFreeGrpIdBegin ), &zllFreeGrpIdBegin );
   \   00008C                ; Setup parameters for call to function osal_nv_write
   \   00008C   75....       MOV     ?V0 + 0,#zllFreeGrpIdBegin & 0xff
   \   00008F   75....       MOV     ?V0 + 1,#(zllFreeGrpIdBegin >> 8) & 0xff
   \   000092   78..         MOV     R0,#?V0 + 0
   \   000094   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000097   75..02       MOV     ?V0 + 0,#0x2
   \   00009A   75..00       MOV     ?V0 + 1,#0x0
   \   00009D   78..         MOV     R0,#?V0 + 0
   \   00009F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A2   7C00         MOV     R4,#0x0
   \   0000A4   7D00         MOV     R5,#0x0
   \   0000A6   7A94         MOV     R2,#-0x6c
   \   0000A8   7B00         MOV     R3,#0x0
   \   0000AA   12....       LCALL   ??osal_nv_write?relay
   \   0000AD   7404         MOV     A,#0x4
   \   0000AF   12....       LCALL   ?DEALLOC_XSTACK8
    945              osal_nv_write( ZCD_NV_MAX_FREE_GRP_ID, 0, sizeof( zllFreeGrpIdEnd ), &zllFreeGrpIdEnd );
   \   0000B2                ; Setup parameters for call to function osal_nv_write
   \   0000B2   75....       MOV     ?V0 + 0,#zllFreeGrpIdEnd & 0xff
   \   0000B5   75....       MOV     ?V0 + 1,#(zllFreeGrpIdEnd >> 8) & 0xff
   \   0000B8   78..         MOV     R0,#?V0 + 0
   \   0000BA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000BD   75..02       MOV     ?V0 + 0,#0x2
   \   0000C0   75..00       MOV     ?V0 + 1,#0x0
   \   0000C3   78..         MOV     R0,#?V0 + 0
   \   0000C5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C8   7C00         MOV     R4,#0x0
   \   0000CA   7D00         MOV     R5,#0x0
   \   0000CC   7A95         MOV     R2,#-0x6b
   \   0000CE   7B00         MOV     R3,#0x0
   \   0000D0   12....       LCALL   ??osal_nv_write?relay
   \   0000D3   7404         MOV     A,#0x4
   \   0000D5   12....       LCALL   ?DEALLOC_XSTACK8
    946          
    947              // Store our group ID range
    948              osal_nv_write( ZCD_NV_MIN_GRP_IDS, 0, sizeof( zllGrpIDsBegin ), &zllGrpIDsBegin );
   \   0000D8                ; Setup parameters for call to function osal_nv_write
   \   0000D8   75....       MOV     ?V0 + 0,#zllGrpIDsBegin & 0xff
   \   0000DB   75....       MOV     ?V0 + 1,#(zllGrpIDsBegin >> 8) & 0xff
   \   0000DE   78..         MOV     R0,#?V0 + 0
   \   0000E0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000E3   75..02       MOV     ?V0 + 0,#0x2
   \   0000E6   75..00       MOV     ?V0 + 1,#0x0
   \   0000E9   78..         MOV     R0,#?V0 + 0
   \   0000EB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000EE   7C00         MOV     R4,#0x0
   \   0000F0   7D00         MOV     R5,#0x0
   \   0000F2   7A96         MOV     R2,#-0x6a
   \   0000F4   7B00         MOV     R3,#0x0
   \   0000F6   12....       LCALL   ??osal_nv_write?relay
   \   0000F9   7404         MOV     A,#0x4
   \   0000FB   12....       LCALL   ?DEALLOC_XSTACK8
    949              osal_nv_write( ZCD_NV_MAX_GRP_IDS, 0, sizeof( zllGrpIDsEnd ), &zllGrpIDsEnd );
   \   0000FE                ; Setup parameters for call to function osal_nv_write
   \   0000FE   75....       MOV     ?V0 + 0,#zllGrpIDsEnd & 0xff
   \   000101   75....       MOV     ?V0 + 1,#(zllGrpIDsEnd >> 8) & 0xff
   \   000104   78..         MOV     R0,#?V0 + 0
   \   000106   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000109   75..02       MOV     ?V0 + 0,#0x2
   \   00010C   75..00       MOV     ?V0 + 1,#0x0
   \   00010F   78..         MOV     R0,#?V0 + 0
   \   000111   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000114   7C00         MOV     R4,#0x0
   \   000116   7D00         MOV     R5,#0x0
   \   000118   7A97         MOV     R2,#-0x69
   \   00011A   7B00         MOV     R3,#0x0
   \   00011C   12....       LCALL   ??osal_nv_write?relay
   \   00011F   7404         MOV     A,#0x4
   \   000121   12....       LCALL   ?DEALLOC_XSTACK8
    950            }
    951          
    952           #if defined ( NV_TURN_OFF_RADIO )
    953            ZMacSetReq( ZMacRxOnIdle, &RxOnIdle );
    954           #endif
    955          
    956          #endif // NV_RESTORE
    957          }
   \                     ??zll_UpdateNV_1:
   \   000124   02....       LJMP    ??Subroutine36_0 & 0xFFFF
    958          
    959          /*********************************************************************
    960           * @fn          zll_InitNV
    961           *
    962           * @brief       Initialize free range RAM variables from NV. If NV items
    963           *              don't exist, then the NV is initialize with what is in
    964           *              RAM variables.
    965           *
    966           * @param       none
    967           *
    968           * @return      none
    969           */
    970          static void zll_InitNV( void )
    971          {
    972            // Initialize our free network address and group ID ranges
    973            zll_ItemInit( ZCD_NV_MIN_FREE_NWK_ADDR, sizeof( zllFreeNwkAddrBegin ), &zllFreeNwkAddrBegin );
    974            zll_ItemInit( ZCD_NV_MAX_FREE_NWK_ADDR, sizeof( zllFreeNwkAddrEnd ), &zllFreeNwkAddrEnd );
    975            zll_ItemInit( ZCD_NV_MIN_FREE_GRP_ID, sizeof( zllFreeGrpIdBegin ), &zllFreeGrpIdBegin );
    976            zll_ItemInit( ZCD_NV_MAX_FREE_GRP_ID, sizeof( zllFreeGrpIdEnd ), &zllFreeGrpIdEnd );
    977          
    978            // Initialize our group ID range
    979            zll_ItemInit( ZCD_NV_MIN_GRP_IDS, sizeof( zllGrpIDsBegin ), &zllGrpIDsBegin );
    980            zll_ItemInit( ZCD_NV_MAX_GRP_IDS, sizeof( zllGrpIDsEnd ), &zllGrpIDsEnd );
    981          }
    982          
    983          /*********************************************************************
    984           * @fn      zll_ItemInit
    985           *
    986           * @brief   Initialize an NV item. If the item doesn't exist in NV memory,
    987           *          write the default (value passed in) into NV memory. But if
    988           *          it exists, set the item to the value stored in NV memory.
    989           *
    990           * @param   id - item id
    991           * @param   len - item len
    992           * @param   buf - pointer to the item
    993           *
    994           * @return  none
    995           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    996          void zll_ItemInit( uint16 id, uint16 len, void *pBuf )
   \                     zll_ItemInit:
    997          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 2,R4
   \   00000B   8D..         MOV     ?V0 + 3,R5
   \   00000D   740C         MOV     A,#0xc
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   12....       LCALL   ?Subroutine15 & 0xFFFF
    998          #if defined ( NV_RESTORE )
    999            // If the item doesn't exist in NV memory, create and initialize
   1000            // it with the value passed in.
   1001            if ( osal_nv_item_init( id, len, pBuf ) == ZSuccess )
   \                     ??CrossCallReturnLabel_11:
   \   000015   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000018   12....       LCALL   ??osal_nv_item_init?relay
   \   00001B   7402         MOV     A,#0x2
   \   00001D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000020   E9           MOV     A,R1
   \   000021   701A         JNZ     ??zll_ItemInit_0
   1002            {
   1003              // The item already exists in NV memory, read it from NV memory
   1004              osal_nv_read( id, 0, len, pBuf );
   \   000023                ; Setup parameters for call to function osal_nv_read
   \   000023   78..         MOV     R0,#?V0 + 0
   \   000025   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000028   78..         MOV     R0,#?V0 + 2
   \   00002A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002D   7C00         MOV     R4,#0x0
   \   00002F   7D00         MOV     R5,#0x0
   \   000031   EE           MOV     A,R6
   \   000032   FA           MOV     R2,A
   \   000033   EF           MOV     A,R7
   \   000034   FB           MOV     R3,A
   \   000035   12....       LCALL   ??osal_nv_read?relay
   \   000038   7404         MOV     A,#0x4
   \   00003A   12....       LCALL   ?DEALLOC_XSTACK8
   1005            }
   1006          #endif // NV_RESTORE
   1007          }
   \                     ??zll_ItemInit_0:
   \   00003D                REQUIRE ?Subroutine3
   \   00003D                ; // Fall through to label ?Subroutine3

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000003                ; Setup parameters for call to function osal_nv_item_init
   \   000003   78..         MOV     R0,#?V0 + 0
   \   000005   22           RET
   1008          
   1009          /*********************************************************************
   1010           * @fn      zll_SetMacNwkParams
   1011           *
   1012           * @brief   Configure MAC with our Network Parameters.
   1013           *
   1014           * @param   nwkAddr - network address
   1015           * @param   panId - PAN identifier
   1016           * @param   channel
   1017           *
   1018           * @return  void
   1019           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1020          void zll_SetMacNwkParams( uint16 nwkAddr, uint16 panId, uint8 channel )
   \                     zll_SetMacNwkParams:
   1021          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   EC           MOV     A,R4
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   A3           INC     DPTR
   \   00001D   ED           MOV     A,R5
   \   00001E   F0           MOVX    @DPTR,A
   \   00001F   E9           MOV     A,R1
   \   000020   FE           MOV     R6,A
   1022            // Set our short address
   1023            ZMacSetReq( ZMacShortAddress, (byte*)&nwkAddr );
   \   000021                ; Setup parameters for call to function ZMacSetReq
   \   000021   7402         MOV     A,#0x2
   \   000023   12....       LCALL   ?XSTACK_DISP0_8
   \   000026   AA82         MOV     R2,DPL
   \   000028   AB83         MOV     R3,DPH
   \   00002A   7953         MOV     R1,#0x53
   \   00002C   12....       LCALL   ??ZMacSetReq?relay
   1024          
   1025            // Set our PAN ID
   1026            ZMacSetReq( ZMacPanId, (byte*)&panId );
   \   00002F                ; Setup parameters for call to function ZMacSetReq
   \   00002F   85..82       MOV     DPL,?XSP + 0
   \   000032   85..83       MOV     DPH,?XSP + 1
   \   000035   AA82         MOV     R2,DPL
   \   000037   AB83         MOV     R3,DPH
   \   000039   7950         MOV     R1,#0x50
   \   00003B   12....       LCALL   ??ZMacSetReq?relay
   1027          
   1028            // Tune to the selected logical channel
   1029            zll_SetChannel( channel );
   \   00003E                ; Setup parameters for call to function zll_SetChannel
   \   00003E   EE           MOV     A,R6
   \   00003F   F9           MOV     R1,A
   \   000040   12....       LCALL   ??zll_SetChannel?relay
   1030          }
   \   000043   7404         MOV     A,#0x4
   \   000045   12....       LCALL   ?DEALLOC_XSTACK8
   \   000048   02....       LJMP    ?Subroutine5 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   1031          
   1032          /*********************************************************************
   1033           * @fn      zll_SetChannel
   1034           *
   1035           * @brief   Set our channel.
   1036           *
   1037           * @param   channel - new channel to change to
   1038           *
   1039           * @return  void
   1040           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine39_0
   \   000003                ; // Fall through to label ??Subroutine39_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1041          void zll_SetChannel( uint8 channel )
   \                     zll_SetChannel:
   1042          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 2
   \   000004   74FE         MOV     A,#-0x2
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   \   000009   7401         MOV     A,#0x1
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   E9           MOV     A,R1
   \   00000F   12....       LCALL   ?Subroutine20 & 0xFFFF
   1043            uint8 curChannel;
   1044          
   1045            // Try to change channel
   1046            ZMacGetReq( ZMacChannel, &curChannel );
   \                     ??CrossCallReturnLabel_22:
   \   000012   79E1         MOV     R1,#-0x1f
   \   000014   12....       LCALL   ??ZMacGetReq?relay
   1047          
   1048            if ( curChannel != channel )
   \   000017   85..82       MOV     DPL,?XSP + 0
   \   00001A   85..83       MOV     DPH,?XSP + 1
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F8           MOV     R0,A
   \   00001F   7401         MOV     A,#0x1
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   E0           MOVX    A,@DPTR
   \   000025   68           XRL     A,R0
   \   000026   6009         JZ      ??zll_SetChannel_0
   1049            {
   1050              // Set the new channel
   1051              ZMacSetReq( ZMacChannel, &channel );
   \   000028                ; Setup parameters for call to function ZMacSetReq
   \   000028   AA82         MOV     R2,DPL
   \   00002A   AB83         MOV     R3,DPH
   \   00002C   79E1         MOV     R1,#-0x1f
   \   00002E   12....       LCALL   ??ZMacSetReq?relay
   1052          
   1053              // NOTE - When operating on channel 26, the transmission power may be
   1054              //        reduced in order to comply with FCC regulations.
   1055            }
   1056          }
   \                     ??zll_SetChannel_0:
   \   000031   7402         MOV     A,#0x2
   \   000033   02....       LJMP    ?Subroutine1 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function ZMacGetReq
   \   000001                ; Setup parameters for call to function NLME_NwkDiscReq2
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   AA82         MOV     R2,DPL
   \   000009   AB83         MOV     R3,DPH
   \   00000B   22           RET
   1057          
   1058          /*********************************************************************
   1059           * @fn      zll_SendScanRsp
   1060           *
   1061           * @brief   Send out a Scan Response command.
   1062           *
   1063           * @param   srcEP - sender's endpoint
   1064           * @param   dstAddr - pointer to destination address struct
   1065           * @param   transID - received transaction id
   1066           * @param   seqNum - received sequence number
   1067           *
   1068           * @return  ZStatus_t
   1069           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1070          ZStatus_t zll_SendScanRsp( uint8 srcEP, afAddrType_t *dstAddr, uint32 transID, uint8 seqNum )
   \                     zll_SendScanRsp:
   1071          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 2,R1
   \   000007   8A..         MOV     ?V0 + 12,R2
   \   000009   8B..         MOV     ?V0 + 13,R3
   \   00000B   8C..         MOV     ?V0 + 3,R4
   1072            ZStatus_t status = ZSuccess;
   \   00000D   75..00       MOV     ?V0 + 0,#0x0
   \   000010   7416         MOV     A,#0x16
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   78..         MOV     R0,#?V0 + 4
   \   000017   12....       LCALL   ?L_MOV_X
   1073          
   1074            // Make sure we respond only once during a Device Discovery
   1075            if ( zllLastAcceptedTransID != transID )
   \   00001A   90....       MOV     DPTR,#zllLastAcceptedTransID
   \   00001D   78..         MOV     R0,#?V0 + 4
   \   00001F   12....       LCALL   ?L_EQ_X
   \   000022   7003         JNZ     $+5
   \   000024   02....       LJMP    ??zll_SendScanRsp_0 & 0xFFFF
   1076            {
   1077              zclLLScanRsp_t *pRsp;
   1078          
   1079              pRsp = (zclLLScanRsp_t *)osal_mem_alloc( sizeof( zclLLScanRsp_t ) );
   \   000027                ; Setup parameters for call to function osal_mem_alloc
   \   000027   7A26         MOV     R2,#0x26
   \   000029   7B00         MOV     R3,#0x0
   \   00002B   12....       LCALL   ??osal_mem_alloc?relay
   \   00002E   8A..         MOV     ?V0 + 0,R2
   \   000030   8B..         MOV     ?V0 + 1,R3
   \   000032   AE..         MOV     R6,?V0 + 0
   \   000034   AF..         MOV     R7,?V0 + 1
   1080              if ( pRsp )
   \   000036   EE           MOV     A,R6
   \   000037   4F           ORL     A,R7
   \   000038   7003         JNZ     $+5
   \   00003A   02....       LJMP    ??zll_SendScanRsp_1 & 0xFFFF
   1081              {
   1082                osal_memset( pRsp, 0, sizeof( zclLLScanRsp_t ) );
   \   00003D                ; Setup parameters for call to function osal_memset
   \   00003D   7C26         MOV     R4,#0x26
   \   00003F   7D00         MOV     R5,#0x0
   \   000041   7900         MOV     R1,#0x0
   \   000043   12....       LCALL   ??osal_memset?relay
   1083          
   1084                // Save transaction id
   1085                zllLastAcceptedTransID = transID;
   \   000046   90....       MOV     DPTR,#zllLastAcceptedTransID
   \   000049   78..         MOV     R0,#?V0 + 4
   \   00004B   12....       LCALL   ?L_MOV_TO_X
   1086                osal_start_timerEx( zllTaskId, ZLL_TRANS_LIFETIME_EXPIRED_EVT,
   1087                                    ZLL_APLC_INTER_PAN_TRANS_ID_LIFETIME );
   \   00004E                ; Setup parameters for call to function osal_start_timerEx
   \   00004E   90....       MOV     DPTR,#__Constant_1f40
   \   000051   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   000054   7A20         MOV     R2,#0x20
   \   000056   7B00         MOV     R3,#0x0
   \   000058   90....       MOV     DPTR,#zllTaskId
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   F9           MOV     R1,A
   \   00005D   12....       LCALL   ??osal_start_timerEx?relay
   \   000060   7404         MOV     A,#0x4
   \   000062   12....       LCALL   ?DEALLOC_XSTACK8
   1088          
   1089                pRsp->transID = transID;
   \   000065   8E82         MOV     DPL,R6
   \   000067   8F83         MOV     DPH,R7
   \   000069   78..         MOV     R0,#?V0 + 4
   \   00006B   12....       LCALL   ?L_MOV_TO_X
   1090                pRsp->rssiCorrection = ZLL_RSSI_CORRECTION;
   \   00006E   8E82         MOV     DPL,R6
   \   000070   8F83         MOV     DPH,R7
   \   000072   A3           INC     DPTR
   \   000073   A3           INC     DPTR
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   E4           CLR     A
   \   000077   F0           MOVX    @DPTR,A
   1091                pRsp->zLogicalType = zgDeviceLogicalType;
   \   000078   EE           MOV     A,R6
   \   000079   2405         ADD     A,#0x5
   \   00007B   F5..         MOV     ?V0 + 4,A
   \   00007D   EF           MOV     A,R7
   \   00007E   3400         ADDC    A,#0x0
   \   000080   F5..         MOV     ?V0 + 5,A
   \   000082   85..82       MOV     DPL,?V0 + 4
   \   000085   F583         MOV     DPH,A
   \   000087   E0           MOVX    A,@DPTR
   \   000088   54FC         ANL     A,#0xfc
   \   00008A   F8           MOV     R0,A
   \   00008B   A3           INC     DPTR
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   F9           MOV     R1,A
   \   00008E   90....       MOV     DPTR,#zgDeviceLogicalType
   \   000091   E0           MOVX    A,@DPTR
   \   000092   5403         ANL     A,#0x3
   \   000094   FA           MOV     R2,A
   \   000095   E8           MOV     A,R0
   \   000096   4A           ORL     A,R2
   \   000097   85..82       MOV     DPL,?V0 + 4
   \   00009A   85..83       MOV     DPH,?V0 + 5
   \   00009D   12....       LCALL   ??Subroutine37_0 & 0xFFFF
   1092                pRsp->zllAddressAssignment = zll_IsValidSplitFreeRanges(0);
   \                     ??CrossCallReturnLabel_53:
   \   0000A0                ; Setup parameters for call to function zll_IsValidSplitFreeRanges
   \   0000A0   7900         MOV     R1,#0x0
   \   0000A2   12....       LCALL   ??zll_IsValidSplitFreeRanges?relay
   \   0000A5   E9           MOV     A,R1
   \   0000A6   F8           MOV     R0,A
   \   0000A7   EE           MOV     A,R6
   \   0000A8   2407         ADD     A,#0x7
   \   0000AA   F5..         MOV     ?V0 + 0,A
   \   0000AC   EF           MOV     A,R7
   \   0000AD   3400         ADDC    A,#0x0
   \   0000AF   F5..         MOV     ?V0 + 1,A
   \   0000B1   85..82       MOV     DPL,?V0 + 0
   \   0000B4   F583         MOV     DPH,A
   \   0000B6   E0           MOVX    A,@DPTR
   \   0000B7   54FD         ANL     A,#0xfd
   \   0000B9   FA           MOV     R2,A
   \   0000BA   A3           INC     DPTR
   \   0000BB   E0           MOVX    A,@DPTR
   \   0000BC   FB           MOV     R3,A
   \   0000BD   E8           MOV     A,R0
   \   0000BE   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000C0   E4           CLR     A
   \   0000C1   33           RLC     A
   \   0000C2   33           RLC     A
   \   0000C3   F8           MOV     R0,A
   \   0000C4   EA           MOV     A,R2
   \   0000C5   48           ORL     A,R0
   \   0000C6   F8           MOV     R0,A
   \   0000C7   EB           MOV     A,R3
   \   0000C8   F9           MOV     R1,A
   \   0000C9   85..82       MOV     DPL,?V0 + 0
   \   0000CC   85..83       MOV     DPH,?V0 + 1
   \   0000CF   12....       LCALL   ?Subroutine19 & 0xFFFF
   1093                pRsp->zllLinkInitiator = zllIsInitiator;
   \                     ??CrossCallReturnLabel_62:
   \   0000D2   E8           MOV     A,R0
   \   0000D3   54EF         ANL     A,#0xef
   \   0000D5   FA           MOV     R2,A
   \   0000D6   90....       MOV     DPTR,#zllIsInitiator
   \   0000D9   E0           MOVX    A,@DPTR
   \   0000DA   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000DC   E4           CLR     A
   \   0000DD   33           RLC     A
   \   0000DE   F5..         MOV     ?V0 + 6,A
   \   0000E0   75..00       MOV     ?V0 + 7,#0x0
   \   0000E3   7404         MOV     A,#0x4
   \   0000E5   78..         MOV     R0,#?V0 + 6
   \   0000E7   12....       LCALL   ?S_SHL
   \   0000EA   A8..         MOV     R0,?V0 + 6
   \   0000EC   EA           MOV     A,R2
   \   0000ED   48           ORL     A,R0
   \   0000EE   85..82       MOV     DPL,?V0 + 0
   \   0000F1   85..83       MOV     DPH,?V0 + 1
   \   0000F4   12....       LCALL   ??Subroutine37_0 & 0xFFFF
   1094          
   1095                if ( ZDO_Config_Node_Descriptor.CapabilityFlags & CAPINFO_RCVR_ON_IDLE )
   \                     ??CrossCallReturnLabel_54:
   \   0000F7   90....       MOV     DPTR,#ZDO_Config_Node_Descriptor + 2
   \   0000FA   E0           MOVX    A,@DPTR
   \   0000FB   A2E3         MOV     C,0xE0 /* A   */.3
   \   0000FD   500A         JNC     ??zll_SendScanRsp_2
   1096                {
   1097                  pRsp->zRxOnWhenIdle = TRUE;
   \   0000FF   85..82       MOV     DPL,?V0 + 4
   \   000102   85..83       MOV     DPH,?V0 + 5
   \   000105   E0           MOVX    A,@DPTR
   \   000106   4404         ORL     A,#0x4
   \   000108   F0           MOVX    @DPTR,A
   1098                }
   1099          
   1100                pRsp->zllLinklinkPriority = FALSE;
   \                     ??zll_SendScanRsp_2:
   \   000109   85..82       MOV     DPL,?V0 + 0
   \   00010C   85..83       MOV     DPH,?V0 + 1
   \   00010F   E0           MOVX    A,@DPTR
   \   000110   54DF         ANL     A,#0xdf
   \   000112   12....       LCALL   ?Subroutine21 & 0xFFFF
   1101                pRsp->keyBitmask = zll_GetNwkKeyBitmask();
   \                     ??CrossCallReturnLabel_24:
   \   000115   A3           INC     DPTR
   \   000116   A3           INC     DPTR
   \   000117   A3           INC     DPTR
   \   000118   E4           CLR     A
   \   000119   F0           MOVX    @DPTR,A
   \   00011A   A3           INC     DPTR
   \   00011B   7480         MOV     A,#-0x80
   \   00011D   F0           MOVX    @DPTR,A
   1102          
   1103                // Generate a new Response ID
   1104                zllResponseID = ( ((uint32)osal_rand()) << 16 ) + osal_rand();
   \   00011E                ; Setup parameters for call to function osal_rand
   \   00011E   12....       LCALL   ??osal_rand?relay
   \   000121   8A..         MOV     ?V0 + 8,R2
   \   000123   8B..         MOV     ?V0 + 9,R3
   \   000125   E4           CLR     A
   \   000126   F5..         MOV     ?V0 + 10,A
   \   000128   F5..         MOV     ?V0 + 11,A
   \   00012A   7410         MOV     A,#0x10
   \   00012C   78..         MOV     R0,#?V0 + 8
   \   00012E   12....       LCALL   ?L_SHL
   \   000131                ; Setup parameters for call to function osal_rand
   \   000131   12....       LCALL   ??osal_rand?relay
   \   000134   8A..         MOV     ?V0 + 4,R2
   \   000136   8B..         MOV     ?V0 + 5,R3
   \   000138   E4           CLR     A
   \   000139   F5..         MOV     ?V0 + 6,A
   \   00013B   78..         MOV     R0,#?V0 + 8
   \   00013D   79..         MOV     R1,#?V0 + 4
   \   00013F   12....       LCALL   ?L_ADD
   \   000142   90....       MOV     DPTR,#zllResponseID
   \   000145   E5..         MOV     A,?V0 + 8
   \   000147   F0           MOVX    @DPTR,A
   \   000148   A3           INC     DPTR
   \   000149   E5..         MOV     A,?V0 + 9
   \   00014B   F0           MOVX    @DPTR,A
   \   00014C   A3           INC     DPTR
   \   00014D   E5..         MOV     A,?V0 + 10
   \   00014F   F0           MOVX    @DPTR,A
   \   000150   A3           INC     DPTR
   \   000151   E5..         MOV     A,?V0 + 11
   \   000153   F0           MOVX    @DPTR,A
   1105                pRsp->responseID = zllResponseID;
   \   000154   90....       MOV     DPTR,#zllResponseID
   \   000157   12....       LCALL   ?XLOAD_R2345
   \   00015A   EE           MOV     A,R6
   \   00015B   240B         ADD     A,#0xb
   \   00015D   12....       LCALL   ??Subroutine40_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   000160   12....       LCALL   ?XSTORE_R2345
   1106          
   1107                pRsp->zllFactoryNew = zll_IsFactoryNew();
   \   000163                ; Setup parameters for call to function zll_IsFactoryNew
   \   000163   12....       LCALL   ??zll_IsFactoryNew?relay
   \   000166   E9           MOV     A,R1
   \   000167   FA           MOV     R2,A
   \   000168   85..82       MOV     DPL,?V0 + 0
   \   00016B   85..83       MOV     DPH,?V0 + 1
   \   00016E   E0           MOVX    A,@DPTR
   \   00016F   54FE         ANL     A,#0xfe
   \   000171   F8           MOV     R0,A
   \   000172   A3           INC     DPTR
   \   000173   E0           MOVX    A,@DPTR
   \   000174   F9           MOV     R1,A
   \   000175   EA           MOV     A,R2
   \   000176   A2E0         MOV     C,0xE0 /* A   */.0
   \   000178   E4           CLR     A
   \   000179   33           RLC     A
   \   00017A   FA           MOV     R2,A
   \   00017B   E8           MOV     A,R0
   \   00017C   4A           ORL     A,R2
   \   00017D   85..82       MOV     DPL,?V0 + 0
   \   000180   85..83       MOV     DPH,?V0 + 1
   \   000183   12....       LCALL   ??Subroutine37_0 & 0xFFFF
   1108                if ( pRsp->zllFactoryNew )
   \                     ??CrossCallReturnLabel_55:
   \   000186   EE           MOV     A,R6
   \   000187   2417         ADD     A,#0x17
   \   000189   F8           MOV     R0,A
   \   00018A   EF           MOV     A,R7
   \   00018B   3400         ADDC    A,#0x0
   \   00018D   F9           MOV     R1,A
   \   00018E   EE           MOV     A,R6
   \   00018F   241B         ADD     A,#0x1b
   \   000191   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   000194   E0           MOVX    A,@DPTR
   \   000195   A2E0         MOV     C,0xE0 /* A   */.0
   \   000197   5010         JNC     ??zll_SendScanRsp_3
   1109                {
   1110                  pRsp->nwkAddr = 0xFFFF;
   \   000199   8A82         MOV     DPL,R2
   \   00019B   8B83         MOV     DPH,R3
   \   00019D   74FF         MOV     A,#-0x1
   \   00019F   F0           MOVX    @DPTR,A
   \   0001A0   A3           INC     DPTR
   \   0001A1   F0           MOVX    @DPTR,A
   1111                  pRsp->nwkUpdateId = 0;
   \   0001A2   8882         MOV     DPL,R0
   \   0001A4   8983         MOV     DPH,R1
   \   0001A6   E4           CLR     A
   \   0001A7   8017         SJMP    ??zll_SendScanRsp_4
   1112                }
   1113                else
   1114                {
   1115                  pRsp->nwkAddr = _NIB.nwkDevAddress;
   \                     ??zll_SendScanRsp_3:
   \   0001A9   90....       MOV     DPTR,#_NIB + 20
   \   0001AC   12....       LCALL   ??Subroutine44_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_108:
   \   0001AF   8A82         MOV     DPL,R2
   \   0001B1   8B83         MOV     DPH,R3
   \   0001B3   EC           MOV     A,R4
   \   0001B4   F0           MOVX    @DPTR,A
   \   0001B5   A3           INC     DPTR
   \   0001B6   ED           MOV     A,R5
   \   0001B7   F0           MOVX    @DPTR,A
   1116                  pRsp->nwkUpdateId = _NIB.nwkUpdateId;
   \   0001B8   90....       MOV     DPTR,#_NIB + 109
   \   0001BB   E0           MOVX    A,@DPTR
   \   0001BC   8882         MOV     DPL,R0
   \   0001BE   8983         MOV     DPH,R1
   \                     ??zll_SendScanRsp_4:
   \   0001C0   F0           MOVX    @DPTR,A
   1117                }
   1118                pRsp->PANID = _NIB.nwkPanId;
   \   0001C1   90....       MOV     DPTR,#_NIB + 33
   \   0001C4   12....       LCALL   ??Subroutine43_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   0001C7   EE           MOV     A,R6
   \   0001C8   2419         ADD     A,#0x19
   \   0001CA   12....       LCALL   ??Subroutine40_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   0001CD   12....       LCALL   ?Subroutine19 & 0xFFFF
   1119                pRsp->logicalChannel = _NIB.nwkLogicalChannel;
   \                     ??CrossCallReturnLabel_63:
   \   0001D0   90....       MOV     DPTR,#_NIB + 22
   \   0001D3   E0           MOVX    A,@DPTR
   \   0001D4   C0E0         PUSH    A
   \   0001D6   EE           MOV     A,R6
   \   0001D7   2418         ADD     A,#0x18
   \   0001D9   12....       LCALL   ??Subroutine40_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   0001DC   D0E0         POP     A
   \   0001DE   F0           MOVX    @DPTR,A
   1120                osal_cpyExtAddr( pRsp->extendedPANID, _NIB.extendedPANID );
   \   0001DF                ; Setup parameters for call to function sAddrExtCpy
   \   0001DF   7C..         MOV     R4,#(_NIB + 53) & 0xff
   \   0001E1   7D..         MOV     R5,#((_NIB + 53) >> 8) & 0xff
   \   0001E3   EE           MOV     A,R6
   \   0001E4   240F         ADD     A,#0xf
   \   0001E6   FA           MOV     R2,A
   \   0001E7   EF           MOV     A,R7
   \   0001E8   3400         ADDC    A,#0x0
   \   0001EA   FB           MOV     R3,A
   \   0001EB   12....       LCALL   ??sAddrExtCpy?relay
   1121          
   1122                pRsp->numSubDevices = zll_GetNumSubDevices( 0 );
   \   0001EE                ; Setup parameters for call to function zll_GetNumSubDevices
   \   0001EE   7900         MOV     R1,#0x0
   \   0001F0   12....       LCALL   ??zll_GetNumSubDevices?relay
   \   0001F3   E9           MOV     A,R1
   \   0001F4   F8           MOV     R0,A
   \   0001F5   EE           MOV     A,R6
   \   0001F6   241D         ADD     A,#0x1d
   \   0001F8   12....       LCALL   ??Subroutine40_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   0001FB   E8           MOV     A,R0
   \   0001FC   F0           MOVX    @DPTR,A
   1123                if ( pRsp->numSubDevices == 1 )
   \   0001FD   7401         MOV     A,#0x1
   \   0001FF   68           XRL     A,R0
   \   000200   700D         JNZ     ??zll_SendScanRsp_5
   1124                {
   1125                  zll_GetSubDeviceInfo( 0, &(pRsp->deviceInfo) );
   \   000202                ; Setup parameters for call to function zll_GetSubDeviceInfo
   \   000202   EE           MOV     A,R6
   \   000203   241F         ADD     A,#0x1f
   \   000205   FA           MOV     R2,A
   \   000206   EF           MOV     A,R7
   \   000207   3400         ADDC    A,#0x0
   \   000209   FB           MOV     R3,A
   \   00020A   7900         MOV     R1,#0x0
   \   00020C   12....       LCALL   ??zll_GetSubDeviceInfo?relay
   1126                }
   1127          
   1128                pRsp->totalGrpIDs = zll_GetNumGrpIDs();
   \                     ??zll_SendScanRsp_5:
   \   00020F                ; Setup parameters for call to function zll_GetNumGrpIDs
   \   00020F   12....       LCALL   ??zll_GetNumGrpIDs?relay
   \   000212   EE           MOV     A,R6
   \   000213   241E         ADD     A,#0x1e
   \   000215   12....       LCALL   ??Subroutine40_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   000218   E9           MOV     A,R1
   \   000219   F0           MOVX    @DPTR,A
   1129          
   1130                // Send a response back
   1131                status = zclLL_Send_ScanRsp( srcEP, dstAddr, pRsp, seqNum );
   \   00021A                ; Setup parameters for call to function zclLL_Send_ScanRsp
   \   00021A   E5..         MOV     A,?V0 + 3
   \   00021C   F5..         MOV     ?V0 + 0,A
   \   00021E   78..         MOV     R0,#?V0 + 0
   \   000220   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000223   EE           MOV     A,R6
   \   000224   FC           MOV     R4,A
   \   000225   EF           MOV     A,R7
   \   000226   FD           MOV     R5,A
   \   000227   AA..         MOV     R2,?V0 + 12
   \   000229   AB..         MOV     R3,?V0 + 13
   \   00022B   A9..         MOV     R1,?V0 + 2
   \   00022D   12....       LCALL   ??zclLL_Send_ScanRsp?relay
   \   000230   7401         MOV     A,#0x1
   \   000232   12....       LCALL   ?DEALLOC_XSTACK8
   \   000235   E9           MOV     A,R1
   \   000236   F5..         MOV     ?V0 + 0,A
   1132          
   1133                osal_mem_free( pRsp );
   \   000238                ; Setup parameters for call to function osal_mem_free
   \   000238   EE           MOV     A,R6
   \   000239   FA           MOV     R2,A
   \   00023A   EF           MOV     A,R7
   \   00023B   FB           MOV     R3,A
   \   00023C   12....       LCALL   ??osal_mem_free?relay
   \   00023F   8003         SJMP    ??zll_SendScanRsp_0
   1134              }
   1135              else
   1136              {
   1137                status = ZMemError;
   \                     ??zll_SendScanRsp_1:
   \   000241   75..10       MOV     ?V0 + 0,#0x10
   1138              }
   1139            }
   1140          
   1141            return ( status );
   \                     ??zll_SendScanRsp_0:
   \   000244   A9..         MOV     R1,?V0 + 0
   \   000246   02....       LJMP    ?Subroutine2 & 0xFFFF
   1142          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   FA           MOV     R2,A
   \   000001   EF           MOV     A,R7
   \   000002   3400         ADDC    A,#0x0
   \   000004   FB           MOV     R3,A
   \   000005   85..82       MOV     DPL,?V0 + 0
   \   000008   85..83       MOV     DPH,?V0 + 1
   \   00000B   22           RET
   1143          
   1144          /*********************************************************************
   1145           * @fn      zll_SendDeviceInfoRsp
   1146           *
   1147           * @brief   Send out a Device Information Response command.
   1148           *
   1149           * @param   srcEP - sender's endpoint
   1150           * @param   dstAddr - destination address
   1151           * @param   startIndex - start index
   1152           * @param   transID - received transaction id
   1153           * @param   seqNum - received sequence number
   1154           *
   1155           * @return  ZStatus_t
   1156           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1157          uint8 zll_SendDeviceInfoRsp( uint8 srcEP, afAddrType_t *dstAddr, uint8 startIndex,
   \                     zll_SendDeviceInfoRsp:
   1158                                       uint32 transID, uint8 seqNum )
   1159          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 8,R1
   \   000007   8A..         MOV     ?V0 + 10,R2
   \   000009   8B..         MOV     ?V0 + 11,R3
   \   00000B   8C..         MOV     ?V0 + 2,R4
   \   00000D   8D..         MOV     ?V0 + 9,R5
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   78..         MOV     R0,#?V0 + 4
   \   000016   12....       LCALL   ?L_MOV_X
   1160            zclLLDeviceInfoRsp_t *pRsp;
   1161            uint8 cnt;
   1162            uint8 rspLen;
   1163            uint8 status = ZSuccess;
   1164          
   1165            cnt = zll_GetNumSubDevices( startIndex );
   \   000019                ; Setup parameters for call to function zll_GetNumSubDevices
   \   000019   A9..         MOV     R1,?V0 + 2
   \   00001B   12....       LCALL   ??zll_GetNumSubDevices?relay
   \   00001E   E9           MOV     A,R1
   \   00001F   F5..         MOV     ?V0 + 3,A
   1166            if ( cnt > ZLL_DEVICE_INFO_RSP_REC_COUNT_MAX )
   \   000021   C3           CLR     C
   \   000022   9406         SUBB    A,#0x6
   \   000024   4003         JC      ??zll_SendDeviceInfoRsp_0
   1167            {
   1168              cnt = ZLL_DEVICE_INFO_RSP_REC_COUNT_MAX; // should be between 0x00-0x05
   \   000026   75..05       MOV     ?V0 + 3,#0x5
   1169            }
   1170          
   1171            rspLen = sizeof( zclLLDeviceInfoRsp_t ) + ( cnt * sizeof( devInfoRec_t ) );
   1172          
   1173            pRsp = (zclLLDeviceInfoRsp_t *)osal_mem_alloc( rspLen );
   \                     ??zll_SendDeviceInfoRsp_0:
   \   000029                ; Setup parameters for call to function osal_mem_alloc
   \   000029   E5..         MOV     A,?V0 + 3
   \   00002B   C4           SWAP    A
   \   00002C   54F0         ANL     A,#0xf0
   \   00002E   2409         ADD     A,#0x9
   \   000030   FA           MOV     R2,A
   \   000031   7B00         MOV     R3,#0x0
   \   000033   12....       LCALL   ??osal_mem_alloc?relay
   \   000036   8A..         MOV     ?V0 + 0,R2
   \   000038   8B..         MOV     ?V0 + 1,R3
   \   00003A   AE..         MOV     R6,?V0 + 0
   \   00003C   AF..         MOV     R7,?V0 + 1
   1174            if ( pRsp )
   \   00003E   EE           MOV     A,R6
   \   00003F   4F           ORL     A,R7
   \   000040   7003         JNZ     $+5
   \   000042   02....       LJMP    ??zll_SendDeviceInfoRsp_1 & 0xFFFF
   1175            {
   1176              pRsp->transID = transID;
   \   000045   8E82         MOV     DPL,R6
   \   000047   8F83         MOV     DPH,R7
   \   000049   78..         MOV     R0,#?V0 + 4
   \   00004B   12....       LCALL   ?L_MOV_TO_X
   1177          
   1178              pRsp->numSubDevices = zll_GetNumSubDevices( 0 );
   \   00004E                ; Setup parameters for call to function zll_GetNumSubDevices
   \   00004E   7900         MOV     R1,#0x0
   \   000050   12....       LCALL   ??zll_GetNumSubDevices?relay
   \   000053   E9           MOV     A,R1
   \   000054   8E82         MOV     DPL,R6
   \   000056   8F83         MOV     DPH,R7
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   12....       LCALL   ?Subroutine33 & 0xFFFF
   1179              pRsp->startIndex = startIndex;
   \                     ??CrossCallReturnLabel_43:
   \   00005F   E5..         MOV     A,?V0 + 2
   \   000061   12....       LCALL   ?Subroutine21 & 0xFFFF
   1180              pRsp->cnt = cnt;
   \                     ??CrossCallReturnLabel_25:
   \   000064   E5..         MOV     A,?V0 + 3
   \   000066   F0           MOVX    @DPTR,A
   1181          
   1182              for ( uint8 i = 0; i < cnt; i++ )
   \   000067   75..00       MOV     ?V0 + 4,#0x0
   \   00006A   8052         SJMP    ??zll_SendDeviceInfoRsp_2
   1183              {
   1184                devInfoRec_t *pRec = &(pRsp->devInfoRec[i]);
   \                     ??zll_SendDeviceInfoRsp_3:
   \   00006C   85....       MOV     ?V0 + 0,?V0 + 4
   \   00006F   75..00       MOV     ?V0 + 1,#0x0
   \   000072   7404         MOV     A,#0x4
   \   000074   78..         MOV     R0,#?V0 + 0
   \   000076   12....       LCALL   ?S_SHL
   \   000079   8E82         MOV     DPL,R6
   \   00007B   8F83         MOV     DPH,R7
   \   00007D   A3           INC     DPTR
   \   00007E   A3           INC     DPTR
   \   00007F   A3           INC     DPTR
   \   000080   A3           INC     DPTR
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   A3           INC     DPTR
   \   000084   E0           MOVX    A,@DPTR
   \   000085   25..         ADD     A,?V0 + 0
   \   000087   F5..         MOV     ?V0 + 0,A
   \   000089   A3           INC     DPTR
   \   00008A   E0           MOVX    A,@DPTR
   \   00008B   35..         ADDC    A,?V0 + 1
   \   00008D   F5..         MOV     ?V0 + 1,A
   1185          
   1186                osal_cpyExtAddr( pRec->ieeeAddr, NLME_GetExtAddr() );
   \   00008F                ; Setup parameters for call to function sAddrExtCpy
   \   00008F                ; Setup parameters for call to function NLME_GetExtAddr
   \   00008F   12....       LCALL   ??NLME_GetExtAddr?relay
   \   000092   EA           MOV     A,R2
   \   000093   FC           MOV     R4,A
   \   000094   EB           MOV     A,R3
   \   000095   FD           MOV     R5,A
   \   000096   AA..         MOV     R2,?V0 + 0
   \   000098   AB..         MOV     R3,?V0 + 1
   \   00009A   12....       LCALL   ??sAddrExtCpy?relay
   1187          
   1188                zll_GetSubDeviceInfo( startIndex + i, &(pRec->deviceInfo) );
   \   00009D                ; Setup parameters for call to function zll_GetSubDeviceInfo
   \   00009D   E5..         MOV     A,?V0 + 0
   \   00009F   2408         ADD     A,#0x8
   \   0000A1   FA           MOV     R2,A
   \   0000A2   E5..         MOV     A,?V0 + 1
   \   0000A4   3400         ADDC    A,#0x0
   \   0000A6   FB           MOV     R3,A
   \   0000A7   E5..         MOV     A,?V0 + 2
   \   0000A9   25..         ADD     A,?V0 + 4
   \   0000AB   F9           MOV     R1,A
   \   0000AC   12....       LCALL   ??zll_GetSubDeviceInfo?relay
   1189          
   1190                pRec->sort = 0;
   \   0000AF   E5..         MOV     A,?V0 + 0
   \   0000B1   240F         ADD     A,#0xf
   \   0000B3   F582         MOV     DPL,A
   \   0000B5   E5..         MOV     A,?V0 + 1
   \   0000B7   12....       LCALL   ??Subroutine41_0 & 0xFFFF
   1191              }
   \                     ??CrossCallReturnLabel_76:
   \   0000BA   E4           CLR     A
   \   0000BB   F0           MOVX    @DPTR,A
   \   0000BC   05..         INC     ?V0 + 4
   \                     ??zll_SendDeviceInfoRsp_2:
   \   0000BE   E5..         MOV     A,?V0 + 4
   \   0000C0   C3           CLR     C
   \   0000C1   95..         SUBB    A,?V0 + 3
   \   0000C3   40A7         JC      ??zll_SendDeviceInfoRsp_3
   1192          
   1193              // Send a response back
   1194              status = zclLL_Send_DeviceInfoRsp( srcEP, dstAddr, pRsp, seqNum );
   \   0000C5                ; Setup parameters for call to function zclLL_Send_DeviceInfoRsp
   \   0000C5   E5..         MOV     A,?V0 + 9
   \   0000C7   F5..         MOV     ?V0 + 0,A
   \   0000C9   78..         MOV     R0,#?V0 + 0
   \   0000CB   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000CE   EE           MOV     A,R6
   \   0000CF   FC           MOV     R4,A
   \   0000D0   EF           MOV     A,R7
   \   0000D1   FD           MOV     R5,A
   \   0000D2   AA..         MOV     R2,?V0 + 10
   \   0000D4   AB..         MOV     R3,?V0 + 11
   \   0000D6   A9..         MOV     R1,?V0 + 8
   \   0000D8   12....       LCALL   ??zclLL_Send_DeviceInfoRsp?relay
   \   0000DB   7401         MOV     A,#0x1
   \   0000DD   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E0   E9           MOV     A,R1
   \   0000E1   F5..         MOV     ?V0 + 0,A
   1195          
   1196              osal_mem_free( pRsp );
   \   0000E3                ; Setup parameters for call to function osal_mem_free
   \   0000E3   EE           MOV     A,R6
   \   0000E4   FA           MOV     R2,A
   \   0000E5   EF           MOV     A,R7
   \   0000E6   FB           MOV     R3,A
   \   0000E7   12....       LCALL   ??osal_mem_free?relay
   \   0000EA   8003         SJMP    ??zll_SendDeviceInfoRsp_4
   1197            }
   1198            else
   1199            {
   1200              status = ZMemError;
   \                     ??zll_SendDeviceInfoRsp_1:
   \   0000EC   75..10       MOV     ?V0 + 0,#0x10
   1201            }
   1202          
   1203            return ( status );
   \                     ??zll_SendDeviceInfoRsp_4:
   \   0000EF   A9..         MOV     R1,?V0 + 0
   \   0000F1                REQUIRE ?Subroutine6
   \   0000F1                ; // Fall through to label ?Subroutine6
   1204          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   7F0C         MOV     R7,#0xc
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   1205          
   1206          /*********************************************************************
   1207           * @fn      zll_SendLeaveReq
   1208           *
   1209           * @brief   Send out a Leave Request command.
   1210           *
   1211           * @param   void
   1212           *
   1213           * @return  ZStatus_t
   1214           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1215          ZStatus_t zll_SendLeaveReq( void )
   \                     zll_SendLeaveReq:
   1216          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 5
   \   000004   74FB         MOV     A,#-0x5
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1217            NLME_LeaveReq_t leaveReq;
   1218          
   1219            // Set every field to 0
   1220            osal_memset( &leaveReq, 0, sizeof( NLME_LeaveReq_t ) );
   \   000009                ; Setup parameters for call to function osal_memset
   \   000009   7C05         MOV     R4,#0x5
   \   00000B   7D00         MOV     R5,#0x0
   \   00000D   7900         MOV     R1,#0x0
   \   00000F   85..82       MOV     DPL,?XSP + 0
   \   000012   85..83       MOV     DPH,?XSP + 1
   \   000015   AA82         MOV     R2,DPL
   \   000017   AB83         MOV     R3,DPH
   \   000019   12....       LCALL   ??osal_memset?relay
   1221          
   1222            // Send out our leave
   1223            return ( NLME_LeaveReq( &leaveReq ) );
   \   00001C                ; Setup parameters for call to function NLME_LeaveReq
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   AA82         MOV     R2,DPL
   \   000024   AB83         MOV     R3,DPH
   \   000026   12....       LCALL   ??NLME_LeaveReq?relay
   \   000029   7405         MOV     A,#0x5
   \   00002B   02....       LJMP    ?Subroutine1 & 0xFFFF
   1224          }
   1225          
   1226          /*********************************************************************
   1227           * @fn      zll_ResetToFactoryNew
   1228           *
   1229           * @brief   Reset to factory new.
   1230           *
   1231           * @param   initiator - initialize initiator
   1232           *
   1233           * @return  none
   1234           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1235          void zll_ResetToFactoryNew( bool initiator )
   \                     zll_ResetToFactoryNew:
   1236          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   1237            // Set the NV startup option to force a "new" join.
   1238            zgWriteStartupOptions( ZG_STARTUP_SET, ZCD_STARTOPT_DEFAULT_NETWORK_STATE );
   \   000007                ; Setup parameters for call to function zgWriteStartupOptions
   \   000007   7A02         MOV     R2,#0x2
   \   000009   79FF         MOV     R1,#-0x1
   \   00000B   12....       LCALL   ??zgWriteStartupOptions?relay
   1239          
   1240            // Leave the network, and reset afterwards
   1241            if ( zll_SendLeaveReq() != ZSuccess )
   \   00000E                ; Setup parameters for call to function zll_SendLeaveReq
   \   00000E   12....       LCALL   ??zll_SendLeaveReq?relay
   \   000011   E9           MOV     A,R1
   \   000012   6005         JZ      ??zll_ResetToFactoryNew_0
   1242            {
   1243              // Couldn't send out leave; prepare to reset anyway
   1244              ZDApp_LeaveReset( FALSE );
   \   000014                ; Setup parameters for call to function ZDApp_LeaveReset
   \   000014   7900         MOV     R1,#0x0
   \   000016   12....       LCALL   ??ZDApp_LeaveReset?relay
   1245            }
   1246          
   1247            // Reset our free ranges
   1248            zll_InitFreeRanges( initiator );
   \                     ??zll_ResetToFactoryNew_0:
   \   000019                ; Setup parameters for call to function zll_InitFreeRanges
   \   000019   EE           MOV     A,R6
   \   00001A   F9           MOV     R1,A
   \   00001B   12....       LCALL   ??zll_InitFreeRanges?relay
   1249          
   1250            _NIB.nwkDevAddress = INVALID_NODE_ADDR;
   \   00001E   90....       MOV     DPTR,#_NIB + 20
   \   000021   12....       LCALL   ?Subroutine26 & 0xFFFF
   1251            _NIB.nwkCoordAddress = INVALID_NODE_ADDR;
   \                     ??CrossCallReturnLabel_51:
   \   000024   90....       MOV     DPTR,#_NIB + 23
   \   000027   14           DEC     A
   \   000028   12....       LCALL   ??Subroutine35_0 & 0xFFFF
   1252            _NIB.nwkPanId = 0xFFFF;
   \                     ??CrossCallReturnLabel_48:
   \   00002B   90....       MOV     DPTR,#_NIB + 33
   \   00002E   F0           MOVX    @DPTR,A
   \   00002F   A3           INC     DPTR
   \   000030   F0           MOVX    @DPTR,A
   1253            osal_memset(_NIB.extendedPANID, 0, Z_EXTADDR_LEN);
   \   000031                ; Setup parameters for call to function osal_memset
   \   000031   7C08         MOV     R4,#0x8
   \   000033   7D00         MOV     R5,#0x0
   \   000035   7900         MOV     R1,#0x0
   \   000037   7A..         MOV     R2,#(_NIB + 53) & 0xff
   \   000039   7B..         MOV     R3,#((_NIB + 53) >> 8) & 0xff
   \   00003B   12....       LCALL   ??osal_memset?relay
   1254            _NIB.nwkUpdateId = 0;
   \   00003E   90....       MOV     DPTR,#_NIB + 109
   \   000041   E4           CLR     A
   \   000042   F0           MOVX    @DPTR,A
   1255            ZDSecMgrUpdateTCAddress( NULL );
   \   000043                ; Setup parameters for call to function ZDSecMgrUpdateTCAddress
   \   000043   FA           MOV     R2,A
   \   000044   FB           MOV     R3,A
   \   000045   12....       LCALL   ??ZDSecMgrUpdateTCAddress?relay
   1256          
   1257            // Save free ranges in NV
   1258            zll_UpdateNV( ZLL_UPDATE_NV_RANGES | ZLL_UPDATE_NV_NIB );
   \   000048                ; Setup parameters for call to function zll_UpdateNV
   \   000048   7903         MOV     R1,#0x3
   \   00004A   12....       LCALL   ??zll_UpdateNV?relay
   1259          }
   \   00004D   02....       LJMP    ?Subroutine5 & 0xFFFF
   1260          
   1261          /*********************************************************************
   1262           * @fn      zll_GetMsgRssi
   1263           *
   1264           * @brief   Get the RSSI of the message just received through a ZCL callback.
   1265           *
   1266           * @param   none
   1267           *
   1268           * @return  RSSI if AF message was received, ZLL_TL_WORST_RSSI otherwise.
   1269           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1270          int8 zll_GetMsgRssi( void )
   \                     zll_GetMsgRssi:
   1271          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1272            afIncomingMSGPacket_t *pAF = zcl_getRawAFMsg();
   \   000005                ; Setup parameters for call to function zcl_getRawAFMsg
   \   000005   12....       LCALL   ??zcl_getRawAFMsg?relay
   \   000008   8A..         MOV     ?V0 + 0,R2
   \   00000A   8B..         MOV     ?V0 + 1,R3
   \   00000C   A8..         MOV     R0,?V0 + 0
   \   00000E   A9..         MOV     R1,?V0 + 1
   1273          
   1274            if ( pAF != NULL )
   \   000010   E8           MOV     A,R0
   \   000011   49           ORL     A,R1
   \   000012   6009         JZ      ??zll_GetMsgRssi_0
   1275            {
   1276              return ( pAF->rssi );
   \   000014   E8           MOV     A,R0
   \   000015   2418         ADD     A,#0x18
   \   000017   12....       LCALL   ??Subroutine47_0 & 0xFFFF
   1277            }
   \                     ??CrossCallReturnLabel_128:
   \   00001A   F9           MOV     R1,A
   \   00001B   8002         SJMP    ??zll_GetMsgRssi_1
   1278          
   1279            return ( ZLL_TL_WORST_RSSI );
   \                     ??zll_GetMsgRssi_0:
   \   00001D   79D8         MOV     R1,#-0x28
   \                     ??zll_GetMsgRssi_1:
   \   00001F   02....       LJMP    ??Subroutine36_0 & 0xFFFF
   1280          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine47_0:
   \   000000   F582         MOV     DPL,A
   \   000002   E9           MOV     A,R1
   \   000003                REQUIRE ??Subroutine48_0
   \   000003                ; // Fall through to label ??Subroutine48_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine48_0:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F583         MOV     DPH,A
   \   000004   E0           MOVX    A,@DPTR
   \   000005   22           RET
   1281          
   1282          /*********************************************************************
   1283           * @fn      zll_NewNwkUpdateId
   1284           *
   1285           * @brief   Determine the new network update id. The nwkUpdateId attribute
   1286           *          can take the value of 0x00 - 0xff and may wrap around so care
   1287           *          must be taken when comparing for newness.
   1288           *
   1289           * @param   ID1 - first nwk update id
   1290           * @param   ID2 - second nwk update id
   1291           *
   1292           * @return  new nwk update ID
   1293           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1294          uint8 zll_NewNwkUpdateId( uint8 ID1, uint8 ID2 )
   \                     zll_NewNwkUpdateId:
   1295          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   1296            if ( ( (ID1 >= ID2) && ((ID1 - ID2) > 200) )
   1297                || ( (ID1 < ID2) && ((ID2 - ID1) > 200) ) )
   \   000007   8A82         MOV     DPL,R2
   \   000009   AC82         MOV     R4,DPL
   \   00000B   8E82         MOV     DPL,R6
   \   00000D   A882         MOV     R0,DPL
   \   00000F   C3           CLR     C
   \   000010   9A           SUBB    A,R2
   \   000011   400F         JC      ??zll_NewNwkUpdateId_0
   \   000013   E8           MOV     A,R0
   \   000014   C3           CLR     C
   \   000015   9C           SUBB    A,R4
   \   000016   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000019   5012         JNC     ??zll_NewNwkUpdateId_1
   \   00001B   EE           MOV     A,R6
   \                     ??zll_NewNwkUpdateId_2:
   \   00001C   FB           MOV     R3,A
   \   00001D   EB           MOV     A,R3
   \                     ??zll_NewNwkUpdateId_3:
   \   00001E   F9           MOV     R1,A
   \   00001F   02....       LJMP    ?Subroutine5 & 0xFFFF
   \                     ??zll_NewNwkUpdateId_0:
   \   000022   EC           MOV     A,R4
   \   000023   C3           CLR     C
   \   000024   98           SUBB    A,R0
   \   000025   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   000028   4006         JC      ??zll_NewNwkUpdateId_4
   \   00002A   EE           MOV     A,R6
   \   00002B   80F1         SJMP    ??zll_NewNwkUpdateId_3
   \                     ??zll_NewNwkUpdateId_1:
   \   00002D   EA           MOV     A,R2
   \   00002E   80EE         SJMP    ??zll_NewNwkUpdateId_3
   \                     ??zll_NewNwkUpdateId_4:
   \   000030   EA           MOV     A,R2
   \   000031   80E9         SJMP    ??zll_NewNwkUpdateId_2
   1298            {
   1299              return ( MIN( ID1, ID2 ) );
   1300            }
   1301          
   1302            return ( MAX( ID1, ID2 ) );
   1303          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   F8           MOV     R0,A
   \   000001   95E0         SUBB    A,0xE0 /* A   */
   \   000003   F9           MOV     R1,A
   \   000004   C3           CLR     C
   \   000005   E8           MOV     A,R0
   \   000006   94C9         SUBB    A,#-0x37
   \   000008   E9           MOV     A,R1
   \   000009   9400         SUBB    A,#0x0
   \   00000B   A2D2         MOV     C,0xD0 /* PSW */.2
   \   00000D   65D0         XRL     A,PSW
   \   00000F   33           RLC     A
   \   000010   22           RET
   1304          
   1305          /*********************************************************************
   1306           * @fn      zll_SetZllTaskId
   1307           *
   1308           * @brief   Register Target/Initiator taskID for commissioning events
   1309           *
   1310           * @param   taskID
   1311           *
   1312           * @return  none
   1313           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1314          void zll_SetZllTaskId( uint8 taskID )
   \                     zll_SetZllTaskId:
   1315          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   1316            zllTaskId = taskID;
   \   000006   90....       MOV     DPTR,#zllTaskId
   \   000009   F0           MOVX    @DPTR,A
   1317          
   1318            // register internal EP for ZLL messages
   1319            zll_RegisterSimpleDesc( &zll_EP_SimpleDesc );
   \   00000A                ; Setup parameters for call to function zll_RegisterSimpleDesc
   \   00000A   7A..         MOV     R2,#zll_EP_SimpleDesc & 0xff
   \   00000C   7B..         MOV     R3,#(zll_EP_SimpleDesc >> 8) & 0xff
   \   00000E   12....       LCALL   ??zll_RegisterSimpleDesc?relay
   1320          
   1321          #if defined( INTER_PAN )
   1322            // Register with Stub APS
   1323            StubAPS_RegisterApp( &zll_EP );
   \   000011                ; Setup parameters for call to function StubAPS_RegisterApp
   \   000011   7A..         MOV     R2,#zll_EP & 0xff
   \   000013   7B..         MOV     R3,#(zll_EP >> 8) & 0xff
   \   000015   12....       LCALL   ??StubAPS_RegisterApp?relay
   1324          #endif // INTER_PAN
   1325          }
   \   000018   02....       LJMP    ?Subroutine5 & 0xFFFF
   1326          
   1327          /*********************************************************************
   1328           * @fn      zll_ClassicalCommissioningInit
   1329           *
   1330           * @brief   Initiate Classical ZigBee commissioning of ZLL device
   1331           *
   1332           * @param   none
   1333           *
   1334           * @return  status
   1335           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1336          ZStatus_t zll_ClassicalCommissioningInit()
   \                     zll_ClassicalCommissioningInit:
   1337          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1338            zllHAScanInitiated = ZLL_SCAN_PRIMARY_CHANNELS;
   \   000004   90....       MOV     DPTR,#zllHAScanInitiated
   \   000007   7401         MOV     A,#0x1
   \   000009   F0           MOVX    @DPTR,A
   1339            NLME_NwkDiscTerm();
   \   00000A                ; Setup parameters for call to function NLME_NwkDiscTerm
   \   00000A   12....       LCALL   ??NLME_NwkDiscTerm?relay
   1340            osal_stop_timerEx( ZDAppTaskID, ZDO_NETWORK_INIT );
   \   00000D                ; Setup parameters for call to function osal_stop_timerEx
   \   00000D   7A01         MOV     R2,#0x1
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   90....       MOV     DPTR,#ZDAppTaskID
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F9           MOV     R1,A
   \   000016   12....       LCALL   ??osal_stop_timerEx?relay
   1341            _NIB.nwkState = NWK_INIT;
   \   000019   90....       MOV     DPTR,#_NIB + 35
   \   00001C   E4           CLR     A
   \   00001D   F0           MOVX    @DPTR,A
   1342            return ( zll_ClassicalCommissioningNetworkDisc() );
   \   00001E                ; Setup parameters for call to function zll_ClassicalCommissioningNetworkDisc
   \   00001E   12....       LCALL   ??zll_ClassicalCommissioningNetworkDisc?relay
   \   000021   02....       LJMP    ??Subroutine39_0 & 0xFFFF
   1343          }
   1344          
   1345          /*********************************************************************
   1346           * @fn      zll_ClassicalCommissioningNetworkDisc
   1347           *
   1348           * @brief   Initiate Network Discovery on Primary or Seconday channels
   1349           *          to allow choosing network to join.
   1350           *
   1351           * @param   none
   1352           *
   1353           * @return  status
   1354           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1355          static ZStatus_t zll_ClassicalCommissioningNetworkDisc( void )
   \                     zll_ClassicalCommissioningNetworkDisc:
   1356          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1357            if ( pDiscoveredNwkParamList == NULL )
   \   000004   12....       LCALL   ??Subroutine45_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   000007   701F         JNZ     ??zll_ClassicalCommissioningNetworkDisc_0
   1358            {
   1359              if ( zllHAScanInitiated == ZLL_SCAN_PRIMARY_CHANNELS )
   \   000009   90....       MOV     DPTR,#zllHAScanInitiated
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   6401         XRL     A,#0x1
   \   00000F   7005         JNZ     ??zll_ClassicalCommissioningNetworkDisc_1
   1360              {
   1361                // Use the primary ZLL channel list
   1362                zll_PerformNetworkDisc(ZLL_PRIMARY_CHANNEL_LIST);
   \   000011                ; Setup parameters for call to function zll_PerformNetworkDisc
   \   000011   90....       MOV     DPTR,#__Constant_2108800
   \   000014   8008         SJMP    ??zll_ClassicalCommissioningNetworkDisc_2
   1363                return ( ZSuccess );
   1364              }
   1365              else if ( zllHAScanInitiated == ZLL_SCAN_SECONDARY_CHANNELS )
   \                     ??zll_ClassicalCommissioningNetworkDisc_1:
   \   000016   E0           MOVX    A,@DPTR
   \   000017   6402         XRL     A,#0x2
   \   000019   700D         JNZ     ??zll_ClassicalCommissioningNetworkDisc_0
   1366              {
   1367                // Use the secondary ZLL channel list
   1368                zll_PerformNetworkDisc(ZLL_SECONDARY_CHANNEL_LIST);
   \   00001B                ; Setup parameters for call to function zll_PerformNetworkDisc
   \   00001B   90....       MOV     DPTR,#__Constant_5ef7000
   \                     ??zll_ClassicalCommissioningNetworkDisc_2:
   \   00001E   12....       LCALL   ?XLOAD_R2345
   \   000021   12....       LCALL   ??zll_PerformNetworkDisc?relay
   1369                return ( ZSuccess );
   \   000024   7900         MOV     R1,#0x0
   \   000026   8002         SJMP    ??zll_ClassicalCommissioningNetworkDisc_3
   1370              }
   1371            }
   1372          
   1373            return ( ZFailure );
   \                     ??zll_ClassicalCommissioningNetworkDisc_0:
   \   000028   7901         MOV     R1,#0x1
   \                     ??zll_ClassicalCommissioningNetworkDisc_3:
   \   00002A   02....       LJMP    ??Subroutine39_0 & 0xFFFF
   1374          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine45_0:
   \   000000   90....       MOV     DPTR,#pDiscoveredNwkParamList
   \   000003                REQUIRE ??Subroutine46_0
   \   000003                ; // Fall through to label ??Subroutine46_0
   1375          
   1376          /*********************************************************************
   1377           * @fn      zll_ClassicalCommissioningJoinDiscoveredNwk
   1378           *
   1379           * @brief   Join best network discovered by classical commissioning
   1380           *
   1381           * @param   void
   1382           *
   1383           * @return  ZStatus
   1384           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1385          ZStatus_t zll_ClassicalCommissioningJoinDiscoveredNwk( void )
   \                     zll_ClassicalCommissioningJoinDiscoveredNwk:
   1386          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1387            zllHAScanInitiated = FALSE;
   \   000005   90....       MOV     DPTR,#zllHAScanInitiated
   \   000008   E4           CLR     A
   \   000009   12....       LCALL   ?Subroutine7 & 0xFFFF
   1388            // it will try to scan primary and secondary channel list
   1389            if ( pDiscoveredNwkParamList == NULL )
   \                     ??CrossCallReturnLabel_113:
   \   00000C   606C         JZ      ??zll_ClassicalCommissioningJoinDiscoveredNwk_0
   1390            {
   1391              return ( ZFailure );
   1392            }
   1393            zllDiscoveredNwkParam_t *pParam = pDiscoveredNwkParamList;
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F9           MOV     R1,A
   1394            zllDiscoveredNwkParam_t *pChosenNwk = NULL;
   \   000010   8004         SJMP    ??zll_ClassicalCommissioningJoinDiscoveredNwk_1
   1395          
   1396            // Add the network parameter to the Network Parameter List
   1397            while ( pParam != NULL )
   1398            {
   1399              if ( pChosenNwk == NULL )
   \                     ??zll_ClassicalCommissioningJoinDiscoveredNwk_2:
   \   000012   EA           MOV     A,R2
   \   000013   4B           ORL     A,R3
   \   000014   7068         JNZ     ??zll_ClassicalCommissioningJoinDiscoveredNwk_3
   1400              {
   1401                // set it to the first element of the list
   1402                pChosenNwk = pParam;
   \                     ??zll_ClassicalCommissioningJoinDiscoveredNwk_1:
   \   000016   E8           MOV     A,R0
   \   000017   FA           MOV     R2,A
   \   000018   E9           MOV     A,R1
   \   000019   FB           MOV     R3,A
   1403              }
   1404              else
   1405              {
   1406                if ( ((pParam->chosenRouterLinkQuality > pChosenNwk->chosenRouterLinkQuality) &&
   1407                      (pParam->chosenRouterDepth < MAX_NODE_DEPTH)) ||
   1408                    ((pParam->chosenRouterLinkQuality == pChosenNwk->chosenRouterLinkQuality) &&
   1409                     (pParam->chosenRouterDepth < pChosenNwk->chosenRouterDepth)) )
   1410                {
   1411                  pChosenNwk = pParam;  // found the better network to join
   1412                  break;
   1413                }
   1414              }
   1415          
   1416              pParam = pParam->nextParam;
   \                     ??zll_ClassicalCommissioningJoinDiscoveredNwk_4:
   \   00001A   8882         MOV     DPL,R0
   \   00001C   8983         MOV     DPH,R1
   \   00001E   12....       LCALL   ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_115:
   \   000021   70EF         JNZ     ??zll_ClassicalCommissioningJoinDiscoveredNwk_2
   1417            }
   1418          
   1419            if ( pChosenNwk != NULL )
   \   000023   EA           MOV     A,R2
   \   000024   4B           ORL     A,R3
   \   000025   7003         JNZ     $+5
   \   000027   02....       LJMP    ??zll_ClassicalCommissioningJoinDiscoveredNwk_5 & 0xFFFF
   1420            {
   1421              // join that network
   1422              if ( NLME_JoinRequest( pChosenNwk->extendedPANID, pChosenNwk->PANID,
   1423                                    pChosenNwk->logicalChannel,
   1424                                    ZDO_Config_Node_Descriptor.CapabilityFlags,
   1425                                    pChosenNwk->chosenRouter, pChosenNwk->chosenRouterDepth ) != ZSuccess )
   \                     ??zll_ClassicalCommissioningJoinDiscoveredNwk_6:
   \   00002A                ; Setup parameters for call to function NLME_JoinRequest
   \   00002A   EA           MOV     A,R2
   \   00002B   2410         ADD     A,#0x10
   \   00002D   F582         MOV     DPL,A
   \   00002F   EB           MOV     A,R3
   \   000030   12....       LCALL   ??Subroutine48_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   000033   F5..         MOV     ?V0 + 0,A
   \   000035   78..         MOV     R0,#?V0 + 0
   \   000037   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00003A   EA           MOV     A,R2
   \   00003B   240D         ADD     A,#0xd
   \   00003D   F582         MOV     DPL,A
   \   00003F   EB           MOV     A,R3
   \   000040   12....       LCALL   ??Subroutine41_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   000043   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000046   90....       MOV     DPTR,#ZDO_Config_Node_Descriptor + 2
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   F5..         MOV     ?V0 + 0,A
   \   00004C   78..         MOV     R0,#?V0 + 0
   \   00004E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000051   8A82         MOV     DPL,R2
   \   000053   8B83         MOV     DPH,R3
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   F9           MOV     R1,A
   \   00005B   8A82         MOV     DPL,R2
   \   00005D   8B83         MOV     DPH,R3
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   12....       LCALL   ??Subroutine44_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_109:
   \   000064   EA           MOV     A,R2
   \   000065   2405         ADD     A,#0x5
   \   000067   FA           MOV     R2,A
   \   000068   EB           MOV     A,R3
   \   000069   3400         ADDC    A,#0x0
   \   00006B   FB           MOV     R3,A
   \   00006C   12....       LCALL   ??NLME_JoinRequest?relay
   \   00006F   7404         MOV     A,#0x4
   \   000071   12....       LCALL   ?DEALLOC_XSTACK8
   \   000074   E9           MOV     A,R1
   \   000075   6049         JZ      ??zll_ClassicalCommissioningJoinDiscoveredNwk_5
   1426              {
   1427                // do something if it fails to join
   1428                zll_FreeNwkParamList();
   \   000077                ; Setup parameters for call to function zll_FreeNwkParamList
   \   000077   12....       LCALL   ??zll_FreeNwkParamList?relay
   1429                return ( ZFailure );
   \                     ??zll_ClassicalCommissioningJoinDiscoveredNwk_0:
   \   00007A   7901         MOV     R1,#0x1
   \   00007C   806F         SJMP    ??zll_ClassicalCommissioningJoinDiscoveredNwk_7
   1430              }
   1431            }
   \                     ??zll_ClassicalCommissioningJoinDiscoveredNwk_3:
   \   00007E   E8           MOV     A,R0
   \   00007F   240F         ADD     A,#0xf
   \   000081   12....       LCALL   ??Subroutine47_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_129:
   \   000084   FC           MOV     R4,A
   \   000085   EA           MOV     A,R2
   \   000086   240F         ADD     A,#0xf
   \   000088   F582         MOV     DPL,A
   \   00008A   EB           MOV     A,R3
   \   00008B   12....       LCALL   ??Subroutine48_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_125:
   \   00008E   FD           MOV     R5,A
   \   00008F   C3           CLR     C
   \   000090   9C           SUBB    A,R4
   \   000091   500B         JNC     ??zll_ClassicalCommissioningJoinDiscoveredNwk_8
   \   000093   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_130:
   \   000096   C3           CLR     C
   \   000097   9414         SUBB    A,#0x14
   \   000099   401E         JC      ??zll_ClassicalCommissioningJoinDiscoveredNwk_9
   \   00009B   02....       LJMP    ??zll_ClassicalCommissioningJoinDiscoveredNwk_4 & 0xFFFF
   \                     ??zll_ClassicalCommissioningJoinDiscoveredNwk_8:
   \   00009E   ED           MOV     A,R5
   \   00009F   6C           XRL     A,R4
   \   0000A0   6003         JZ      $+5
   \   0000A2   02....       LJMP    ??zll_ClassicalCommissioningJoinDiscoveredNwk_4 & 0xFFFF
   \   0000A5   EA           MOV     A,R2
   \   0000A6   2410         ADD     A,#0x10
   \   0000A8   F582         MOV     DPL,A
   \   0000AA   EB           MOV     A,R3
   \   0000AB   12....       LCALL   ??Subroutine48_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_126:
   \   0000AE   FC           MOV     R4,A
   \   0000AF   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_131:
   \   0000B2   C3           CLR     C
   \   0000B3   9C           SUBB    A,R4
   \   0000B4   4003         JC      $+5
   \   0000B6   02....       LJMP    ??zll_ClassicalCommissioningJoinDiscoveredNwk_4 & 0xFFFF
   \                     ??zll_ClassicalCommissioningJoinDiscoveredNwk_9:
   \   0000B9   E8           MOV     A,R0
   \   0000BA   FA           MOV     R2,A
   \   0000BB   E9           MOV     A,R1
   \   0000BC   FB           MOV     R3,A
   \   0000BD   02....       LJMP    ??zll_ClassicalCommissioningJoinDiscoveredNwk_6 & 0xFFFF
   1432          
   1433            zll_FreeNwkParamList();
   \                     ??zll_ClassicalCommissioningJoinDiscoveredNwk_5:
   \   0000C0                ; Setup parameters for call to function zll_FreeNwkParamList
   \   0000C0   12....       LCALL   ??zll_FreeNwkParamList?relay
   1434            zllJoinedHANetwork = TRUE;
   \   0000C3   90....       MOV     DPTR,#zllJoinedHANetwork
   \   0000C6   7401         MOV     A,#0x1
   \   0000C8   F0           MOVX    @DPTR,A
   1435            zllFreeNwkAddrBegin = zllFreeNwkAddrEnd = zllFreeGrpIdBegin = zllFreeGrpIdEnd = 0;
   \   0000C9   90....       MOV     DPTR,#zllFreeGrpIdEnd
   \   0000CC   E4           CLR     A
   \   0000CD   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   0000D0   F0           MOVX    @DPTR,A
   \   0000D1   90....       MOV     DPTR,#zllFreeNwkAddrEnd
   \   0000D4   12....       LCALL   ?Subroutine23 & 0xFFFF
   1436            devState = DEV_HOLD;
   \                     ??CrossCallReturnLabel_29:
   \   0000D7   90....       MOV     DPTR,#devState
   \   0000DA   F0           MOVX    @DPTR,A
   1437            ZDApp_ResetNwkKey();
   \   0000DB                ; Setup parameters for call to function ZDApp_ResetNwkKey
   \   0000DB   12....       LCALL   ??ZDApp_ResetNwkKey?relay
   1438            _NIB.nwkKeyLoaded = FALSE;
   \   0000DE   90....       MOV     DPTR,#_NIB + 61
   \   0000E1   E4           CLR     A
   \   0000E2   F0           MOVX    @DPTR,A
   1439            zll_UpdateNV( ZLL_UPDATE_NV_NIB | ZLL_UPDATE_NV_RANGES );
   \   0000E3                ; Setup parameters for call to function zll_UpdateNV
   \   0000E3   7903         MOV     R1,#0x3
   \   0000E5   12....       LCALL   ??zll_UpdateNV?relay
   1440            ZDApp_LeaveCtrlReset();
   \   0000E8                ; Setup parameters for call to function ZDApp_LeaveCtrlReset
   \   0000E8   12....       LCALL   ??ZDApp_LeaveCtrlReset?relay
   1441            return ( ZSuccess );
   \   0000EB   7900         MOV     R1,#0x0
   \                     ??zll_ClassicalCommissioningJoinDiscoveredNwk_7:
   \   0000ED                REQUIRE ?Subroutine5
   \   0000ED                ; // Fall through to label ?Subroutine5
   1442          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                REQUIRE ??Subroutine45_0
   \   000001                ; // Fall through to label ??Subroutine45_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   E8           MOV     A,R0
   \   000001   2410         ADD     A,#0x10
   \   000003                REQUIRE ??Subroutine47_0
   \   000003                ; // Fall through to label ??Subroutine47_0
   1443          
   1444          
   1445          /*********************************************************************
   1446           * @fn      zll_PerformNetworkDisc
   1447           *
   1448           * @brief   Perform a Network Discovery scan.
   1449           *          Scan results will be stored locally to analyze.
   1450           *
   1451           * @param   scanChannelList - channels to perform discovery scan
   1452           *
   1453           * @return  void
   1454           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1455          void zll_PerformNetworkDisc( uint32 scanChannelList )
   \                     zll_PerformNetworkDisc:
   1456          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   8C..         MOV     ?V0 + 2,R4
   \   000010   8D..         MOV     ?V0 + 3,R5
   1457            NLME_ScanFields_t scan;
   1458          
   1459            scan.channels = scanChannelList;
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   78..         MOV     R0,#?V0 + 0
   \   00001A   12....       LCALL   ?L_MOV_TO_X
   1460            scan.duration = BEACON_ORDER_240_MSEC;
   \   00001D   7404         MOV     A,#0x4
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   7404         MOV     A,#0x4
   \   000024   F0           MOVX    @DPTR,A
   1461            scan.scanType = ZMAC_ACTIVE_SCAN;
   \   000025   04           INC     A
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   7401         MOV     A,#0x1
   \   00002B   F0           MOVX    @DPTR,A
   1462            scan.scanApp  = NLME_DISC_SCAN;
   \   00002C   7406         MOV     A,#0x6
   \   00002E   12....       LCALL   ?XSTACK_DISP0_8
   \   000031   7401         MOV     A,#0x1
   \   000033   12....       LCALL   ?Subroutine20 & 0xFFFF
   1463          
   1464            if ( NLME_NwkDiscReq2( &scan ) == ZSuccess )
   \                     ??CrossCallReturnLabel_23:
   \   000036   12....       LCALL   ??NLME_NwkDiscReq2?relay
   \   000039   E9           MOV     A,R1
   \   00003A   7014         JNZ     ??zll_PerformNetworkDisc_0
   1465            {
   1466              // Register ZDO callback to handle the network discovery confirm and
   1467              // beacon notification confirm
   1468              ZDO_RegisterForZdoCB( ZDO_NWK_DISCOVERY_CNF_CBID, zll_NwkDiscoveryCnfCB );
   \   00003C                ; Setup parameters for call to function ZDO_RegisterForZdoCB
   \   00003C   7A..         MOV     R2,#??zll_NwkDiscoveryCnfCB?relay & 0xff
   \   00003E   7B..         MOV     R3,#(??zll_NwkDiscoveryCnfCB?relay >> 8) & 0xff
   \   000040   7902         MOV     R1,#0x2
   \   000042   12....       LCALL   ??ZDO_RegisterForZdoCB?relay
   1469              ZDO_RegisterForZdoCB( ZDO_BEACON_NOTIFY_IND_CBID, zll_BeaconIndCB );
   \   000045                ; Setup parameters for call to function ZDO_RegisterForZdoCB
   \   000045   7A..         MOV     R2,#??zll_BeaconIndCB?relay & 0xff
   \   000047   7B..         MOV     R3,#(??zll_BeaconIndCB?relay >> 8) & 0xff
   \   000049   7903         MOV     R1,#0x3
   \   00004B   12....       LCALL   ??ZDO_RegisterForZdoCB?relay
   \   00004E   8003         SJMP    ??zll_PerformNetworkDisc_1
   1470            }
   1471            else
   1472            {
   1473              NLME_NwkDiscTerm();
   \                     ??zll_PerformNetworkDisc_0:
   \   000050                ; Setup parameters for call to function NLME_NwkDiscTerm
   \   000050   12....       LCALL   ??NLME_NwkDiscTerm?relay
   1474            }
   1475          }
   \                     ??zll_PerformNetworkDisc_1:
   \   000053   7407         MOV     A,#0x7
   \   000055   12....       LCALL   ?DEALLOC_XSTACK8
   \   000058   02....       LJMP    ?Subroutine3 & 0xFFFF
   1476          
   1477          
   1478          /*********************************************************************
   1479           * @fn      zll_BeaconIndCB
   1480           *
   1481           * @brief   Process the incoming beacon indication.
   1482           *
   1483           * @param   param -  pointer to a parameter and a structure of parameters
   1484           *
   1485           * @return  void
   1486           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1487          static void *zll_BeaconIndCB ( void *param )
   \                     zll_BeaconIndCB:
   1488          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   1489            NLME_beaconInd_t *pBeacon = param;
   1490            zllDiscoveredNwkParam_t *pParam = pDiscoveredNwkParamList;
   \   000009   90....       MOV     DPTR,#pDiscoveredNwkParamList
   \   00000C   12....       LCALL   ?Subroutine14 & 0xFFFF
   1491            zllDiscoveredNwkParam_t *pLastParam;
   1492            uint8 found = FALSE;
   1493          
   1494            if ( pBeacon->permitJoining == TRUE )
   \                     ??CrossCallReturnLabel_8:
   \   00000F   EA           MOV     A,R2
   \   000010   2405         ADD     A,#0x5
   \   000012   F5..         MOV     ?V0 + 6,A
   \   000014   EB           MOV     A,R3
   \   000015   3400         ADDC    A,#0x0
   \   000017   F5..         MOV     ?V0 + 7,A
   \   000019   85..82       MOV     DPL,?V0 + 6
   \   00001C   F583         MOV     DPH,A
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   6401         XRL     A,#0x1
   \   000021   6003         JZ      $+5
   \   000023   02....       LJMP    ??zll_BeaconIndCB_0 & 0xFFFF
   \   000026   8037         SJMP    ??CrossCallReturnLabel_9
   1495            {
   1496              // Add the network parameter to the Network Parameter List
   1497              while ( pParam != NULL )
   1498              {
   1499                if ( ( pParam->PANID == pBeacon->panID ) &&
   1500                    ( pParam->logicalChannel == pBeacon->logicalChannel ) )
   \                     ??zll_BeaconIndCB_1:
   \   000028   8E82         MOV     DPL,R6
   \   00002A   8F83         MOV     DPH,R7
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   12....       LCALL   ??Subroutine43_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   000031   85..82       MOV     DPL,?V0 + 4
   \   000034   85..83       MOV     DPH,?V0 + 5
   \   000037   E0           MOVX    A,@DPTR
   \   000038   68           XRL     A,R0
   \   000039   7003         JNZ     ??zll_BeaconIndCB_2
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   69           XRL     A,R1
   \                     ??zll_BeaconIndCB_2:
   \   00003E   7014         JNZ     ??zll_BeaconIndCB_3
   \   000040   8E82         MOV     DPL,R6
   \   000042   8F83         MOV     DPH,R7
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   E0           MOVX    A,@DPTR
   \   000049   F8           MOV     R0,A
   \   00004A   85..82       MOV     DPL,?V0 + 2
   \   00004D   85..83       MOV     DPH,?V0 + 3
   \   000050   E0           MOVX    A,@DPTR
   \   000051   68           XRL     A,R0
   \   000052   6068         JZ      ??zll_BeaconIndCB_4
   1501                {
   1502                  found = TRUE;
   1503                  break;
   1504                }
   1505          
   1506                pLastParam = pParam;
   \                     ??zll_BeaconIndCB_3:
   \   000054   8E..         MOV     ?V0 + 8,R6
   \   000056   8F..         MOV     ?V0 + 9,R7
   1507                pParam = pParam->nextParam;
   \   000058   8E82         MOV     DPL,R6
   \   00005A   8F83         MOV     DPH,R7
   \   00005C   12....       LCALL   ?Subroutine14 & 0xFFFF
   1508              }
   \                     ??CrossCallReturnLabel_9:
   \   00005F   EA           MOV     A,R2
   \   000060   2404         ADD     A,#0x4
   \   000062   F5..         MOV     ?V0 + 2,A
   \   000064   EB           MOV     A,R3
   \   000065   3400         ADDC    A,#0x0
   \   000067   F5..         MOV     ?V0 + 3,A
   \   000069   EA           MOV     A,R2
   \   00006A   2402         ADD     A,#0x2
   \   00006C   F5..         MOV     ?V0 + 4,A
   \   00006E   EB           MOV     A,R3
   \   00006F   3400         ADDC    A,#0x0
   \   000071   F5..         MOV     ?V0 + 5,A
   \   000073   EE           MOV     A,R6
   \   000074   4F           ORL     A,R7
   \   000075   70B1         JNZ     ??zll_BeaconIndCB_1
   1509          
   1510              // If no existing parameter found, make a new one and add to the list
   1511              if ( found == FALSE )
   1512              {
   1513                pParam = osal_mem_alloc( sizeof( zllDiscoveredNwkParam_t ) );
   \   000077                ; Setup parameters for call to function osal_mem_alloc
   \   000077   7A13         MOV     R2,#0x13
   \   000079   7B00         MOV     R3,#0x0
   \   00007B   12....       LCALL   ??osal_mem_alloc?relay
   \   00007E   8A..         MOV     ?V0 + 10,R2
   \   000080   8B..         MOV     ?V0 + 11,R3
   \   000082   AE..         MOV     R6,?V0 + 10
   \   000084   AF..         MOV     R7,?V0 + 11
   1514                if ( pParam == NULL )
   \   000086   EE           MOV     A,R6
   \   000087   4F           ORL     A,R7
   \   000088   7003         JNZ     $+5
   \   00008A   02....       LJMP    ??zll_BeaconIndCB_0 & 0xFFFF
   1515                {
   1516                  // Memory alloc failed, discard this beacon
   1517                  return ( NULL );
   1518                }
   1519          
   1520                // Clear the network descriptor
   1521                osal_memset( pParam, 0, sizeof( zllDiscoveredNwkParam_t )  );
   \   00008D                ; Setup parameters for call to function osal_memset
   \   00008D   7C13         MOV     R4,#0x13
   \   00008F   7D00         MOV     R5,#0x0
   \   000091   7900         MOV     R1,#0x0
   \   000093   12....       LCALL   ??osal_memset?relay
   1522          
   1523                // Initialize the descriptor
   1524                pParam->chosenRouter = INVALID_NODE_ADDR;
   \   000096   EE           MOV     A,R6
   \   000097   240D         ADD     A,#0xd
   \   000099   12....       LCALL   ??Subroutine40_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   00009C   12....       LCALL   ?Subroutine26 & 0xFFFF
   1525                pParam->chosenRouterDepth = 0xFF;
   \                     ??CrossCallReturnLabel_52:
   \   00009F   EE           MOV     A,R6
   \   0000A0   2410         ADD     A,#0x10
   \   0000A2   12....       LCALL   ??Subroutine40_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   0000A5   74FF         MOV     A,#-0x1
   \   0000A7   12....       LCALL   ?Subroutine7 & 0xFFFF
   1526          
   1527                // Save new entry into the descriptor list
   1528                if ( pDiscoveredNwkParamList == NULL )
   \                     ??CrossCallReturnLabel_114:
   \   0000AA   7005         JNZ     ??zll_BeaconIndCB_5
   1529                {
   1530                  // First element in the list
   1531                  pDiscoveredNwkParamList = pParam;
   \   0000AC   90....       MOV     DPTR,#pDiscoveredNwkParamList
   \   0000AF   8006         SJMP    ??zll_BeaconIndCB_6
   1532                }
   1533                else
   1534                {
   1535                  // Last element in the list
   1536                  pLastParam->nextParam = pParam;
   \                     ??zll_BeaconIndCB_5:
   \   0000B1   85..82       MOV     DPL,?V0 + 8
   \   0000B4   85..83       MOV     DPH,?V0 + 9
   \                     ??zll_BeaconIndCB_6:
   \   0000B7   EE           MOV     A,R6
   \   0000B8   F0           MOVX    @DPTR,A
   \   0000B9   A3           INC     DPTR
   \   0000BA   EF           MOV     A,R7
   \   0000BB   F0           MOVX    @DPTR,A
   1537                }
   1538              }
   1539          
   1540              // Update the descriptor with the incoming beacon
   1541              pParam->logicalChannel = pBeacon->logicalChannel;
   \                     ??zll_BeaconIndCB_4:
   \   0000BC   85..82       MOV     DPL,?V0 + 2
   \   0000BF   85..83       MOV     DPH,?V0 + 3
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   8E82         MOV     DPL,R6
   \   0000C5   8F83         MOV     DPH,R7
   \   0000C7   A3           INC     DPTR
   \   0000C8   A3           INC     DPTR
   \   0000C9   A3           INC     DPTR
   \   0000CA   A3           INC     DPTR
   \   0000CB   F0           MOVX    @DPTR,A
   1542              pParam->PANID          = pBeacon->panID;
   \   0000CC   85..82       MOV     DPL,?V0 + 4
   \   0000CF   85..83       MOV     DPH,?V0 + 5
   \   0000D2   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   0000D5   A3           INC     DPTR
   \   0000D6   A3           INC     DPTR
   \   0000D7   12....       LCALL   ?Subroutine19 & 0xFFFF
   1543          
   1544              // Save the extended PAN ID from the beacon payload only if 1.1 version network
   1545              if ( pBeacon->protocolVersion != ZB_PROT_V1_0 )
   \                     ??CrossCallReturnLabel_64:
   \   0000DA   EE           MOV     A,R6
   \   0000DB   2405         ADD     A,#0x5
   \   0000DD   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   0000E0   A3           INC     DPTR
   \   0000E1   A3           INC     DPTR
   \   0000E2   A3           INC     DPTR
   \   0000E3   A3           INC     DPTR
   \   0000E4   A3           INC     DPTR
   \   0000E5   A3           INC     DPTR
   \   0000E6   A3           INC     DPTR
   \   0000E7   A3           INC     DPTR
   \   0000E8   E0           MOVX    A,@DPTR
   \   0000E9   6401         XRL     A,#0x1
   \   0000EB   600F         JZ      ??zll_BeaconIndCB_7
   1546              {
   1547                osal_cpyExtAddr( pParam->extendedPANID, pBeacon->extendedPanID );
   \   0000ED                ; Setup parameters for call to function sAddrExtCpy
   \   0000ED   E5..         MOV     A,?V0 + 0
   \   0000EF   240D         ADD     A,#0xd
   \   0000F1   FC           MOV     R4,A
   \   0000F2   E5..         MOV     A,?V0 + 1
   \   0000F4   3400         ADDC    A,#0x0
   \   0000F6   FD           MOV     R5,A
   \   0000F7   12....       LCALL   ??sAddrExtCpy?relay
   \   0000FA   8009         SJMP    ??zll_BeaconIndCB_8
   1548              }
   1549              else
   1550              {
   1551                osal_memset( pParam->extendedPANID, 0xFF, Z_EXTADDR_LEN );
   \                     ??zll_BeaconIndCB_7:
   \   0000FC                ; Setup parameters for call to function osal_memset
   \   0000FC   7C08         MOV     R4,#0x8
   \   0000FE   7D00         MOV     R5,#0x0
   \   000100   79FF         MOV     R1,#-0x1
   \   000102   12....       LCALL   ??osal_memset?relay
   1552              }
   1553          
   1554              // check if this device is a better choice to join...
   1555              // ...dont bother checking assocPermit flag is doing a rejoin
   1556              if ( ( pBeacon->LQI > gMIN_TREE_LINK_COST ) &&
   1557                  (  pBeacon->permitJoining == TRUE   ) )
   \                     ??zll_BeaconIndCB_8:
   \   000105   E5..         MOV     A,?V0 + 0
   \   000107   240A         ADD     A,#0xa
   \   000109   F8           MOV     R0,A
   \   00010A   E5..         MOV     A,?V0 + 1
   \   00010C   3400         ADDC    A,#0x0
   \   00010E   F9           MOV     R1,A
   \   00010F   8882         MOV     DPL,R0
   \   000111   8983         MOV     DPH,R1
   \   000113   E0           MOVX    A,@DPTR
   \   000114   FA           MOV     R2,A
   \   000115   90....       MOV     DPTR,#gMIN_TREE_LINK_COST
   \   000118   E0           MOVX    A,@DPTR
   \   000119   C3           CLR     C
   \   00011A   9A           SUBB    A,R2
   \   00011B   4003         JC      $+5
   \   00011D   02....       LJMP    ??zll_BeaconIndCB_0 & 0xFFFF
   \   000120   85..82       MOV     DPL,?V0 + 6
   \   000123   85..83       MOV     DPH,?V0 + 7
   \   000126   E0           MOVX    A,@DPTR
   \   000127   6401         XRL     A,#0x1
   \   000129   6003         JZ      $+5
   \   00012B   02....       LJMP    ??zll_BeaconIndCB_0 & 0xFFFF
   1558              {
   1559                uint8 selected = FALSE;
   1560                uint8 capacity = FALSE;
   1561          
   1562                if ( _NIB.nwkAddrAlloc == NWK_ADDRESSING_STOCHASTIC )
   \   00012E   E5..         MOV     A,?V0 + 0
   \   000130   2406         ADD     A,#0x6
   \   000132   FA           MOV     R2,A
   \   000133   E5..         MOV     A,?V0 + 1
   \   000135   3400         ADDC    A,#0x0
   \   000137   FB           MOV     R3,A
   \   000138   EE           MOV     A,R6
   \   000139   2410         ADD     A,#0x10
   \   00013B   FC           MOV     R4,A
   \   00013C   EF           MOV     A,R7
   \   00013D   3400         ADDC    A,#0x0
   \   00013F   FD           MOV     R5,A
   \   000140   E5..         MOV     A,?V0 + 0
   \   000142   240B         ADD     A,#0xb
   \   000144   F5..         MOV     ?V0 + 2,A
   \   000146   E5..         MOV     A,?V0 + 1
   \   000148   3400         ADDC    A,#0x0
   \   00014A   F5..         MOV     ?V0 + 3,A
   \   00014C   EE           MOV     A,R6
   \   00014D   240F         ADD     A,#0xf
   \   00014F   F5..         MOV     ?V0 + 4,A
   \   000151   EF           MOV     A,R7
   \   000152   3400         ADDC    A,#0x0
   \   000154   F5..         MOV     ?V0 + 5,A
   \   000156   90....       MOV     DPTR,#_NIB + 96
   \   000159   E0           MOVX    A,@DPTR
   \   00015A   6402         XRL     A,#0x2
   \   00015C   7027         JNZ     ??zll_BeaconIndCB_9
   1563                {
   1564                  if ( ((pBeacon->LQI   > pParam->chosenRouterLinkQuality) &&
   1565                        (pBeacon->depth < MAX_NODE_DEPTH)) ||
   1566                      ((pBeacon->LQI   == pParam->chosenRouterLinkQuality) &&
   1567                       (pBeacon->depth < pParam->chosenRouterDepth)) )
   \   00015E   8882         MOV     DPL,R0
   \   000160   8983         MOV     DPH,R1
   \   000162   E0           MOVX    A,@DPTR
   \   000163   F5..         MOV     ?V0 + 6,A
   \   000165   85..82       MOV     DPL,?V0 + 4
   \   000168   85..83       MOV     DPH,?V0 + 5
   \   00016B   E0           MOVX    A,@DPTR
   \   00016C   F5..         MOV     ?V0 + 7,A
   \   00016E   C3           CLR     C
   \   00016F   95..         SUBB    A,?V0 + 6
   \   000171   500C         JNC     ??zll_BeaconIndCB_10
   \   000173   85..82       MOV     DPL,?V0 + 2
   \   000176   85..83       MOV     DPH,?V0 + 3
   \   000179   E0           MOVX    A,@DPTR
   \   00017A   C3           CLR     C
   \   00017B   9414         SUBB    A,#0x14
   \   00017D   4019         JC      ??zll_BeaconIndCB_11
   \                     ??zll_BeaconIndCB_10:
   \   00017F   E5..         MOV     A,?V0 + 7
   \   000181   65..         XRL     A,?V0 + 6
   \   000183   704C         JNZ     ??zll_BeaconIndCB_12
   1568                  {
   1569                    selected = TRUE;
   1570                  }
   1571                }
   1572                else
   1573                {
   1574                  if ( pBeacon->depth < pParam->chosenRouterDepth )
   \                     ??zll_BeaconIndCB_9:
   \   000185   8C82         MOV     DPL,R4
   \   000187   8D83         MOV     DPH,R5
   \   000189   E0           MOVX    A,@DPTR
   \   00018A   F5..         MOV     ?V0 + 6,A
   \   00018C   85..82       MOV     DPL,?V0 + 2
   \   00018F   85..83       MOV     DPH,?V0 + 3
   \   000192   E0           MOVX    A,@DPTR
   \   000193   C3           CLR     C
   \   000194   95..         SUBB    A,?V0 + 6
   \   000196   5039         JNC     ??zll_BeaconIndCB_12
   1575                  {
   1576                    selected = TRUE;
   1577                  }
   1578                }
   1579          
   1580                capacity = pBeacon->routerCapacity;
   1581          
   1582                if ( (capacity) && (selected) )
   \                     ??zll_BeaconIndCB_11:
   \   000198   8A82         MOV     DPL,R2
   \   00019A   8B83         MOV     DPH,R3
   \   00019C   E0           MOVX    A,@DPTR
   \   00019D   6032         JZ      ??zll_BeaconIndCB_12
   1583                {
   1584                  // this is the new chosen router for joining...
   1585                  pParam->chosenRouter            = pBeacon->sourceAddr;
   \   00019F   85..82       MOV     DPL,?V0 + 0
   \   0001A2   85..83       MOV     DPH,?V0 + 1
   \   0001A5   E0           MOVX    A,@DPTR
   \   0001A6   F5..         MOV     ?V0 + 6,A
   \   0001A8   A3           INC     DPTR
   \   0001A9   E0           MOVX    A,@DPTR
   \   0001AA   F5..         MOV     ?V0 + 7,A
   \   0001AC   EE           MOV     A,R6
   \   0001AD   240D         ADD     A,#0xd
   \   0001AF   12....       LCALL   ??Subroutine40_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   0001B2   E5..         MOV     A,?V0 + 6
   \   0001B4   F0           MOVX    @DPTR,A
   \   0001B5   A3           INC     DPTR
   \   0001B6   E5..         MOV     A,?V0 + 7
   \   0001B8   F0           MOVX    @DPTR,A
   1586                  pParam->chosenRouterLinkQuality = pBeacon->LQI;
   \   0001B9   8882         MOV     DPL,R0
   \   0001BB   8983         MOV     DPH,R1
   \   0001BD   E0           MOVX    A,@DPTR
   \   0001BE   85..82       MOV     DPL,?V0 + 4
   \   0001C1   85..83       MOV     DPH,?V0 + 5
   \   0001C4   F0           MOVX    @DPTR,A
   1587                  pParam->chosenRouterDepth       = pBeacon->depth;
   \   0001C5   85..82       MOV     DPL,?V0 + 2
   \   0001C8   85..83       MOV     DPH,?V0 + 3
   \   0001CB   E0           MOVX    A,@DPTR
   \   0001CC   8C82         MOV     DPL,R4
   \   0001CE   8D83         MOV     DPH,R5
   \   0001D0   F0           MOVX    @DPTR,A
   1588                }
   1589          
   1590                if ( pBeacon->deviceCapacity )
   \                     ??zll_BeaconIndCB_12:
   \   0001D1   85..82       MOV     DPL,?V0 + 0
   \   0001D4   85..83       MOV     DPH,?V0 + 1
   \   0001D7   A3           INC     DPTR
   \   0001D8   A3           INC     DPTR
   \   0001D9   A3           INC     DPTR
   \   0001DA   A3           INC     DPTR
   \   0001DB   A3           INC     DPTR
   \   0001DC   A3           INC     DPTR
   \   0001DD   A3           INC     DPTR
   \   0001DE   E0           MOVX    A,@DPTR
   \   0001DF   6009         JZ      ??zll_BeaconIndCB_13
   1591                  pParam->deviceCapacity = 1;
   \   0001E1   EE           MOV     A,R6
   \   0001E2   2412         ADD     A,#0x12
   \   0001E4   12....       LCALL   ??Subroutine40_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   0001E7   7401         MOV     A,#0x1
   \   0001E9   F0           MOVX    @DPTR,A
   1592          
   1593                if ( pBeacon->routerCapacity )
   \                     ??zll_BeaconIndCB_13:
   \   0001EA   8A82         MOV     DPL,R2
   \   0001EC   8B83         MOV     DPH,R3
   \   0001EE   E0           MOVX    A,@DPTR
   \   0001EF   6009         JZ      ??zll_BeaconIndCB_0
   1594                  pParam->routerCapacity = 1;
   \   0001F1   EE           MOV     A,R6
   \   0001F2   2411         ADD     A,#0x11
   \   0001F4   12....       LCALL   ??Subroutine40_0 & 0xFFFF
   1595              }
   1596            }
   \                     ??CrossCallReturnLabel_87:
   \   0001F7   7401         MOV     A,#0x1
   \   0001F9   F0           MOVX    @DPTR,A
   1597            return ( NULL );
   \                     ??zll_BeaconIndCB_0:
   \   0001FA   7A00         MOV     R2,#0x0
   \   0001FC   7B00         MOV     R3,#0x0
   \   0001FE   02....       LJMP    ?Subroutine6 & 0xFFFF
   1598          }
   1599          
   1600          /*********************************************************************
   1601           * @fn      zll_NwkDiscoveryCnfCB
   1602           *
   1603           * @brief   Send an event to inform the target the completion of
   1604           *          network discovery scan
   1605           *
   1606           * @param   param - pointer to a parameter and a structure of parameters
   1607           *
   1608           * @return  void
   1609           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1610          static void *zll_NwkDiscoveryCnfCB ( void *param )
   \                     zll_NwkDiscoveryCnfCB:
   1611          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1612            // Scan completed. De-register the callbacks with ZDO
   1613            ZDO_DeregisterForZdoCB( ZDO_NWK_DISCOVERY_CNF_CBID );
   \   000004                ; Setup parameters for call to function ZDO_DeregisterForZdoCB
   \   000004   7902         MOV     R1,#0x2
   \   000006   12....       LCALL   ??ZDO_DeregisterForZdoCB?relay
   1614            ZDO_DeregisterForZdoCB( ZDO_BEACON_NOTIFY_IND_CBID );
   \   000009                ; Setup parameters for call to function ZDO_DeregisterForZdoCB
   \   000009   7903         MOV     R1,#0x3
   \   00000B   12....       LCALL   ??ZDO_DeregisterForZdoCB?relay
   1615          
   1616            NLME_NwkDiscTerm();
   \   00000E                ; Setup parameters for call to function NLME_NwkDiscTerm
   \   00000E   12....       LCALL   ??NLME_NwkDiscTerm?relay
   1617          
   1618            if ( pDiscoveredNwkParamList != NULL )
   \   000011   12....       LCALL   ??Subroutine45_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_123:
   \   000014   6006         JZ      ??zll_NwkDiscoveryCnfCB_0
   1619            {
   1620              // proceed to join the network, otherwise
   1621              // Notify our task
   1622              osal_set_event( zllTaskId, ZLL_NWK_DISC_CNF_EVT );
   \   000016                ; Setup parameters for call to function osal_set_event
   \   000016   7A01         MOV     R2,#0x1
   \   000018   7B00         MOV     R3,#0x0
   \   00001A   801E         SJMP    ??zll_NwkDiscoveryCnfCB_1
   1623            }
   1624            else
   1625            {
   1626              if ( zllHAScanInitiated == ZLL_SCAN_PRIMARY_CHANNELS )
   \                     ??zll_NwkDiscoveryCnfCB_0:
   \   00001C   90....       MOV     DPTR,#zllHAScanInitiated
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6401         XRL     A,#0x1
   \   000022   7008         JNZ     ??zll_NwkDiscoveryCnfCB_2
   1627              {
   1628                // try discovery in secondary ZLL channel list
   1629                zllHAScanInitiated = ZLL_SCAN_SECONDARY_CHANNELS;
   \   000024   7402         MOV     A,#0x2
   \   000026   F0           MOVX    @DPTR,A
   1630          
   1631                zll_ClassicalCommissioningNetworkDisc();
   \   000027                ; Setup parameters for call to function zll_ClassicalCommissioningNetworkDisc
   \   000027   12....       LCALL   ??zll_ClassicalCommissioningNetworkDisc?relay
   \   00002A   8016         SJMP    ??zll_NwkDiscoveryCnfCB_3
   1632              }
   1633              else
   1634              {
   1635                if ( zllHAScanInitiated != FALSE )
   \                     ??zll_NwkDiscoveryCnfCB_2:
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   6003         JZ      ??zll_NwkDiscoveryCnfCB_4
   1636                {
   1637                  zllHAScanInitiated = ZLL_SCAN_FOUND_NOTHING;
   \   00002F   7403         MOV     A,#0x3
   \   000031   F0           MOVX    @DPTR,A
   1638                }
   1639                zllJoinedHANetwork = FALSE;
   \                     ??zll_NwkDiscoveryCnfCB_4:
   \   000032   90....       MOV     DPTR,#zllJoinedHANetwork
   \   000035   E4           CLR     A
   \   000036   F0           MOVX    @DPTR,A
   1640          
   1641                // no suitable network in secondary channel list, then just wait for touchlink
   1642                // Notify our task
   1643                osal_set_event( zllTaskId, ZLL_NWK_DISC_CNF_EVT );
   \   000037                ; Setup parameters for call to function osal_set_event
   \   000037   7A01         MOV     R2,#0x1
   \   000039   FB           MOV     R3,A
   \                     ??zll_NwkDiscoveryCnfCB_1:
   \   00003A   90....       MOV     DPTR,#zllTaskId
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   F9           MOV     R1,A
   \   00003F   12....       LCALL   ??osal_set_event?relay
   1644              }
   1645            }
   1646          
   1647            return ( NULL );
   \                     ??zll_NwkDiscoveryCnfCB_3:
   \   000042   7A00         MOV     R2,#0x0
   \   000044   7B00         MOV     R3,#0x0
   \   000046   02....       LJMP    ??Subroutine39_0 & 0xFFFF
   1648          }
   1649          
   1650          /****************************************************************************
   1651           * @fn      zll_FreeNwkParamList
   1652           *
   1653           * @brief   This function frees any network discovery data.
   1654           *
   1655           * @param   none
   1656           *
   1657           * @return  none
   1658           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1659          void zll_FreeNwkParamList( void )
   \                     zll_FreeNwkParamList:
   1660          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1661            zllDiscoveredNwkParam_t *pParam = pDiscoveredNwkParamList;
   \   000005   90....       MOV     DPTR,#pDiscoveredNwkParamList
   \   000008   E0           MOVX    A,@DPTR
   \   000009   FA           MOV     R2,A
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   800D         SJMP    ??zll_FreeNwkParamList_0
   1662            zllDiscoveredNwkParam_t *pNextParam;
   1663          
   1664            // deallocate the pDiscoveredNwkParamList memory
   1665            while ( pParam != NULL )
   1666            {
   1667              pNextParam = pParam->nextParam;
   \                     ??zll_FreeNwkParamList_1:
   \   00000E   8A82         MOV     DPL,R2
   \   000010   8B83         MOV     DPH,R3
   \   000012   12....       LCALL   ?Subroutine14 & 0xFFFF
   1668          
   1669              osal_mem_free( pParam );
   \                     ??CrossCallReturnLabel_10:
   \   000015                ; Setup parameters for call to function osal_mem_free
   \   000015   12....       LCALL   ??osal_mem_free?relay
   1670          
   1671              pParam = pNextParam;
   \   000018   EE           MOV     A,R6
   \   000019   FA           MOV     R2,A
   \   00001A   EF           MOV     A,R7
   \                     ??zll_FreeNwkParamList_0:
   \   00001B   FB           MOV     R3,A
   1672            }
   \   00001C   EA           MOV     A,R2
   \   00001D   4B           ORL     A,R3
   \   00001E   70EE         JNZ     ??zll_FreeNwkParamList_1
   1673          
   1674            pDiscoveredNwkParamList = NULL;
   \   000020   90....       MOV     DPTR,#pDiscoveredNwkParamList
   \   000023   E4           CLR     A
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   F0           MOVX    @DPTR,A
   1675          }
   \   000027   02....       LJMP    ?Subroutine5 & 0xFFFF
   1676          
   1677          /****************************************************************************
   1678           * @fn      zll_SetTCLK
   1679           *
   1680           * @brief   This function sets the default ZLL link key in the TC Link Key table,
   1681           *          in the last entry.
   1682           *
   1683           * @param   none
   1684           *
   1685           * @return  none
   1686           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1687          static void zll_SetTCLK()
   \                     zll_SetTCLK:
   1688          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 48
   \   000005   74D0         MOV     A,#-0x30
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1689            uint8 defaultZllTCLinkKey[SEC_KEY_LEN] = ZLL_LINK_KEY;
   \   00000A   7420         MOV     A,#0x20
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   AC82         MOV     R4,DPL
   \   000011   AD83         MOV     R5,DPH
   \   000013   7583..       MOV     DPH,#(`?<Constant {208, 209, 210, 211, 212, 213, 214,` >> 8) & 0xff
   \   000016   7582..       MOV     DPL,#`?<Constant {208, 209, 210, 211, 212, 213, 214,` & 0xff
   \   000019   7410         MOV     A,#0x10
   \   00001B   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   1690            APSME_TCLinkKey_t zllTCLKentry = {0};
   \   00001E   85..82       MOV     DPL,?XSP + 0
   \   000021   85..83       MOV     DPH,?XSP + 1
   \   000024   AC82         MOV     R4,DPL
   \   000026   AD83         MOV     R5,DPH
   \   000028   7583..       MOV     DPH,#(`?<Constant {{0}}>` >> 8) & 0xff
   \   00002B   7582..       MOV     DPL,#`?<Constant {{0}}>` & 0xff
   \   00002E   7420         MOV     A,#0x20
   \   000030   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   1691            osal_memset( zllTCLKentry.extAddr, 0xFF, Z_EXTADDR_LEN );
   \   000033                ; Setup parameters for call to function osal_memset
   \   000033   7C08         MOV     R4,#0x8
   \   000035   FD           MOV     R5,A
   \   000036   79FF         MOV     R1,#-0x1
   \   000038   85..82       MOV     DPL,?XSP + 0
   \   00003B   85..83       MOV     DPH,?XSP + 1
   \   00003E   AA82         MOV     R2,DPL
   \   000040   AB83         MOV     R3,DPH
   \   000042   12....       LCALL   ??osal_memset?relay
   1692            osal_memcpy( zllTCLKentry.key, defaultZllTCLinkKey, SEC_KEY_LEN);
   \   000045                ; Setup parameters for call to function osal_memcpy
   \   000045   7420         MOV     A,#0x20
   \   000047   12....       LCALL   ?XSTACK_DISP0_8
   \   00004A   A982         MOV     R1,DPL
   \   00004C   AA83         MOV     R2,DPH
   \   00004E   89..         MOV     ?V0 + 0,R1
   \   000050   8A..         MOV     ?V0 + 1,R2
   \   000052   75..00       MOV     ?V0 + 2,#0x0
   \   000055   78..         MOV     R0,#?V0 + 0
   \   000057   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00005A   7C10         MOV     R4,#0x10
   \   00005C   7D00         MOV     R5,#0x0
   \   00005E   740B         MOV     A,#0xb
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   AA82         MOV     R2,DPL
   \   000065   AB83         MOV     R3,DPH
   \   000067   12....       LCALL   ??osal_memcpy?relay
   \   00006A   7403         MOV     A,#0x3
   \   00006C   12....       LCALL   ?DEALLOC_XSTACK8
   1693          #if ( ZDSECMGR_TC_DEVICE_MAX > 1 )
   1694            osal_nv_write( ZCD_NV_TCLK_TABLE_START + (ZDSECMGR_TC_DEVICE_MAX-1), 0,
   1695                           sizeof(zllTCLKentry), &zllTCLKentry);
   \   00006F                ; Setup parameters for call to function osal_nv_write
   \   00006F   85..82       MOV     DPL,?XSP + 0
   \   000072   85..83       MOV     DPH,?XSP + 1
   \   000075   8582..       MOV     ?V0 + 0,DPL
   \   000078   8583..       MOV     ?V0 + 1,DPH
   \   00007B   78..         MOV     R0,#?V0 + 0
   \   00007D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000080   75..20       MOV     ?V0 + 0,#0x20
   \   000083   75..00       MOV     ?V0 + 1,#0x0
   \   000086   78..         MOV     R0,#?V0 + 0
   \   000088   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008B   7C00         MOV     R4,#0x0
   \   00008D   7D00         MOV     R5,#0x0
   \   00008F   7A02         MOV     R2,#0x2
   \   000091   7B01         MOV     R3,#0x1
   \   000093   12....       LCALL   ??osal_nv_write?relay
   \   000096   7404         MOV     A,#0x4
   \   000098   12....       LCALL   ?DEALLOC_XSTACK8
   1696          #else
   1697          #error ZDSECMGR_TC_DEVICE_MAX should be defined to be 2 or more
   1698          #endif
   1699          }
   \   00009B   7430         MOV     A,#0x30
   \   00009D   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A0   7F03         MOV     R7,#0x3
   \   0000A2   02....       LJMP    ?BANKED_LEAVE_XDATA
   1700          
   1701          /****************************************************************************
   1702           * @fn      zll_IsValidTransID
   1703           *
   1704           * @brief   Transaction ID Filter for Touch-Link received commands.
   1705           *
   1706           * @param   transID - received transaction ID
   1707           *
   1708           * @return  FALSE if not matching current or transaction expired
   1709           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1710          bool zll_IsValidTransID( uint32 transID )
   \                     zll_IsValidTransID:
   1711          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   8C..         MOV     ?V0 + 2,R4
   \   00000B   8D..         MOV     ?V0 + 3,R5
   1712            if ( ( zllTransID == 0 ) || ( ( zllTransID != transID ) && ( zllLastAcceptedTransID != transID ) ) )
   \   00000D   90....       MOV     DPTR,#zllTransID
   \   000010   78..         MOV     R0,#?V0 + 4
   \   000012   12....       LCALL   ?L_MOV_X
   \   000015   E5..         MOV     A,?V0 + 4
   \   000017   45..         ORL     A,?V0 + 5
   \   000019   45..         ORL     A,?V0 + 6
   \   00001B   45..         ORL     A,?V0 + 7
   \   00001D   6014         JZ      ??zll_IsValidTransID_0
   \   00001F   90....       MOV     DPTR,#zllTransID
   \   000022   78..         MOV     R0,#?V0 + 0
   \   000024   12....       LCALL   ?L_EQ_X
   \   000027   600E         JZ      ??zll_IsValidTransID_1
   \   000029   90....       MOV     DPTR,#zllLastAcceptedTransID
   \   00002C   78..         MOV     R0,#?V0 + 0
   \   00002E   12....       LCALL   ?L_EQ_X
   \   000031   6004         JZ      ??zll_IsValidTransID_1
   1713            {
   1714              return ( FALSE );
   \                     ??zll_IsValidTransID_0:
   \   000033   7900         MOV     R1,#0x0
   \   000035   8002         SJMP    ??zll_IsValidTransID_2
   1715            }
   1716            return ( TRUE );
   \                     ??zll_IsValidTransID_1:
   \   000037   7901         MOV     R1,#0x1
   \                     ??zll_IsValidTransID_2:
   \   000039   7F08         MOV     R7,#0x8
   \   00003B   02....       LJMP    ?BANKED_LEAVE_XDATA
   1717          }
   1718          
   1719          /*********************************************************************
   1720           * @fn      zll_RouterProcessZDOMsg
   1721           *
   1722           * @brief   Process incoming ZDO messages (for routers)
   1723           *
   1724           * @param   inMsg - message to process
   1725           *
   1726           * @return  none
   1727           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   90....       MOV     DPTR,#_NIB + 33
   \   000003                REQUIRE ??Subroutine44_0
   \   000003                ; // Fall through to label ??Subroutine44_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1728          void zll_RouterProcessZDOMsg( zdoIncomingMsg_t *inMsg )
   \                     zll_RouterProcessZDOMsg:
   1729          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV     A,#-0xc
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1730            ZDO_DeviceAnnce_t devAnnce;
   1731          
   1732            switch ( inMsg->clusterID )
   \   00000E   EE           MOV     A,R6
   \   00000F   240C         ADD     A,#0xc
   \   000011   12....       LCALL   ??Subroutine40_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   000014   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   000017   12....       LCALL   ?US_SWITCH_SPARSE
   \                     `?<Jumptable for zll_RouterProcessZDOMsg>_0`:
   \   00001A   0000         DW        0
   \   00001C   0200         DW        2
   \   00001E   1300         DW        19
   \   000020   ....         DW        ??zll_RouterProcessZDOMsg_0
   \   000022   3600         DW        54
   \   000024   ....         DW        ??zll_RouterProcessZDOMsg_1
   \   000026   ....         DW        ??zll_RouterProcessZDOMsg_2
   1733            {
   1734              case Device_annce:
   1735                {
   1736                  // all devices should send link status, including the one sending it
   1737                  ZDO_ParseDeviceAnnce( inMsg, &devAnnce );
   \                     ??zll_RouterProcessZDOMsg_0:
   \   000028                ; Setup parameters for call to function ZDO_ParseDeviceAnnce
   \   000028   7401         MOV     A,#0x1
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   AC82         MOV     R4,DPL
   \   00002F   AD83         MOV     R5,DPH
   \   000031   12....       LCALL   ??ZDO_ParseDeviceAnnce?relay
   1738          
   1739                  linkInfo_t *linkInfo;
   1740          
   1741                  // check if entry exists
   1742                  linkInfo = nwkNeighborGetLinkInfo( devAnnce.nwkAddr, _NIB.nwkPanId );
   \   000034                ; Setup parameters for call to function nwkNeighborGetLinkInfo
   \   000034   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_110:
   \   000037   7401         MOV     A,#0x1
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   12....       LCALL   ??Subroutine38_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   00003F   12....       LCALL   ??nwkNeighborGetLinkInfo?relay
   \   000042   8A82         MOV     DPL,R2
   \   000044   8B83         MOV     DPH,R3
   1743          
   1744                  // if not, look for a vacant entry to add this node...
   1745                  if ( linkInfo == NULL )
   \   000046   E582         MOV     A,DPL
   \   000048   4583         ORL     A,DPH
   \   00004A   7044         JNZ     ??zll_RouterProcessZDOMsg_3
   1746                  {
   1747                    nwkNeighborAdd( devAnnce.nwkAddr, _NIB.nwkPanId, 1 );
   \   00004C                ; Setup parameters for call to function nwkNeighborAdd
   \   00004C   7901         MOV     R1,#0x1
   \   00004E   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_111:
   \   000051   E9           MOV     A,R1
   \   000052   12....       LCALL   ?XSTACK_DISP0_8
   \   000055   12....       LCALL   ??Subroutine38_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   000058   12....       LCALL   ??nwkNeighborAdd?relay
   1748                    // if we have end device childs, send link status
   1749                    if ( AssocCount(CHILD_RFD, CHILD_RFD_RX_IDLE) > 0 )
   \   00005B                ; Setup parameters for call to function AssocCount
   \   00005B   7A02         MOV     R2,#0x2
   \   00005D   7901         MOV     R1,#0x1
   \   00005F   12....       LCALL   ??AssocCount?relay
   \   000062   8B..         MOV     ?V0 + 1,R3
   \   000064   EA           MOV     A,R2
   \   000065   45..         ORL     A,?V0 + 1
   \   000067   7003         JNZ     $+5
   \   000069   02....       LJMP    ??zll_RouterProcessZDOMsg_2 & 0xFFFF
   1750                    {
   1751                      linkInfo = nwkNeighborGetLinkInfo( devAnnce.nwkAddr, _NIB.nwkPanId );
   \   00006C                ; Setup parameters for call to function nwkNeighborGetLinkInfo
   \   00006C   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   00006F   7401         MOV     A,#0x1
   \   000071   12....       LCALL   ?XSTACK_DISP0_8
   \   000074   12....       LCALL   ??Subroutine38_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   000077   12....       LCALL   ??nwkNeighborGetLinkInfo?relay
   \   00007A   8A82         MOV     DPL,R2
   \   00007C   8B83         MOV     DPH,R3
   1752                      if ( (linkInfo != NULL) && (linkInfo->txCost == 0) )
   \   00007E   E582         MOV     A,DPL
   \   000080   4583         ORL     A,DPH
   \   000082   6007         JZ      ??zll_RouterProcessZDOMsg_4
   \   000084   A3           INC     DPTR
   \   000085   E0           MOVX    A,@DPTR
   \   000086   7003         JNZ     ??zll_RouterProcessZDOMsg_4
   1753                      {
   1754                        linkInfo->txCost = MAX_LINK_COST;
   \   000088   7407         MOV     A,#0x7
   \   00008A   F0           MOVX    @DPTR,A
   1755                      }
   1756                      NLME_UpdateLinkStatus();
   \                     ??zll_RouterProcessZDOMsg_4:
   \   00008B                ; Setup parameters for call to function NLME_UpdateLinkStatus
   \   00008B   12....       LCALL   ??NLME_UpdateLinkStatus?relay
   \   00008E   8067         SJMP    ??zll_RouterProcessZDOMsg_2
   1757                    }
   1758                  }
   1759                  else
   1760                  {
   1761                    // only update the TxCost, so the Link Status can be sent properly
   1762                    if (linkInfo->txCost == 0)
   \                     ??zll_RouterProcessZDOMsg_3:
   \   000090   A3           INC     DPTR
   \   000091   E0           MOVX    A,@DPTR
   \   000092   7063         JNZ     ??zll_RouterProcessZDOMsg_2
   1763                    {
   1764                      linkInfo->txCost = MAX_LINK_COST;
   \   000094   7407         MOV     A,#0x7
   \   000096   F0           MOVX    @DPTR,A
   \   000097   805E         SJMP    ??zll_RouterProcessZDOMsg_2
   1765                    }
   1766                  }
   1767                }
   1768                break;
   1769          
   1770              case Mgmt_Permit_Join_req:
   1771                {
   1772                  uint8 duration = inMsg->asdu[ZDP_MGMT_PERMIT_JOIN_REQ_DURATION];
   1773                  ZStatus_t stat = NLME_PermitJoiningRequest( duration );
   \                     ??zll_RouterProcessZDOMsg_1:
   \   000099                ; Setup parameters for call to function NLME_PermitJoiningRequest
   \   000099   EE           MOV     A,R6
   \   00009A   2413         ADD     A,#0x13
   \   00009C   12....       LCALL   ??Subroutine40_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   00009F   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   0000A2   E0           MOVX    A,@DPTR
   \   0000A3   F9           MOV     R1,A
   \   0000A4   12....       LCALL   ??NLME_PermitJoiningRequest?relay
   \   0000A7   E9           MOV     A,R1
   \   0000A8   85..82       MOV     DPL,?XSP + 0
   \   0000AB   85..83       MOV     DPH,?XSP + 1
   \   0000AE   F0           MOVX    @DPTR,A
   1774                  // Send a response if unicast
   1775                  if ( !inMsg->wasBroadcast )
   \   0000AF   EE           MOV     A,R6
   \   0000B0   240B         ADD     A,#0xb
   \   0000B2   F582         MOV     DPL,A
   \   0000B4   EF           MOV     A,R7
   \   0000B5   12....       LCALL   ??Subroutine48_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   0000B8   703D         JNZ     ??zll_RouterProcessZDOMsg_2
   1776                  {
   1777                    ZDP_MgmtPermitJoinRsp( inMsg->TransSeq, &(inMsg->srcAddr), stat, false );
   \   0000BA                ; Setup parameters for call to function ZDP_SendData
   \   0000BA   75..00       MOV     ?V0 + 0,#0x0
   \   0000BD   78..         MOV     R0,#?V0 + 0
   \   0000BF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C2   7401         MOV     A,#0x1
   \   0000C4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C7   8582..       MOV     ?V0 + 0,DPL
   \   0000CA   8583..       MOV     ?V0 + 1,DPH
   \   0000CD   78..         MOV     R0,#?V0 + 0
   \   0000CF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000D2   75..36       MOV     ?V0 + 0,#0x36
   \   0000D5   75..80       MOV     ?V0 + 1,#-0x80
   \   0000D8   78..         MOV     R0,#?V0 + 0
   \   0000DA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000DD   7901         MOV     R1,#0x1
   \   0000DF   EE           MOV     A,R6
   \   0000E0   2402         ADD     A,#0x2
   \   0000E2   FC           MOV     R4,A
   \   0000E3   EF           MOV     A,R7
   \   0000E4   3400         ADDC    A,#0x0
   \   0000E6   FD           MOV     R5,A
   \   0000E7   EE           MOV     A,R6
   \   0000E8   240F         ADD     A,#0xf
   \   0000EA   FA           MOV     R2,A
   \   0000EB   EF           MOV     A,R7
   \   0000EC   3400         ADDC    A,#0x0
   \   0000EE   FB           MOV     R3,A
   \   0000EF   12....       LCALL   ??ZDP_SendData?relay
   \   0000F2   7405         MOV     A,#0x5
   \   0000F4   12....       LCALL   ?DEALLOC_XSTACK8
   1778                  }
   1779                }
   1780                break;
   1781          
   1782              default:
   1783                break;
   1784            }
   1785          }
   \                     ??zll_RouterProcessZDOMsg_2:
   \   0000F7   740C         MOV     A,#0xc
   \   0000F9   02....       LJMP    ?Subroutine0 & 0xFFFF
   1786          
   1787          /*********************************************************************
   1788           * @fn      zll_PermitJoin
   1789           *
   1790           * @brief   Set the router permit join flag, to allow or deny classical
   1791           *          commissioning by other ZigBee devices.
   1792           *
   1793           * @param   duration - enable up to aplcMaxPermitJoinDuration seconds,
   1794           *                     0 to disable
   1795           *
   1796           * @return  status
   1797           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1798          ZStatus_t zll_PermitJoin( uint8 duration )
   \                     zll_PermitJoin:
   1799          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   1800            if ( duration > ZLL_APLC_MAX_PERMIT_JOIN_DURATION )
   \   000007   C3           CLR     C
   \   000008   943D         SUBB    A,#0x3d
   \   00000A   4002         JC      ??zll_PermitJoin_0
   1801            {
   1802              duration = ZLL_APLC_MAX_PERMIT_JOIN_DURATION;
   \   00000C   7E3C         MOV     R6,#0x3c
   1803            }
   1804            return NLME_PermitJoiningRequest( duration );
   \                     ??zll_PermitJoin_0:
   \   00000E                ; Setup parameters for call to function NLME_PermitJoiningRequest
   \   00000E   EE           MOV     A,R6
   \   00000F   F9           MOV     R1,A
   \   000010   12....       LCALL   ??NLME_PermitJoiningRequest?relay
   \   000013   02....       LJMP    ?Subroutine5 & 0xFFFF
   1805          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for zll_EP_SimpleDesc>`:
   \   000000   0D           DB 13
   \   000001   5EC0         DW 49246
   \   000003   5EE1         DW 57694
   \   000005   02           DB 2
   \   000006   01           DB 1
   \   000007   ....         DW zll_EP_InClusterList
   \   000009   01           DB 1
   \   00000A   ....         DW zll_EP_OutClusterList

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for zll_EP>`:
   \   000000   0D           DB 13
   \   000001   ....         DW zllTaskId
   \   000003   0000         DW 0H
   \   000005   00           DB 0

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_RegisterSimpleDesc?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_RegisterSimpleDesc

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_InitVariables?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_InitVariables

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_InitFreeRanges?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_InitFreeRanges

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_RegisterApp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_RegisterApp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_IsFactoryNew?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_IsFactoryNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_UpdateFreeRanges?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_UpdateFreeRanges

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_IsValidSplitFreeRanges?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_IsValidSplitFreeRanges

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_SplitFreeRanges?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_SplitFreeRanges

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_PopGrpIDRange?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_PopGrpIDRange

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_PopNwkAddress?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_PopNwkAddress

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_GetNumSubDevices?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_GetNumSubDevices

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_GetNumGrpIDs?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_GetNumGrpIDs

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_GetSubDeviceInfo?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_GetSubDeviceInfo

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_EncryptNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_EncryptNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_DecryptNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_DecryptNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_BuildAesKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_BuildAesKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_UpdateNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_UpdateNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_GetNwkKeyBitmask?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_GetNwkKeyBitmask

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_GenerateRandNum?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_GenerateRandNum

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_GetRandPrimaryChannel?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_GetRandPrimaryChannel

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_SetNIB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_SetNIB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_ProcessNwkUpdate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_ProcessNwkUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_UpdateNV?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_UpdateNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_ItemInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_ItemInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_SetMacNwkParams?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_SetMacNwkParams

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_SetChannel?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_SetChannel

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_SendScanRsp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_SendScanRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_SendDeviceInfoRsp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_SendDeviceInfoRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_SendLeaveReq?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_SendLeaveReq

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_ResetToFactoryNew?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_ResetToFactoryNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_GetMsgRssi?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_GetMsgRssi

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_NewNwkUpdateId?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_NewNwkUpdateId

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_SetZllTaskId?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_SetZllTaskId

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_ClassicalCommissioningInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_ClassicalCommissioningInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_ClassicalCommissioningNetworkDisc?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_ClassicalCommissioningNetworkDisc

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_ClassicalCommissioningJoinDiscoveredNwk?r:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_ClassicalCommissioningJoinDiscoveredNwk

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_PerformNetworkDisc?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_PerformNetworkDisc

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_BeaconIndCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_BeaconIndCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_NwkDiscoveryCnfCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_NwkDiscoveryCnfCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_FreeNwkParamList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_FreeNwkParamList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_SetTCLK?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_SetTCLK

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_IsValidTransID?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_IsValidTransID

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_RouterProcessZDOMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_RouterProcessZDOMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zll_PermitJoin?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zll_PermitJoin

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {80, 104, 76, 105, 234, 156, 209, 5`:
   \   000000   50           DB 80
   \   000001   68           DB 104
   \   000002   4C           DB 76
   \   000003   69           DB 105
   \   000004   EA           DB 234
   \   000005   9C           DB 156
   \   000006   D1           DB 209
   \   000007   38           DB 56
   \   000008   43           DB 67
   \   000009   4C           DB 76
   \   00000A   53           DB 83
   \   00000B   4E           DB 78
   \   00000C   8F           DB 143
   \   00000D   8D           DB 141
   \   00000E   BA           DB 186
   \   00000F   B4           DB 180

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {192, 193, 194, 195, 196, 197, 198,`:
   \   000000   C0           DB 192
   \   000001   C1           DB 193
   \   000002   C2           DB 194
   \   000003   C3           DB 195
   \   000004   C4           DB 196
   \   000005   C5           DB 197
   \   000006   C6           DB 198
   \   000007   C7           DB 199
   \   000008   C8           DB 200
   \   000009   C9           DB 201
   \   00000A   CA           DB 202
   \   00000B   CB           DB 203
   \   00000C   CC           DB 204
   \   00000D   CD           DB 205
   \   00000E   CE           DB 206
   \   00000F   CF           DB 207

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {80, 104, 76, 105, 234, 156, 209, 5_1`:
   \   000000   50           DB 80
   \   000001   68           DB 104
   \   000002   4C           DB 76
   \   000003   69           DB 105
   \   000004   EA           DB 234
   \   000005   9C           DB 156
   \   000006   D1           DB 209
   \   000007   38           DB 56
   \   000008   43           DB 67
   \   000009   4C           DB 76
   \   00000A   53           DB 83
   \   00000B   4E           DB 78
   \   00000C   8F           DB 143
   \   00000D   8D           DB 141
   \   00000E   BA           DB 186
   \   00000F   B4           DB 180

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {192, 193, 194, 195, 196, 197, 198,_1`:
   \   000000   C0           DB 192
   \   000001   C1           DB 193
   \   000002   C2           DB 194
   \   000003   C3           DB 195
   \   000004   C4           DB 196
   \   000005   C5           DB 197
   \   000006   C6           DB 198
   \   000007   C7           DB 199
   \   000008   C8           DB 200
   \   000009   C9           DB 201
   \   00000A   CA           DB 202
   \   00000B   CB           DB 203
   \   00000C   CC           DB 204
   \   00000D   CD           DB 205
   \   00000E   CE           DB 206
   \   00000F   CF           DB 207

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {208, 209, 210, 211, 212, 213, 214,`:
   \   000000   D0           DB 208
   \   000001   D1           DB 209
   \   000002   D2           DB 210
   \   000003   D3           DB 211
   \   000004   D4           DB 212
   \   000005   D5           DB 213
   \   000006   D6           DB 214
   \   000007   D7           DB 215
   \   000008   D8           DB 216
   \   000009   D9           DB 217
   \   00000A   DA           DB 218
   \   00000B   DB           DB 219
   \   00000C   DC           DB 220
   \   00000D   DD           DB 221
   \   00000E   DE           DB 222
   \   00000F   DF           DB 223

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {{0}}>`:
   \   000000   00           DB 0
   \   000001   00000000     DB 0, 0, 0, 0, 0, 0, 0
   \            000000  
   \   000008   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000010   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000018   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1f40:
   \   000000   401F0000     DD 8000

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_2108800:
   \   000000   00881002     DD 34637824

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_5ef7000:
   \   000000   0070EF05     DD 99577856
   1806          
   1807          
   1808          /*********************************************************************
   1809          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK PSTACK XSTACK Function
   ------ ------ ------ --------
       1      0     20  zll_BeaconIndCB
                          0 0 20 -> osal_mem_alloc
                          0 0 20 -> osal_memset
                          0 0 20 -> sAddrExtCpy
       1      0    120  zll_BuildAesKey
       2      0      0  zll_ClassicalCommissioningInit
                          2 0  0 -> NLME_NwkDiscTerm
                          2 0  0 -> osal_stop_timerEx
                          2 0  0 -> zll_ClassicalCommissioningNetworkDisc
       0      0     13  zll_ClassicalCommissioningJoinDiscoveredNwk
                          0 0 13 -> NLME_JoinRequest
                          0 0  9 -> ZDApp_LeaveCtrlReset
                          0 0  9 -> ZDApp_ResetNwkKey
                          0 0  9 -> zll_FreeNwkParamList
                          0 0  9 -> zll_UpdateNV
       2      0      0  zll_ClassicalCommissioningNetworkDisc
                          2 0  0 -> zll_PerformNetworkDisc
       2      0     83  zll_DecryptNwkKey
                          0 0 70 -> osal_memcpy
                          0 0 67 -> sspAesDecrypt
                          0 0 67 -> sspAesEncrypt
                          0 0 75 -> zll_BuildAesKey
                          0 0 67 -> zll_UpdateNwkKey
       2      0    107  zll_EncryptNwkKey
                          0 0 91 -> SSP_ReadNwkActiveKey
                          0 0 94 -> osal_memcpy
                          0 0 91 -> sspAesEncrypt
                          0 0 99 -> zll_BuildAesKey
                          0 0 91 -> zll_GenerateRandNum
                          0 0 91 -> zll_IsFactoryNew
       0      0     18  zll_FreeNwkParamList
                          0 0  9 -> osal_mem_free
       1      0    104  zll_GenerateRandNum
                          0 0 13 -> osal_rand
       0      0     10  zll_GetMsgRssi
                          0 0 10 -> zcl_getRawAFMsg
       2      0     22  zll_GetNumGrpIDs
       2      0     22  zll_GetNumSubDevices
       0      0      0  zll_GetNwkKeyBitmask
       2      0      0  zll_GetRandPrimaryChannel
                          2 0  0 -> osal_rand
       0      0     36  zll_GetSubDeviceInfo
                          0 0 14 -> afFindEndPointDesc
                          0 0 14 -> osal_memset
       2      0     10  zll_InitFreeRanges
       0      0     14  zll_InitVariables
                          0 0 10 -> APSME_IsDistributedSecurity
                          0 0 10 -> NLME_SetBroadcastFilter
                          0 0 10 -> osal_memset
                          0 0 14 -> osal_nv_write
                          0 0 10 -> zll_InitFreeRanges
                          0 0 10 -> zll_IsFactoryNew
                          0 0 12 -> zll_ItemInit
                          0 0 10 -> zll_SetTCLK
       0      0    107  zll_IsFactoryNew
                          0 0 16 -> osal_nv_read
       2      0     32  zll_IsValidSplitFreeRanges
       0      0     16  zll_IsValidTransID
       0      0     28  zll_ItemInit
                          0 0 14 -> osal_nv_item_init
                          0 0 16 -> osal_nv_read
       0      0      9  zll_NewNwkUpdateId
       2      0      0  zll_NwkDiscoveryCnfCB
                          2 0  0 -> NLME_NwkDiscTerm
                          2 0  0 -> ZDO_DeregisterForZdoCB
                          2 0  0 -> osal_set_event
                          2 0  0 -> zll_ClassicalCommissioningNetworkDisc
       0      0     19  zll_PerformNetworkDisc
                          0 0 19 -> NLME_NwkDiscReq2
                          0 0 19 -> NLME_NwkDiscTerm
                          0 0 19 -> ZDO_RegisterForZdoCB
       0      0      9  zll_PermitJoin
                          0 0  9 -> NLME_PermitJoiningRequest
       2      0     10  zll_PopGrpIDRange
       4      0      0  zll_PopNwkAddress
       0      0     12  zll_ProcessNwkUpdate
                          0 0 12 -> NLME_SetUpdateID
                          0 0 12 -> ZDApp_NwkStateUpdateCB
                          0 0 12 -> nwkTransmissionFailures
                          0 0 12 -> zll_SetChannel
       0      0     10  zll_RegisterApp
                          0 0 10 -> zll_RegisterSimpleDesc
       1      0     20  zll_RegisterSimpleDesc
                          0 0 10 -> afRegister
                          0 0 10 -> osal_mem_alloc
       0      0      9  zll_ResetToFactoryNew
                          0 0  9 -> ZDApp_LeaveReset
                          0 0  9 -> ZDSecMgrUpdateTCAddress
                          0 0  9 -> osal_memset
                          0 0  9 -> zgWriteStartupOptions
                          0 0  9 -> zll_InitFreeRanges
                          0 0  9 -> zll_SendLeaveReq
                          0 0  9 -> zll_UpdateNV
       1      0     27  zll_RouterProcessZDOMsg
                          0 0 22 -> AssocCount
                          0 0 22 -> NLME_PermitJoiningRequest
                          0 0 22 -> NLME_UpdateLinkStatus
                          0 0 22 -> ZDO_ParseDeviceAnnce
                          0 0 27 -> ZDP_SendData
                          0 0 22 -> nwkNeighborAdd
                          0 0 22 -> nwkNeighborGetLinkInfo
       1      0     25  zll_SendDeviceInfoRsp
                          0 0 20 -> NLME_GetExtAddr
                          0 0 20 -> osal_mem_alloc
                          0 0 20 -> osal_mem_free
                          0 0 20 -> sAddrExtCpy
                          0 0 21 -> zclLL_Send_DeviceInfoRsp
                          0 0 20 -> zll_GetNumSubDevices
                          0 0 20 -> zll_GetSubDeviceInfo
       2      0     14  zll_SendLeaveReq
                          2 0  5 -> NLME_LeaveReq
                          2 0  5 -> osal_memset
       1      0     30  zll_SendScanRsp
                          0 0 22 -> osal_mem_alloc
                          0 0 22 -> osal_mem_free
                          0 0 22 -> osal_memset
                          0 0 22 -> osal_rand
                          0 0 26 -> osal_start_timerEx
                          0 0 22 -> sAddrExtCpy
                          0 0 23 -> zclLL_Send_ScanRsp
                          0 0 22 -> zll_GetNumGrpIDs
                          0 0 22 -> zll_GetNumSubDevices
                          0 0 22 -> zll_GetSubDeviceInfo
                          0 0 22 -> zll_IsFactoryNew
                          0 0 22 -> zll_IsValidSplitFreeRanges
       3      0     15  zll_SetChannel
                          2 0  2 -> ZMacGetReq
                          2 0  2 -> ZMacSetReq
       0      0     13  zll_SetMacNwkParams
                          0 0 13 -> ZMacSetReq
                          0 0 13 -> zll_SetChannel
       0      0     17  zll_SetNIB
                          0 0 13 -> NLME_SetUpdateID
                          0 0 13 -> sAddrExtCpy
                          0 0 13 -> zll_UpdateNV
       2      0     73  zll_SetTCLK
                          0 0 62 -> osal_memcpy
                          0 0 59 -> osal_memset
                          0 0 63 -> osal_nv_write
       0      0      9  zll_SetZllTaskId
                          0 0  9 -> StubAPS_RegisterApp
                          0 0  9 -> zll_RegisterSimpleDesc
       0      0     22  zll_SplitFreeRanges
       2      0      0  zll_UpdateFreeRanges
       0      0     27  zll_UpdateNV
                          0 0 14 -> osal_nv_write
                          0 0 10 -> zgWriteStartupOptions
       0      0     79  zll_UpdateNwkKey
                          0 0 12 -> SSP_SwitchNwkKey
                          0 0 12 -> SSP_UpdateNwkKey
                          0 0 12 -> ZDApp_SaveNwkKey


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?<Constant {192, 193, 194, 195, 196, 197, 198,
      16  ?<Constant {192, 193, 194, 195, 196, 197, 198,_1
      16  ?<Constant {208, 209, 210, 211, 212, 213, 214,
      16  ?<Constant {80, 104, 76, 105, 234, 156, 209, 5
      16  ?<Constant {80, 104, 76, 105, 234, 156, 209, 5_1
      32  ?<Constant {{0}}>
       6  ?<Initializer for zll_EP>
      12  ?<Initializer for zll_EP_SimpleDesc>
       5  ??Subroutine35_0
       5  ??Subroutine36_0
       5  ??Subroutine37_0
       6  ??Subroutine38_0
       7  ??Subroutine39_0
       3  ??Subroutine40_0
       5  ??Subroutine41_0
       2  ??Subroutine42_0
       6  ??Subroutine43_0
       6  ??Subroutine44_0
       3  ??Subroutine45_0
       8  ??Subroutine46_0
       3  ??Subroutine47_0
       6  ??Subroutine48_0
       6  ??zll_BeaconIndCB?relay
       6  ??zll_BuildAesKey?relay
       6  ??zll_ClassicalCommissioningInit?relay
       6  ??zll_ClassicalCommissioningJoinDiscoveredNwk?r
       6  ??zll_ClassicalCommissioningNetworkDisc?relay
       6  ??zll_DecryptNwkKey?relay
       6  ??zll_EncryptNwkKey?relay
       6  ??zll_FreeNwkParamList?relay
       6  ??zll_GenerateRandNum?relay
       6  ??zll_GetMsgRssi?relay
       6  ??zll_GetNumGrpIDs?relay
       6  ??zll_GetNumSubDevices?relay
       6  ??zll_GetNwkKeyBitmask?relay
       6  ??zll_GetRandPrimaryChannel?relay
       6  ??zll_GetSubDeviceInfo?relay
       6  ??zll_InitFreeRanges?relay
       6  ??zll_InitVariables?relay
       6  ??zll_IsFactoryNew?relay
       6  ??zll_IsValidSplitFreeRanges?relay
       6  ??zll_IsValidTransID?relay
       6  ??zll_ItemInit?relay
       6  ??zll_NewNwkUpdateId?relay
       6  ??zll_NwkDiscoveryCnfCB?relay
       6  ??zll_PerformNetworkDisc?relay
       6  ??zll_PermitJoin?relay
       6  ??zll_PopGrpIDRange?relay
       6  ??zll_PopNwkAddress?relay
       6  ??zll_ProcessNwkUpdate?relay
       6  ??zll_RegisterApp?relay
       6  ??zll_RegisterSimpleDesc?relay
       6  ??zll_ResetToFactoryNew?relay
       6  ??zll_RouterProcessZDOMsg?relay
       6  ??zll_SendDeviceInfoRsp?relay
       6  ??zll_SendLeaveReq?relay
       6  ??zll_SendScanRsp?relay
       6  ??zll_SetChannel?relay
       6  ??zll_SetMacNwkParams?relay
       6  ??zll_SetNIB?relay
       6  ??zll_SetTCLK?relay
       6  ??zll_SetZllTaskId?relay
       6  ??zll_SplitFreeRanges?relay
       6  ??zll_UpdateFreeRanges?relay
       6  ??zll_UpdateNV?relay
       6  ??zll_UpdateNwkKey?relay
       3  ?Subroutine0
       3  ?Subroutine1
      17  ?Subroutine10
      13  ?Subroutine11
      10  ?Subroutine12
       5  ?Subroutine13
       6  ?Subroutine14
       6  ?Subroutine15
       9  ?Subroutine16
      15  ?Subroutine17
       7  ?Subroutine18
       1  ?Subroutine19
       5  ?Subroutine2
      12  ?Subroutine20
       5  ?Subroutine21
       6  ?Subroutine22
      10  ?Subroutine23
      11  ?Subroutine24
       9  ?Subroutine25
       2  ?Subroutine26
      10  ?Subroutine27
       3  ?Subroutine28
       3  ?Subroutine29
       5  ?Subroutine3
      12  ?Subroutine30
      17  ?Subroutine31
       8  ?Subroutine32
      11  ?Subroutine33
       9  ?Subroutine34
       5  ?Subroutine4
       5  ?Subroutine5
       5  ?Subroutine6
       1  ?Subroutine7
       3  ?Subroutine8
      10  ?Subroutine9
       4  __Constant_1
       4  __Constant_1f40
       4  __Constant_2108800
       4  __Constant_5ef7000
       2  pDiscoveredNwkParamList
       2  zllFreeGrpIdBegin
       2  zllFreeGrpIdEnd
       2  zllFreeNwkAddrBegin
       2  zllFreeNwkAddrEnd
       2  zllGrpIDsBegin
       2  zllGrpIDsEnd
       1  zllHAScanInitiated
       1  zllIsInitiator
       1  zllJoinedHANetwork
       4  zllLastAcceptedTransID
       1  zllLeaveInitiated
       4  zllResponseID
      10  zllSubDevicesTbl
       1  zllTaskId
       4  zllTransID
     513  zll_BeaconIndCB
     289  zll_BuildAesKey
      36  zll_ClassicalCommissioningInit
     237  zll_ClassicalCommissioningJoinDiscoveredNwk
      45  zll_ClassicalCommissioningNetworkDisc
     202  zll_DecryptNwkKey
       6  zll_EP
       2  zll_EP_InClusterList
       2  zll_EP_OutClusterList
      12  zll_EP_SimpleDesc
     278  zll_EncryptNwkKey
      42  zll_FreeNwkParamList
      75  zll_GenerateRandNum
      34  zll_GetMsgRssi
      39  zll_GetNumGrpIDs
      27  zll_GetNumSubDevices
       7  zll_GetNwkKeyBitmask
      45  zll_GetRandPrimaryChannel
      99  zll_GetSubDeviceInfo
      75  zll_InitFreeRanges
     304  zll_InitVariables
      90  zll_IsFactoryNew
     103  zll_IsValidSplitFreeRanges
      62  zll_IsValidTransID
      61  zll_ItemInit
      51  zll_NewNwkUpdateId
      73  zll_NwkDiscoveryCnfCB
      91  zll_PerformNetworkDisc
      22  zll_PermitJoin
      98  zll_PopGrpIDRange
      54  zll_PopNwkAddress
      67  zll_ProcessNwkUpdate
     104  zll_RegisterApp
      59  zll_RegisterSimpleDesc
      80  zll_ResetToFactoryNew
     252  zll_RouterProcessZDOMsg
     241  zll_SendDeviceInfoRsp
      46  zll_SendLeaveReq
     585  zll_SendScanRsp
      54  zll_SetChannel
      75  zll_SetMacNwkParams
     169  zll_SetNIB
     165  zll_SetTCLK
      27  zll_SetZllTaskId
     224  zll_SplitFreeRanges
      74  zll_UpdateFreeRanges
     295  zll_UpdateNV
      37  zll_UpdateNwkKey

 
 5 938 bytes in segment BANKED_CODE
   264 bytes in segment BANK_RELAYS
    18 bytes in segment XDATA_I
    18 bytes in segment XDATA_ID
   132 bytes in segment XDATA_ROM_C
    41 bytes in segment XDATA_Z
 
 6 220 bytes of CODE  memory
   116 bytes of CONST memory (+ 16 bytes shared)
    59 bytes of XDATA memory

Errors: none
Warnings: none
